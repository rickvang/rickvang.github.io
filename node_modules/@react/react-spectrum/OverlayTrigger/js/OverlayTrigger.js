'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class;

var _autobindDecorator = require('autobind-decorator');

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

var _createId = require('../../utils/createId');

var _createId2 = _interopRequireDefault(_createId);

var _ModalContainer = require('../../ModalContainer/js/ModalContainer.js');

var _Overlay = require('./Overlay');

var _Overlay2 = _interopRequireDefault(_Overlay);

var _ownerDocument = require('react-overlays/lib/utils/ownerDocument');

var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var triggerType = _propTypes2.default.oneOf(['click', 'hover', 'focus']);

/**
 * Check if value one is inside or equal to the of value
 *
 * @param {string} one
 * @param {string|array} of
 * @returns {boolean}
 */
function isOneOf(one, of) {
  if (Array.isArray(of)) {
    return of.indexOf(one) >= 0;
  }
  return one === of;
}

/**
 * Find all of the scrollable parents of a DOM node
 */
function getScrollParents(node) {
  var nodes = [];
  while (node.parentNode) {
    var style = window.getComputedStyle(node);

    // Look for scrollable nodes, both real and fake.
    if (/auto|scroll/.test(style.overflow + style.overflowY) || node.hasAttribute('data-scrollable')) {
      nodes.push(node);
    }

    node = node.parentNode;
  }

  return nodes;
}

/*
 * Class based on React-bootstrap
 * https://github.com/react-bootstrap/react-bootstrap/blob/master/src/OverlayTrigger.js
 */

var OverlayTrigger = (0, _autobindDecorator2.default)(_class = function (_Component) {
  _inherits(OverlayTrigger, _Component);

  function OverlayTrigger(props, context) {
    _classCallCheck(this, OverlayTrigger);

    var _this = _possibleConstructorReturn(this, (OverlayTrigger.__proto__ || Object.getPrototypeOf(OverlayTrigger)).call(this, props, context));

    _this.overlayId = (0, _createId2.default)();
    _this._mountNode = null;
    _this.state = {
      show: props.show === undefined ? props.defaultShow : props.show
    };
    return _this;
  }

  _createClass(OverlayTrigger, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.show !== this.props.show) {
        nextProps.show ? this.handleDelayedShow() : this.handleDelayedHide();
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._mountNode = document.createElement('div');
      this.renderOverlay();

      this._scrollParents = getScrollParents(_reactDom2.default.findDOMNode(this));
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._scrollParents[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var node = _step.value;

          node.addEventListener('scroll', this.hide, false);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      var isDisabled = prevProps.disabled;
      var shouldDisable = this.props.disabled;
      if (!isDisabled && shouldDisable) {
        this.hide();
      }
      this.renderOverlay();
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      _ModalContainer.modalManager.removeFromModal(this._overlay);
      _reactDom2.default.unmountComponentAtNode(this._mountNode);
      this._mountNode = null;

      clearTimeout(this._hoverShowDelay);
      clearTimeout(this._hoverHideDelay);

      if (this._scrollParents) {
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this._scrollParents[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var node = _step2.value;

            node.removeEventListener('scroll', this.hide, false);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }

        this._scrollParents = null;
      }
    }
  }, {
    key: 'handleToggle',
    value: function handleToggle(e) {
      if (this.state.show) {
        this.hide(e);
      } else {
        this.show(e);
      }
    }
  }, {
    key: 'handleDelayedShow',
    value: function handleDelayedShow(e) {
      var _this2 = this;

      if (this._hoverHideDelay != null) {
        clearTimeout(this._hoverHideDelay);
        this._hoverHideDelay = null;
        return;
      }

      if (this.state.show || this._hoverShowDelay != null) {
        return;
      }

      var delay = this.props.delayShow != null ? this.props.delayShow : this.props.delay;

      if (!delay) {
        this.show(e);
        return;
      }

      this._hoverShowDelay = setTimeout(function () {
        _this2._hoverShowDelay = null;
        _this2.show(e);
      }, delay);
    }
  }, {
    key: 'handleDelayedHide',
    value: function handleDelayedHide(e) {
      var _this3 = this;

      if (this._hoverShowDelay != null) {
        clearTimeout(this._hoverShowDelay);
        this._hoverShowDelay = null;
        return;
      }

      if (!this.state.show || this._hoverHideDelay != null) {
        return;
      }

      var delay = (!this.props.delayHide || this.props.delayHide === OverlayTrigger.defaultProps.delayHide) && this.props.delay != null ? this.props.delay : this.props.delayHide;

      if (!delay) {
        this.hide(e);
        return;
      }

      this._hoverHideDelay = setTimeout(function () {
        _this3._hoverHideDelay = null;
        _this3.hide(e);
      }, delay);
    }

    // Simple implementation of mouseEnter and mouseLeave.
    // React's built version is broken: https://github.com/facebook/react/issues/4251
    // for cases when the trigger is disabled and mouseOut/Over can cause flicker
    // moving from one child element to another.

  }, {
    key: 'handleMouseOverOut',
    value: function handleMouseOverOut(handler, e) {
      var target = e.currentTarget;
      var related = e.relatedTarget || e.nativeEvent.toElement;

      if (!related || related !== target && !target.contains(related)) {
        handler(e);
      }
    }
  }, {
    key: 'show',
    value: function show(e) {
      if (!this.state.show && !this.props.disabled) {
        this.setState({ show: true });
        if (this.props.onShow) {
          this.props.onShow(e);
        }
      }
    }
  }, {
    key: 'hide',
    value: function hide(e) {
      if (this.state.show) {
        this.setState({ show: false });
        if (this.props.onHide) {
          this.props.onHide(e);
        }
      }
    }
  }, {
    key: 'makeOverlay',
    value: function makeOverlay(overlay, props) {
      var _props$target = this.props.target,
          target = _props$target === undefined ? this : _props$target;

      var _props$rootClose = props.rootClose,
          rootClose = _props$rootClose === undefined ? true : _props$rootClose,
          overlayProps = _objectWithoutProperties(props, ['rootClose']);

      delete overlayProps.crossOffset;
      delete overlayProps.defaultShow;
      delete overlayProps.flip;
      delete overlayProps.boundariesElement;
      delete overlayProps.shouldUpdatePosition;
      if (!overlay.props.id) {
        overlayProps.id = this.overlayId;
      }
      if (!props.id) {
        props.id = overlay.props.id || overlayProps.id;
      }
      return _react2.default.createElement(
        _Overlay2.default,
        _extends({}, props, {
          show: this.state.show,
          onHide: this.hide,
          target: target,
          rootClose: rootClose }),
        (0, _react.cloneElement)(overlay, overlayProps)
      );
    }
  }, {
    key: 'renderOverlay',
    value: function renderOverlay() {
      // Only add overlay to modalManager when it is shown.
      if (this._overlay.props.show) {
        _ModalContainer.modalManager.addToModal(this._overlay);
      }

      _reactDom2.default.unstable_renderSubtreeIntoContainer(this, this._overlay, this._mountNode);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          trigger = _props.trigger,
          show = _props.show,
          _props$selected = _props.selected,
          selected = _props$selected === undefined ? this.state.show : _props$selected,
          props = _objectWithoutProperties(_props, ['trigger', 'show', 'selected']);

      delete props.delay;
      delete props.delayShow;
      delete props.delayHide;
      delete props.defaultShow;
      delete props.onShow;
      delete props.onHide;

      var _React$Children$toArr = _react2.default.Children.toArray(this.props.children),
          _React$Children$toArr2 = _slicedToArray(_React$Children$toArr, 2),
          triggerChild = _React$Children$toArr2[0],
          overlayChild = _React$Children$toArr2[1];

      var triggerProps = {};
      delete props.children;

      // When Tooltip is shown,
      if (this.state.show && overlayChild.type && overlayChild.props.role === 'tooltip') {
        // Tooltip element id should match trigger element's aria-describedby value,
        if (!props.id) {
          props.id = overlayChild.props.id || this.overlayId;
        }

        // Tooltip should add aria-describedby attribute to trigger element.
        triggerProps['aria-describedby'] = props.id;
      }

      // Attach trigger events in case on un-controlled overlay
      if (show === undefined) {
        if (isOneOf('click', trigger)) {
          triggerProps.onClick = this.handleToggle;
        }

        if (isOneOf('hover', trigger)) {
          triggerProps.onMouseOver = this.handleMouseOverOut.bind(this, this.handleDelayedShow);
          triggerProps.onMouseOut = this.handleMouseOverOut.bind(this, this.handleDelayedHide);
          props.onMouseOver = this.handleMouseOverOut.bind(this, this.handleDelayedShow);
          props.onMouseOut = this.handleMouseOverOut.bind(this, this.handleDelayedHide);
        }

        if (isOneOf('focus', trigger)) {
          triggerProps.onFocus = this.handleDelayedShow;
          triggerProps.onBlur = this.handleDelayedHide;
          props.onFocus = this.handleDelayedShow;
          props.onBlur = this.handleDelayedHide;
        }
      }

      triggerProps.selected = selected;

      // Remove previous overlay from modalManager
      if (this._overlay) {
        _ModalContainer.modalManager.removeFromModal(this._overlay);
      }

      this._overlay = this.makeOverlay(overlayChild, props);

      return (0, _react.cloneElement)(triggerChild, triggerProps);
    }
  }]);

  return OverlayTrigger;
}(_react.Component)) || _class;

OverlayTrigger.propTypes = _extends({}, _Overlay2.default.propTypes, {
  /**
  * Specify which action or actions trigger Overlay visibility
  */
  trigger: _propTypes2.default.oneOfType([triggerType, _propTypes2.default.arrayOf(triggerType)]),
  /**
   * A millisecond delay amount to show and hide the Overlay once triggered
   */
  delay: _propTypes2.default.number,
  /**
   * A millisecond delay amount before showing the Overlay once triggered.
   */
  delayShow: _propTypes2.default.number,
  /**
   * A millisecond delay amount before hiding the Overlay once triggered.
   */
  delayHide: _propTypes2.default.number,
  /**
   * The initial visibility state of the Overlay. For more nuanced visibility
   * control, consider using the Overlay component directly.
   */
  defaultShow: _propTypes2.default.bool,
  /**
   * Callback when the overlay trigger is blurred.
   */
  onBlur: _propTypes2.default.func,
  /**
   * Callback when the overlay trigger is clicked.
   */
  onClick: _propTypes2.default.func,
  /**
   * Callback when the overlay trigger receives focus.
   */
  onFocus: _propTypes2.default.func,
  /**
   * Callback when the mouse leaves the overlay trigger.
   */
  onMouseOut: _propTypes2.default.func,
  /**
   * Callback when the mouse is over the overlay trigger.
   */
  onMouseOver: _propTypes2.default.func,
  /**
   * Callback when the overlay show is invoked, determined by the 'trigger' prop.
   */
  onShow: _propTypes2.default.func,
  /**
   * Callback when the overlay is hidden.
   */
  onHide: _propTypes2.default.func,
  /**
   * Will cause the overlay to show in a controlled state.
   */
  show: _propTypes2.default.bool,
  /**
   * Overlay will be shifted by specified units in the placement's axis direction.
   */
  offset: _propTypes2.default.number,
  /**
   * Overlay will be shifted by specified units in the placement's cross-axis direction.
   */
  crossOffset: _propTypes2.default.number,
  /**
   * Whether overlay should be allowed to flip if it hits the boundary
   */
  flip: _propTypes2.default.bool,
  /**
   * Grey's out the trigger and removes interaction.
   */
  disabled: _propTypes2.default.bool,
  /**
   * By default, the body of the owning document. The overlay will do a hit test to see if it
   * extends outside the boundaries and move it to a new position if it collides.
   */
  boundariesElement: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string])
});
OverlayTrigger.defaultProps = {
  defaultShow: false,
  trigger: ['hover', 'focus'],
  placement: 'left',
  offset: 0,
  crossOffset: 0,
  flip: true,
  disabled: false,
  boundariesElement: function boundariesElement() {
    return (0, _ownerDocument2.default)(undefined).body;
  },
  delayHide: 100
};
exports.default = OverlayTrigger;