{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TABBABLE_ELEMENT_SELECTOR = exports.FOCUSABLE_ELEMENT_SELECTOR = exports.default = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _class;\n\nexports.trapFocus = trapFocus;\n\nvar _autobindDecorator = require('autobind-decorator');\n\nvar _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);\n\nvar _events = require('./events');\n\nvar _propTypes = require('prop-types');\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nvar _string = require('./string');\n\nvar _scrollToDOMNode = require('./scrollToDOMNode');\n\nvar _scrollToDOMNode2 = _interopRequireDefault(_scrollToDOMNode);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar WHITESPACE_REGEXP = /[\\n\\r]+|[\\s]{1,}/g;\nvar DELAY_BEFORE_AUTOFOCUS = 20;\n\nvar FocusManager = (0, _autobindDecorator2.default)(_class = function (_React$Component) {\n  _inherits(FocusManager, _React$Component);\n\n  function FocusManager() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, FocusManager);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = FocusManager.__proto__ || Object.getPrototypeOf(FocusManager)).call.apply(_ref, [this].concat(args))), _this), _this.keysSoFar = '', _this.keyClearTimeout = null, _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(FocusManager, [{\n    key: 'getItems',\n    value: function getItems() {\n      var selected = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var _props = this.props,\n          itemSelector = _props.itemSelector,\n          selectedItemSelector = _props.selectedItemSelector,\n          includeSelf = _props.includeSelf;\n      var selector = selected && selectedItemSelector ? selectedItemSelector : itemSelector;\n\n      var node = _reactDom2.default.findDOMNode(this);\n\n      var array = [];\n\n      if (includeSelf && node.matches(selector)) {\n        array.push(node);\n      }\n\n      return array.concat(Array.from(node.querySelectorAll(selector)));\n    }\n  }, {\n    key: 'onFocusFirst',\n    value: function onFocusFirst(e) {\n      var items = this.getItems();\n\n      if (items.length && (!e || items.indexOf(e.target) !== -1)) {\n        if (e) {\n          e.preventDefault();\n        }\n\n        items[0].focus();\n      }\n    }\n  }, {\n    key: 'onFocusLast',\n    value: function onFocusLast(e) {\n      var items = this.getItems();\n\n      if (items.length && (!e || items.indexOf(e.target) !== -1)) {\n        if (e) {\n          e.preventDefault();\n        }\n\n        items[items.length - 1].focus();\n      }\n    }\n  }, {\n    key: 'onFocusPrevious',\n    value: function onFocusPrevious(e) {\n      var items = this.getItems();\n\n      if (items.length && e && items.indexOf(e.target) !== -1) {\n        e.preventDefault();\n        var index = items.indexOf(e.target) - 1;\n\n        if (index < 0) {\n          index = items.length - 1;\n        }\n\n        items[index].focus();\n      }\n    }\n  }, {\n    key: 'onFocusNext',\n    value: function onFocusNext(e) {\n      var items = this.getItems();\n\n      if (items.length && e && items.indexOf(e.target) !== -1) {\n        e.preventDefault();\n        var index = items.indexOf(e.target) + 1;\n\n        if (index >= items.length) {\n          index = 0;\n        }\n\n        items[index].focus();\n      }\n    }\n  }, {\n    key: 'onPageUp',\n    value: function onPageUp(e) {\n      if (this.props.ignorePageUpPageDown) {\n        return;\n      }\n\n      var items = this.getItems();\n\n      if (items.length && e && items.indexOf(e.target) !== -1) {\n        e.preventDefault();\n\n        var listNode = _reactDom2.default.findDOMNode(this);\n\n        var nextPage = Math.max(e.target.offsetTop + e.target.offsetHeight - listNode.clientHeight, 0);\n        var index = items.indexOf(e.target);\n        var item = items.slice(0, index).reverse().find(function (item) {\n          return item.offsetTop < nextPage;\n        });\n\n        if (item) {\n          item.focus();\n          (0, _scrollToDOMNode2.default)(item, listNode, true);\n        } else {\n          this.onFocusFirst(e);\n        }\n      }\n    }\n  }, {\n    key: 'onPageDown',\n    value: function onPageDown(e) {\n      if (this.props.ignorePageUpPageDown) {\n        return;\n      }\n\n      var items = this.getItems();\n\n      if (items.length && e && items.indexOf(e.target) !== -1) {\n        e.preventDefault();\n\n        var listNode = _reactDom2.default.findDOMNode(this);\n\n        var nextPage = Math.min(e.target.offsetTop + listNode.clientHeight, listNode.scrollHeight + listNode.clientHeight);\n        var index = items.indexOf(e.target) + 1;\n        var item = items.slice(index).find(function (item) {\n          return item.offsetTop + item.offsetHeight > nextPage;\n        });\n\n        if (item) {\n          item.focus();\n          (0, _scrollToDOMNode2.default)(item, listNode, true);\n        } else {\n          this.onFocusLast(e);\n        }\n      }\n    }\n  }, {\n    key: 'findItemToFocus',\n    value: function findItemToFocus(e) {\n      var target = e.target,\n          shiftKey = e.shiftKey,\n          charCode = e.charCode;\n      var character = (0, _string.removeDiacritics)(String.fromCharCode(charCode)).toUpperCase();\n      var items = this.getItems();\n\n      if (this.keysSoFar === '' || character === this.keysSoFar || shiftKey) {\n        // reverse order if shiftKey is pressed\n        if (shiftKey) {\n          items = items.reverse();\n        }\n\n        this.searchIndex = items.indexOf(target);\n      }\n\n      if (character !== this.keysSoFar) {\n        this.keysSoFar += character;\n      }\n\n      this.clearKeysSoFarAfterDelay();\n      var item = this.findMatchInRange(items, this.searchIndex + 1, items.length);\n\n      if (!item) {\n        item = this.findMatchInRange(items, 0, this.searchIndex);\n      }\n\n      if (item) {\n        item.focus();\n      }\n    }\n  }, {\n    key: 'clearKeysSoFarAfterDelay',\n    value: function clearKeysSoFarAfterDelay() {\n      var _this2 = this;\n\n      if (this.keyClearTimeout) {\n        clearTimeout(this.keyClearTimeout);\n      }\n\n      this.keyClearTimeout = setTimeout(function () {\n        return _this2.keysSoFar = '';\n      }, 500);\n    }\n  }, {\n    key: 'findMatchInRange',\n    value: function findMatchInRange(items, startIndex, endIndex) {\n      // Find the first item starting with the keysSoFar substring, searching in the specified range of items\n      for (var i = startIndex; i < endIndex; i++) {\n        var label = items[i].innerText || items[i].textContent;\n\n        if (label && (0, _string.removeDiacritics)(label).replace(WHITESPACE_REGEXP, '').toUpperCase().indexOf(this.keysSoFar) === 0) {\n          return items[i];\n        }\n      }\n\n      return null;\n    }\n    /**\n     * Handle keydown event\n     * @param {Event} e Event object\n     */\n\n  }, {\n    key: 'onKeyDown',\n    value: function onKeyDown(e) {\n      if (e.isPropagationStopped()) {\n        return;\n      }\n\n      _events.interpretKeyboardEvent.call(this, e, this.props.orientation);\n    }\n    /**\n     * Handle keypress event\n     * @param {Event} e Event object\n     */\n\n  }, {\n    key: 'onKeyPress',\n    value: function onKeyPress(e) {\n      if (e.isPropagationStopped()) {\n        return;\n      }\n\n      this.findItemToFocus(e);\n    }\n    /**\n     * When an item receives focus, it should have tabIndex === 0 and all other items should have tabIndex === -1\n     * @param {Event} e Event object\n     */\n\n  }, {\n    key: 'onFocus',\n    value: function onFocus(e) {\n      if (e.isPropagationStopped()) {\n        return;\n      }\n\n      this.getItems().forEach(function (item) {\n        return item.tabIndex = item === e.target ? 0 : -1;\n      });\n    }\n    /**\n     * When an item loses focus, set the appropriate tabIndex on each item based on its selected state.\n     * If the item losing focus is selected,\n     * it should be the only item to receive focus on shift+tab or tab back to the control,\n     * However, if the item losing focus is not selected,\n     * any of the selected items should receive focus on shift+tab or tab.\n     * @param {Event} e Event object\n     */\n\n  }, {\n    key: 'onBlur',\n    value: function onBlur(e) {\n      if (e.isPropagationStopped()) {\n        return;\n      }\n\n      var selectedItems = this.getItems(true); // If there are selected items,\n\n      if (selectedItems.length) {\n        // store whether item losing focus is selected.\n        var targetSelected = selectedItems.indexOf(e.target) !== -1;\n        this.getItems().forEach(function (item) {\n          // store whether the current item is selected.\n          var selected = selectedItems.indexOf(item) !== -1; // If the current item is the item losing focus and it is selected,\n          // or the current item is selected and the item losing focus is not selected,\n          // set tabIndex === 0, otherwise set tabIndex === -1.\n\n          item.tabIndex = item === e.target && targetSelected || !targetSelected && selected ? 0 : -1;\n        });\n      }\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _this3 = this;\n\n      var _props2 = this.props,\n          autoFocus = _props2.autoFocus,\n          selectedItemSelector = _props2.selectedItemSelector;\n\n      if (autoFocus) {\n        var selectedItem = selectedItemSelector ? _reactDom2.default.findDOMNode(this).querySelector(selectedItemSelector) : null; // wait a frame before trying to shift focus\n\n        this.focusTimer = setTimeout(function () {\n          if (selectedItem) {\n            selectedItem.focus();\n          } else {\n            _this3.onFocusFirst();\n          }\n        }, DELAY_BEFORE_AUTOFOCUS);\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      clearTimeout(this.focusTimer);\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var _props3 = this.props,\n          children = _props3.children,\n          disabled = _props3.disabled,\n          manageTabIndex = _props3.manageTabIndex,\n          typeToSelect = _props3.typeToSelect;\n\n      var child = _react2.default.Children.only(children);\n\n      var _child$props = child.props,\n          onKeyDown = _child$props.onKeyDown,\n          onKeyPress = _child$props.onKeyPress,\n          onFocus = _child$props.onFocus,\n          onBlur = _child$props.onBlur;\n      return _react2.default.cloneElement(child, {\n        onKeyDown: !disabled ? (0, _events.chain)(onKeyDown, this.onKeyDown) : onKeyDown,\n        onKeyPress: typeToSelect && !disabled ? (0, _events.chain)(onKeyPress, this.onKeyPress) : onKeyPress,\n        onFocus: manageTabIndex && !disabled ? (0, _events.chain)(onFocus, this.onFocus) : onFocus,\n        onBlur: manageTabIndex && !disabled ? (0, _events.chain)(onBlur, this.onBlur) : onBlur\n      });\n    }\n  }]);\n\n  return FocusManager;\n}(_react2.default.Component)) || _class;\n\nFocusManager.propTypes = {\n  /**\n   * A selector of focusable elements to manage focus between\n   */\n  itemSelector: _propTypes2.default.string.isRequired,\n\n  /**\n   * Whether to use roving tabIndex so that only one element within the group can receive focus with tab key at a time.\n   */\n  manageTabIndex: _propTypes2.default.bool,\n\n  /**\n   * Orientation of items; \"horizontal\" orientation ignores up/down arrow keys, \"vertical\" orientation ignores left/right arrow keys, \"both\" handles up/left and down/right.\n   */\n  orientation: _propTypes2.default.oneOf(['horizontal', 'vertical', 'both']),\n\n  /**\n   * A selector of selected elements\n   */\n  selectedItemSelector: _propTypes2.default.string,\n\n  /**\n   * Whether to disable focus management\n   */\n  disabled: _propTypes2.default.bool,\n\n  /**\n   * Whether to include alphanumeric typing as a way to move focus to items in a list.\n   */\n  typeToSelect: _propTypes2.default.bool,\n\n  /**\n   * Whether to include the child wrapper element in the group of elements that can receive focus.\n   */\n  includeSelf: _propTypes2.default.bool,\n\n  /**\n   * Whether to ignore PageUp and PageDown events to move focus between items.\n   */\n  ignorePageUpPageDown: _propTypes2.default.bool,\n\n  /**\n   * Whether to autoFocus first selected item or first item.\n   */\n  autoFocus: _propTypes2.default.bool\n};\nFocusManager.defaultProps = {\n  manageTabIndex: true,\n  orientation: 'vertical',\n  typeToSelect: false,\n  includeSelf: false,\n  ignorePageUpPageDown: false\n};\nexports.default = FocusManager;\nvar focusableElements = ['input:not([disabled]):not([type=hidden])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'a[href]', 'area[href]', 'summary', 'iframe', 'object', 'embed', 'audio[controls]', 'video[controls]', '[contenteditable]'];\nvar FOCUSABLE_ELEMENT_SELECTOR = exports.FOCUSABLE_ELEMENT_SELECTOR = focusableElements.join(',') + ',[tabindex]';\nfocusableElements.push('[tabindex]:not([tabindex=\"-1\"])');\nvar TABBABLE_ELEMENT_SELECTOR = exports.TABBABLE_ELEMENT_SELECTOR = focusableElements.join(':not([tabindex=\"-1\"]),');\n\nfunction trapFocus(componentOrElement, event) {\n  var type = event.type,\n      key = event.key,\n      shiftKey = event.shiftKey,\n      target = event.target;\n  var node = void 0;\n  var tabbables = void 0;\n  var tabbable = void 0;\n  var first = void 0;\n  var last = void 0;\n\n  if (type === 'keydown' || type === 'focus') {\n    node = _reactDom2.default.findDOMNode(componentOrElement);\n\n    if (node) {\n      // find tabbable elements within container element\n      tabbables = Array.from(node.querySelectorAll(TABBABLE_ELEMENT_SELECTOR)).filter(function (el) {\n        return el !== node;\n      });\n      first = tabbables[0];\n      last = tabbables[tabbables.length - 1];\n    }\n  } // If navigating using the tab key,\n\n\n  if (type === 'keydown' && key === 'Tab') {\n    if (node) {\n      if (shiftKey) {\n        // with focus on first tabbable element, navigating backwards,\n        if (target === first) {\n          // focus the last tabbable element\n          tabbable = last;\n        } // otherwise, with focus on last tabbable element, navigating forwards,\n\n      } else if (target === last) {\n        // focus the first tabbable element.\n        tabbable = first;\n      }\n    }\n  } else if (type === 'focus') {\n    if (target === node) {\n      tabbable = first;\n    }\n  }\n\n  if (tabbable) {\n    event.preventDefault();\n    event.stopPropagation();\n    tabbable.focus();\n  }\n}","map":null,"metadata":{},"sourceType":"script"}