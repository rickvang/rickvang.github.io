'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class;

var _autobindDecorator = require('autobind-decorator');

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

var _Button = require('../../Button');

var _Button2 = _interopRequireDefault(_Button);

var _ChevronLeftLarge = require('../../Icon/core/ChevronLeftLarge');

var _ChevronLeftLarge2 = _interopRequireDefault(_ChevronLeftLarge);

var _ChevronRightLarge = require('../../Icon/core/ChevronRightLarge');

var _ChevronRightLarge2 = _interopRequireDefault(_ChevronRightLarge);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _createId = require('../../utils/createId');

var _createId2 = _interopRequireDefault(_createId);

var _momentRange = require('moment-range');

var _filterDOMProps = require('../../utils/filterDOMProps');

var _filterDOMProps2 = _interopRequireDefault(_filterDOMProps);

var _moment = require('../../utils/moment');

var _intl = require('../../utils/intl');

var _LiveRegionAnnouncer = require('../../utils/LiveRegionAnnouncer');

var _LiveRegionAnnouncer2 = _interopRequireDefault(_LiveRegionAnnouncer);

var _moment2 = require('moment');

var _moment3 = _interopRequireDefault(_moment2);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

require('../style/index.css');

require('../../utils/style/index.css');

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var intlMessages = {
  'cs-CZ': _interopRequireDefault(require('./../intl/cs-CZ.json')).default,
  'da-DK': _interopRequireDefault(require('./../intl/da-DK.json')).default,
  'de-DE': _interopRequireDefault(require('./../intl/de-DE.json')).default,
  'en-US': _interopRequireDefault(require('./../intl/en-US.json')).default,
  'es-ES': _interopRequireDefault(require('./../intl/es-ES.json')).default,
  'fi-FI': _interopRequireDefault(require('./../intl/fi-FI.json')).default,
  'fr-FR': _interopRequireDefault(require('./../intl/fr-FR.json')).default,
  'it-IT': _interopRequireDefault(require('./../intl/it-IT.json')).default,
  'ja-JP': _interopRequireDefault(require('./../intl/ja-JP.json')).default,
  'ko-KR': _interopRequireDefault(require('./../intl/ko-KR.json')).default,
  'nb-NO': _interopRequireDefault(require('./../intl/nb-NO.json')).default,
  'nl-NL': _interopRequireDefault(require('./../intl/nl-NL.json')).default,
  'pl-PL': _interopRequireDefault(require('./../intl/pl-PL.json')).default,
  'pt-BR': _interopRequireDefault(require('./../intl/pt-BR.json')).default,
  'ru-RU': _interopRequireDefault(require('./../intl/ru-RU.json')).default,
  'sv-SE': _interopRequireDefault(require('./../intl/sv-SE.json')).default,
  'tr-TR': _interopRequireDefault(require('./../intl/tr-TR.json')).default,
  'zh-CN': _interopRequireDefault(require('./../intl/zh-CN.json')).default,
  'zh-TW': _interopRequireDefault(require('./../intl/zh-TW.json')).default
};

if (process.env.SCALE_MEDIUM && process.env.SCALE_LARGE) {
  require('../../spectrum-css/calendar/index.css');

  require('../../spectrum-css/calendar/index-diff.css');
} else if (process.env.SCALE_LARGE) {
  require('../../spectrum-css/calendar/index-lg.css');
} else {
  require('../../spectrum-css/calendar/index.css');
}

if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_LIGHT) require('../../spectrum-css/calendar/multiStops/light.css');
if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_DARK) require('../../spectrum-css/calendar/multiStops/dark.css');
if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_LIGHTEST) require('../../spectrum-css/calendar/multiStops/lightest.css');
if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_DARKEST) require('../../spectrum-css/calendar/multiStops/darkest.css');


var formatMessage = (0, _intl.messageFormatter)(intlMessages);

var Calendar = (0, _autobindDecorator2.default)(_class = function (_Component) {
  _inherits(Calendar, _Component);

  function Calendar(props) {
    _classCallCheck(this, Calendar);

    var _this = _possibleConstructorReturn(this, (Calendar.__proto__ || Object.getPrototypeOf(Calendar)).call(this, props));

    _this.calendarId = (0, _createId2.default)();
    return _this;
  }

  _createClass(Calendar, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      var _props = this.props,
          value = _props.value,
          defaultValue = _props.defaultValue,
          min = _props.min,
          max = _props.max,
          valueFormat = _props.valueFormat;


      var newValue = (0, _moment.toMoment)(value || defaultValue || '', valueFormat);
      var newMin = (0, _moment.toMoment)(min, valueFormat);
      var newMax = (0, _moment.toMoment)(max, valueFormat);

      this.setState({
        isFocused: false,
        min: newMin && newMin.startOf('day'),
        max: newMax && newMax.startOf('day')
      });

      this.setSelected(newValue);
      this.setCurrentMonth(newValue);
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      if (this.props.autoFocus) {
        this.focus();
      }
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _props2 = this.props,
          min = _props2.min,
          max = _props2.max,
          valueFormat = _props2.valueFormat;


      if (min !== nextProps.min || valueFormat !== nextProps.valueFormat) {
        var newMin = (0, _moment.toMoment)(nextProps.min, nextProps.valueFormat);
        this.setState({
          min: newMin && newMin.startOf('day')
        });
      }

      if (max !== nextProps.max || valueFormat !== nextProps.valueFormat) {
        var newMax = (0, _moment.toMoment)(nextProps.max, nextProps.valueFormat);
        this.setState({
          max: newMax && newMax.startOf('day')
        });
      }

      if ('value' in nextProps && nextProps.value !== this.state.value) {
        var newValue = (0, _moment.toMoment)(nextProps.value, nextProps.valueFormat);

        // Only change the current month window if the next value is a different day than
        // what we currently have.  We don't want to trigger the month switch if we are just
        // changing the hours or minutes of the day.
        if (!newValue.isSame(this.state.value, 'day')) {
          this.setSelected(newValue);
          this.setCurrentMonth(newValue);
        }
      }
    }
  }, {
    key: 'getRange',
    value: function getRange(value) {
      if (value instanceof _momentRange.DateRange) {
        return value.clone();
      } else if (value) {
        return new _momentRange.DateRange(value.clone().startOf('day'), value.clone().endOf('day'));
      }

      return null;
    }
  }, {
    key: 'setSelected',
    value: function setSelected(value) {
      var range = this.getRange(value);

      this.setState({
        value: this.props.selectionType === 'range' ? range : value,
        highlightedRange: range,
        focusedDate: range ? range.start : (0, _moment3.default)()
      });
    }
  }, {
    key: 'setValue',
    value: function setValue(value) {
      var onChange = this.props.onChange;


      if (this.props.selectionType === 'range') {
        value = this.getRange(value);
      } else {
        value = value.clone();
      }

      if (!('value' in this.props)) {
        this.setSelected(value);
        this.setCurrentMonth(value);
      }

      onChange(value);
    }
  }, {
    key: 'setCurrentMonth',
    value: function setCurrentMonth(date) {
      var today = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (0, _moment3.default)();

      if (date instanceof _momentRange.DateRange) {
        date = date.end;
      }

      var visibleMonth = date && date.isValid() ? date : today;

      this.setState({
        currentMonth: visibleMonth.clone().startOf('month')
      });
    }

    /**
     * Generates a unique id for a DOM element descendant
     * * @param   {Sting} string String value
     * @returns {String} A unique id
     * @private
     */

  }, {
    key: 'generateId',
    value: function generateId(string) {
      var _props$id = this.props.id,
          id = _props$id === undefined ? this.calendarId : _props$id;


      return id + '-' + string;
    }

    /**
     * Generates a unique id for a Calendar table cell
     * @param   {Object} date Moment object
     * @returns {String} A unique id for the Calendar table cell
     * @private
     */

  }, {
    key: 'generateDateId',
    value: function generateDateId(date) {
      return date ? this.generateId(date.format('YYYY/MM/DD')) : null;
    }

    /**
     * Handles click on previous arrow button to navigate to the previous month.
     * @private
     */

  }, {
    key: 'handleClickPrevious',
    value: function handleClickPrevious() {
      var _this2 = this;

      var _state = this.state,
          currentMonth = _state.currentMonth,
          focusedDate = _state.focusedDate;

      // set focus to the appropriate date within the previous month

      if (focusedDate) {
        this.focusTimeUnit(focusedDate.clone().add(-1, 'month'));
      }

      this.setState({
        currentMonth: currentMonth.clone().add(-1, 'month').startOf('month')
      }, function () {
        // announce new currentMonth using a live region.
        _this2.announceCurrentMonth();

        // restore focus from the calendar body to the previous month button
        requestAnimationFrame(function () {
          return _this2.prevMonthButton.focus();
        });
      });
    }

    /**
     * Handles click on next arrow button to navigate to the next month.
     * @private
     */

  }, {
    key: 'handleClickNext',
    value: function handleClickNext() {
      var _this3 = this;

      var _state2 = this.state,
          currentMonth = _state2.currentMonth,
          focusedDate = _state2.focusedDate;

      // set focus to the appropriate date within the previous month

      if (focusedDate) {
        this.focusTimeUnit(focusedDate.clone().add(1, 'month'));
      }

      this.setState({
        currentMonth: currentMonth.clone().add(1, 'month').startOf('month')
      }, function () {
        _this3.announceCurrentMonth();

        // restore focus from the calendar body to the next month button
        requestAnimationFrame(function () {
          return _this3.nextMonthButton.focus();
        });
      });
    }
  }, {
    key: 'handleDayClick',
    value: function handleDayClick(e, date) {
      this.selectFocused(date);
    }
  }, {
    key: 'handleDayMouseDown',
    value: function handleDayMouseDown(e, date) {
      this.focusTimeUnit(date);
    }
  }, {
    key: 'getSelectingRange',
    value: function getSelectingRange(date) {
      var min = _moment3.default.min(this.state.anchorDate || this.state.focusedDate, date).clone();
      var max = _moment3.default.max(this.state.anchorDate || this.state.focusedDate, date).clone();
      return new _momentRange.DateRange(min, max);
    }
  }, {
    key: 'onHighlight',
    value: function onHighlight(e, date) {
      if (this.state.selectingRange) {
        this.setState({
          selectingRange: this.getSelectingRange(date)
        });
      }
    }
  }, {
    key: 'onFocus',
    value: function onFocus(e) {
      this.setState({ isFocused: true });
      if (this.props.onFocus) {
        this.props.onFocus(e);
      }
    }
  }, {
    key: 'onBlur',
    value: function onBlur(e) {
      this.setState({ isFocused: false });
      if (this.props.onBlur) {
        this.props.onBlur(e);
      }
    }
  }, {
    key: 'handleKeyDown',
    value: function handleKeyDown(e) {
      var focusedDate = this.state.focusedDate;

      var nextMoment = focusedDate.clone();

      switch (e.keyCode) {
        case 13: // enter
        case 32:
          // space
          e.preventDefault();
          this.selectFocused(nextMoment);
          break;
        case 33:
          // page up
          e.preventDefault();
          this.focusTimeUnit(nextMoment.subtract(1, e.metaKey ? 'year' : 'month'));
          break;
        case 34:
          // page down
          e.preventDefault();
          this.focusTimeUnit(nextMoment.add(1, e.metaKey ? 'year' : 'month'));
          break;
        case 35:
          // end
          e.preventDefault();
          this.focusTimeUnit(nextMoment.endOf('month').startOf('day'));
          break;
        case 36:
          // home
          e.preventDefault();
          this.focusTimeUnit(nextMoment.startOf('month').startOf('day'));
          break;
        case 37:
          // left arrow
          e.preventDefault();
          this.focusTimeUnit(nextMoment.subtract(1, 'day'));
          break;
        case 38:
          // up arrow
          e.preventDefault();
          this.focusTimeUnit(nextMoment.subtract(1, 'week'));
          break;
        case 39:
          // right arrow
          e.preventDefault();
          this.focusTimeUnit(nextMoment.add(1, 'day'));
          break;
        case 40:
          // down arrow
          e.preventDefault();
          this.focusTimeUnit(nextMoment.add(1, 'week'));
          break;
        case 27:
          // escape
          if (this.state.selectingRange) {
            this.setState({ selectingRange: null, anchorDate: null });
          }
          break;
      }
    }
  }, {
    key: 'focusTimeUnit',
    value: function focusTimeUnit(date) {
      var _this4 = this;

      var _state3 = this.state,
          currentMonth = _state3.currentMonth,
          min = _state3.min,
          max = _state3.max;

      // Don't move focus if the date is not in range.

      if (!(0, _moment.isDateInRange)(date, min, max)) {
        return;
      }

      var sameMonthAsVisible = currentMonth.isSame(date, 'month');
      var newCurrentMonth = sameMonthAsVisible ? currentMonth : date.clone().startOf('month');

      this.setState({
        focusedDate: date,
        currentMonth: newCurrentMonth
      }, function () {
        // wait for render before highlighting the date range and focusing the Calendar body
        _this4.onHighlight(null, date);
        _this4.focusCalendarBody();

        if (!sameMonthAsVisible) {
          _this4.announceCurrentMonth('polite');
        }
      });
    }

    /**
     * Announces current month using a live region
     * @private
     */

  }, {
    key: 'announceCurrentMonth',
    value: function announceCurrentMonth() {
      var assertiveness = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'assertive';

      var method = assertiveness === 'polite' ? 'announcePolite' : 'announceAssertive';
      var currentMonth = this.state.currentMonth;

      currentMonth.locale((0, _intl.getLocale)());
      _LiveRegionAnnouncer2.default[method](currentMonth.format(this.props.headerFormat));
    }

    /**
     * Announces selected date or selected range of dates
     * @private
     */

  }, {
    key: 'announceSelection',
    value: function announceSelection() {
      var assertiveness = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'polite';

      var selectedRangeDescription = this.getSelectedRangeDescription();
      if (selectedRangeDescription === '') {
        _LiveRegionAnnouncer2.default.clearMessage();
      } else {
        var method = assertiveness === 'polite' ? 'announcePolite' : 'announceAssertive';
        _LiveRegionAnnouncer2.default[method](selectedRangeDescription);
      }
    }
  }, {
    key: 'getSelectedRangeDescription',
    value: function getSelectedRangeDescription() {
      var _state4 = this.state,
          highlightedRange = _state4.highlightedRange,
          _state4$anchorDate = _state4.anchorDate,
          anchorDate = _state4$anchorDate === undefined ? false : _state4$anchorDate;

      var isRangeSelection = this.props.selectionType === 'range';
      var selectedRangeDescription = '';

      // Provide localized description of selected date or range of dates.
      if (highlightedRange) {
        highlightedRange.start.locale((0, _intl.getLocale)());
        if (isRangeSelection) {
          highlightedRange.end.locale((0, _intl.getLocale)());
        }
        var start = highlightedRange.start.toDate();
        var end = isRangeSelection ? highlightedRange.end.toDate() : start;
        if (isRangeSelection && !anchorDate && start.valueOf() !== end.valueOf()) {
          selectedRangeDescription = formatMessage('selectedRangeDescription', {
            start: start,
            end: end
          });
        } else if (!anchorDate) {
          selectedRangeDescription = formatMessage('selectedDateDescription', {
            date: start
          });
        }
      }

      return selectedRangeDescription;
    }
  }, {
    key: 'selectFocused',
    value: function selectFocused(date) {
      var _this5 = this;

      var value = this.state.value;


      date = date.clone();
      if (value && _moment3.default.isMoment(value) && value.isValid()) {
        date.hour(value.hour());
        date.minute(value.minute());
        date.second(value.second());
        date.millisecond(value.millisecond());
      }

      var selectingRange = null;
      var anchorDate = null;
      var newValue = null;
      var assertiveness = 'polite';
      if (this.props.selectionType === 'range') {
        // If this is the second date selected, set the value.
        // Otherwise, setup the selecting range.
        if (this.state.selectingRange) {
          newValue = this.getSelectingRange(date);
        } else {
          selectingRange = this.getRange(date);
          anchorDate = date;
        }
      } else {
        newValue = date;
      }

      if (newValue) {
        assertiveness = 'assertive';
        this.setValue(newValue);
      }

      this.setState({
        anchorDate: anchorDate,
        focusedDate: date,
        selectingRange: selectingRange
      }, function () {
        // wait for render before setting focus to Calendar body
        _this5.focusCalendarBody();

        // announce newly selected date or range of dates
        _this5.announceSelection(assertiveness);
      });
    }

    /**
     * Focus calendar
     * @private
     */

  }, {
    key: 'focus',
    value: function focus() {
      this.focusCalendarBody();
    }

    /**
     * Ensure Calendar body receives focus after clicking on a cell
     * @private
     */

  }, {
    key: 'focusCalendarBody',
    value: function focusCalendarBody() {
      var calendarBody = this.calendarBody;
      if (calendarBody) {
        // this forces assistive technology to announce the current active descendant of the calendar body
        if (calendarBody === document.activeElement) {
          calendarBody.blur();
        }
        requestAnimationFrame(function () {
          return calendarBody.focus();
        });
      }
    }
  }, {
    key: 'renderTable',
    value: function renderTable(date) {
      var descriptionId = this.generateId('description');
      var selectedRangeDescription = this.getSelectedRangeDescription();

      return _react2.default.createElement(
        'table',
        {
          key: date.format('MM/Y'),
          className: 'spectrum-Calendar-table' },
        _react2.default.createElement(
          'caption',
          { className: 'u-react-spectrum-screenReaderOnly', id: descriptionId },
          selectedRangeDescription
        ),
        this.renderTableHeader(),
        this.renderTableBody(date)
      );
    }
  }, {
    key: 'renderTableHeader',
    value: function renderTableHeader() {
      var startDay = this.props.startDay;


      return _react2.default.createElement(
        'thead',
        null,
        _react2.default.createElement(
          'tr',
          { role: 'row' },
          [].concat(_toConsumableArray(new Array(7).keys())).map(function (index) {
            var dayMoment = (0, _moment3.default)().day((index + startDay) % 7);
            return _react2.default.createElement(
              'th',
              {
                key: index,
                role: 'columnheader',
                scope: 'col',
                className: 'spectrum-Calendar-tableCell' },
              _react2.default.createElement(
                'abbr',
                {
                  className: 'spectrum-Calendar-dayOfWeek',
                  title: dayMoment.format('dddd') },
                dayMoment.format('dd')
              )
            );
          })
        )
      );
    }
  }, {
    key: 'renderTableBody',
    value: function renderTableBody(date) {
      var _this6 = this;

      var _props3 = this.props,
          startDay = _props3.startDay,
          disabled = _props3.disabled;
      var _state5 = this.state,
          highlightedRange = _state5.highlightedRange,
          selectingRange = _state5.selectingRange,
          min = _state5.min,
          max = _state5.max,
          isFocused = _state5.isFocused,
          focusedDate = _state5.focusedDate,
          currentMonth = _state5.currentMonth,
          anchorDate = _state5.anchorDate;

      var range = selectingRange || highlightedRange;

      var month = date.month();
      var year = date.year();
      var dateFocusedLocal = focusedDate ? focusedDate.clone().startOf('day') : null;
      var monthStartsAt = (currentMonth.day() - startDay) % 7;

      if (monthStartsAt < 0) {
        monthStartsAt += 7;
      }

      return _react2.default.createElement(
        'tbody',
        null,
        [].concat(_toConsumableArray(new Array(6).keys())).map(function (weekIndex) {
          return _react2.default.createElement(
            'tr',
            { key: weekIndex, role: 'row' },
            [].concat(_toConsumableArray(new Array(7).keys())).map(function (dayIndex) {
              var day = weekIndex * 7 + dayIndex - monthStartsAt + 1;
              var cursor = (0, _moment3.default)(new Date(year, month, day));
              var isCurrentMonth = cursor.month() === parseFloat(month);
              var cursorLocal = cursor.clone().startOf('day');
              var isRangeStart = range && (dayIndex === 0 || day === 1);
              var isRangeEnd = range && (dayIndex === 6 || day === cursor.daysInMonth());
              var isSelectionStart = range && cursorLocal.isSame(range.start, 'day');
              var isSelectionEnd = range && cursorLocal.isSame(range.end, 'day');
              var isSelected = isSelectionStart || isSelectionEnd || range && range.contains(cursorLocal);
              var isRangeSelection = _this6.props.selectionType === 'range';
              var isRangeSelected = isRangeSelection && range && !anchorDate;
              var isRangeSelectionInProgress = isRangeSelection && anchorDate;

              return _react2.default.createElement(CalendarCell, {
                key: dayIndex,
                id: _this6.generateDateId(cursor),
                date: cursor,
                disabled: disabled || !isCurrentMonth || !(0, _moment.isDateInRange)(cursor, min, max),
                isToday: cursor.isSame((0, _moment3.default)(), 'day'),
                isCurrentMonth: isCurrentMonth,
                selected: isSelected,
                isRangeSelected: isRangeSelected,
                isRangeSelection: isRangeSelection,
                isRangeSelectionInProgress: isRangeSelectionInProgress,
                isSelectionStart: isSelectionStart,
                isSelectionEnd: isSelectionEnd,
                isRangeStart: isRangeStart,
                isRangeEnd: isRangeEnd,
                focused: isFocused && dateFocusedLocal && cursorLocal.isSame(dateFocusedLocal, 'day'),
                onClick: _this6.handleDayClick,
                onMouseDown: _this6.handleDayMouseDown,
                onHighlight: _this6.onHighlight });
            })
          );
        })
      );
    }
  }, {
    key: 'render',
    value: function render() {
      var _this7 = this;

      var _props4 = this.props,
          name = _props4.name,
          headerFormat = _props4.headerFormat,
          valueFormat = _props4.valueFormat,
          className = _props4.className,
          disabled = _props4.disabled,
          invalid = _props4.invalid,
          readOnly = _props4.readOnly,
          selectionType = _props4.selectionType,
          _props4$id = _props4.id,
          id = _props4$id === undefined ? this.calendarId : _props4$id,
          otherProps = _objectWithoutProperties(_props4, ['name', 'headerFormat', 'valueFormat', 'className', 'disabled', 'invalid', 'readOnly', 'selectionType', 'id']);

      var _state6 = this.state,
          focusedDate = _state6.focusedDate,
          highlightedRange = _state6.highlightedRange,
          currentMonth = _state6.currentMonth;

      var headingId = this.generateId('heading');
      var descriptionId = this.generateId('description');
      var activeDescendantId = this.generateDateId(focusedDate);
      var isRangeSelection = selectionType === 'range';
      var ariaLabelledby = headingId;

      delete otherProps.autoFocus;
      delete otherProps.required;

      // If Calendar is labelled using aria-label, concatenate id for Calendar itself to include the Calendar group as a label along with Calendar Month/Year heading
      if (otherProps['aria-label']) {
        ariaLabelledby = id + ' ' + ariaLabelledby;
      }

      // If Calendar is labelled by an external element, concatenate id to include the external label and the Calendar Month/Year heading
      if (otherProps['aria-labelledby']) {
        ariaLabelledby = otherProps['aria-labelledby'] + ' ' + ariaLabelledby;
        delete otherProps['aria-labelledby'];
      }

      // Make sure moment localizes date formatting per Intl.locale
      _moment3.default.locale((0, _intl.getLocale)());
      currentMonth.locale((0, _intl.getLocale)());
      var currentMonthFormatted = currentMonth.format(headerFormat);

      return _react2.default.createElement(
        'div',
        _extends({
          className: (0, _classnames2.default)('spectrum-Calendar', className),
          role: 'group',
          'aria-labelledby': ariaLabelledby,
          id: id
        }, (0, _filterDOMProps2.default)(otherProps)),
        _react2.default.createElement('input', { type: 'hidden', name: name, value: (0, _moment.formatMoment)(highlightedRange && highlightedRange.start, valueFormat) }),
        _react2.default.createElement(
          'div',
          { className: 'spectrum-Calendar-header' },
          _react2.default.createElement(
            'h2',
            {
              className: 'spectrum-Calendar-title',
              id: headingId },
            currentMonthFormatted
          ),
          _react2.default.createElement(_Button2.default, {
            ref: function ref(b) {
              return _this7.prevMonthButton = b;
            },
            className: 'spectrum-Calendar-prevMonth',
            variant: 'action',
            quiet: true,
            icon: _react2.default.createElement(_ChevronLeftLarge2.default, { className: 'spectrum-Calendar-chevron' }),
            'aria-label': formatMessage('previous'),
            title: formatMessage('previous'),
            disabled: disabled,
            onClick: this.handleClickPrevious }),
          _react2.default.createElement(_Button2.default, {
            ref: function ref(b) {
              return _this7.nextMonthButton = b;
            },
            className: 'spectrum-Calendar-nextMonth',
            variant: 'action',
            quiet: true,
            icon: _react2.default.createElement(_ChevronRightLarge2.default, { className: 'spectrum-Calendar-chevron' }),
            'aria-label': formatMessage('next'),
            title: formatMessage('next'),
            disabled: disabled,
            onClick: this.handleClickNext })
        ),
        _react2.default.createElement(
          'div',
          {
            ref: function ref(el) {
              return _this7.calendarBody = el;
            },
            className: 'spectrum-Calendar-body',
            role: 'grid',
            tabIndex: disabled ? null : '0',
            'aria-invalid': invalid,
            'aria-readonly': readOnly,
            'aria-disabled': disabled,
            'aria-activedescendant': activeDescendantId,
            'aria-labelledby': ariaLabelledby,
            'aria-describedby': highlightedRange ? descriptionId : null,
            'aria-multiselectable': isRangeSelection || null,
            onKeyDown: this.handleKeyDown,
            onFocus: this.onFocus,
            onBlur: this.onBlur },
          this.renderTable(currentMonth)
        )
      );
    }
  }]);

  return Calendar;
}(_react.Component)) || _class;

Calendar.displayName = 'Calendar';
Calendar.propTypes = {
  /**
   * If focus should immediately be given to the calendar upon render.
   */
  autoFocus: _propTypes2.default.bool,

  /**
   * A unique identifying string for forms.
   */
  id: _propTypes2.default.string,

  /**
   * Formats the date string at the top of the calendar,
   */
  headerFormat: _propTypes2.default.string,

  /**
   * Max date selectable, everything past it will be disabled. Can accept anything Moment understands.
   */
  max: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object, _propTypes2.default.number]),

  /**
   * Min date selectable, everything past it will be disabled. Can accept anything Moment understands.
   */
  min: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object, _propTypes2.default.number]),

  /**
   * Starting value. Can accept anything Moment understands. Causes component to be Controlled.
   */
  value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object, _propTypes2.default.number, _propTypes2.default.array]),

  /**
   * Format of the value that should be returned. Anything Moment understands.
   */
  valueFormat: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),

  /**
   * Tells the calendar if the user can select a range or just a single day.
   */
  selectionType: _propTypes2.default.oneOf(['single', 'range']),

  /**
   * Start day refers to what day of the week should be left most, 0 = Sunday, 1 = Monday...
   */
  startDay: _propTypes2.default.oneOf([0, 1, 2, 3, 4, 5, 6]),

  /**
   * Disables the calendar, it cannot be interacted with and renders greyed out
   */
  disabled: _propTypes2.default.bool,

  /**
   * Fill in.
   */
  readOnly: _propTypes2.default.bool,

  /**
   * For forms.
   */
  required: _propTypes2.default.bool,

  /**
   * Fill in.
   */
  invalid: _propTypes2.default.bool,

  /**
   * Called when a date is selected or a range is selected
   * @callback Calendar~onChange
   * @param {Object} event - Moment object
   */
  onChange: _propTypes2.default.func
};
Calendar.defaultProps = {
  autoFocus: false,
  headerFormat: 'MMMM YYYY',
  max: null,
  min: null,
  valueFormat: 'YYYY-MM-DD',
  selectionType: 'single',
  startDay: 0,
  disabled: false,
  invalid: false,
  readOnly: false,
  required: false,
  onChange: function onChange() {}
};
exports.default = Calendar;


var CalendarCell = function CalendarCell(_ref) {
  var id = _ref.id,
      date = _ref.date,
      _ref$isToday = _ref.isToday,
      isToday = _ref$isToday === undefined ? false : _ref$isToday,
      _ref$isCurrentMonth = _ref.isCurrentMonth,
      isCurrentMonth = _ref$isCurrentMonth === undefined ? false : _ref$isCurrentMonth,
      _ref$selected = _ref.selected,
      selected = _ref$selected === undefined ? false : _ref$selected,
      _ref$disabled = _ref.disabled,
      disabled = _ref$disabled === undefined ? false : _ref$disabled,
      _ref$focused = _ref.focused,
      focused = _ref$focused === undefined ? false : _ref$focused,
      _ref$invalid = _ref.invalid,
      invalid = _ref$invalid === undefined ? false : _ref$invalid,
      _ref$isRangeSelected = _ref.isRangeSelected,
      isRangeSelected = _ref$isRangeSelected === undefined ? false : _ref$isRangeSelected,
      _ref$isRangeSelection = _ref.isRangeSelection,
      isRangeSelection = _ref$isRangeSelection === undefined ? false : _ref$isRangeSelection,
      _ref$isRangeSelection2 = _ref.isRangeSelectionInProgress,
      isRangeSelectionInProgress = _ref$isRangeSelection2 === undefined ? false : _ref$isRangeSelection2,
      _ref$isRangeStart = _ref.isRangeStart,
      isRangeStart = _ref$isRangeStart === undefined ? false : _ref$isRangeStart,
      _ref$isRangeEnd = _ref.isRangeEnd,
      isRangeEnd = _ref$isRangeEnd === undefined ? false : _ref$isRangeEnd,
      _ref$isSelectionStart = _ref.isSelectionStart,
      isSelectionStart = _ref$isSelectionStart === undefined ? false : _ref$isSelectionStart,
      _ref$isSelectionEnd = _ref.isSelectionEnd,
      isSelectionEnd = _ref$isSelectionEnd === undefined ? false : _ref$isSelectionEnd,
      _ref$onClick = _ref.onClick,
      onClick = _ref$onClick === undefined ? function () {} : _ref$onClick,
      _ref$onMouseDown = _ref.onMouseDown,
      onMouseDown = _ref$onMouseDown === undefined ? function () {} : _ref$onMouseDown,
      _ref$onHighlight = _ref.onHighlight,
      onHighlight = _ref$onHighlight === undefined ? function () {} : _ref$onHighlight;

  // title should be localize Day of week, Month, Day and Year without Time.
  var title = date.format('LLLL').replace(date.format('LT'), '').trim();
  var rangeSelectionPrompt = '';

  // Localized string for cell title/aria-label
  if (isToday) {
    // If date is today, set appropriate string depending on selected state:
    title = formatMessage(selected ? 'todayDateSelected' : 'todayDate', {
      date: date.toDate()
    });
  } else if (selected) {
    // If date is selected but not today:
    title = formatMessage('dateSelected', {
      date: date.toDate()
    });
  }

  // When cell is focused and selection mode is range,
  if (isRangeSelection && focused) {
    // If selection has started add "click to finish selecting range"
    if (isRangeSelectionInProgress) {
      rangeSelectionPrompt = formatMessage('finishRangeSelectionPrompt');
      // Otherwise, if no range is selected, add "click to start selecting range" prompt
    } else if (!isRangeSelected) {
      rangeSelectionPrompt = formatMessage('startRangeSelectionPrompt');
    }
    // If rangeSelectionPrompt has been set, add parentheses
    if (rangeSelectionPrompt.length) {
      rangeSelectionPrompt = ' (' + rangeSelectionPrompt + ')';
    }
  }

  return _react2.default.createElement(
    'td',
    {
      id: id,
      role: 'gridcell',
      className: 'spectrum-Calendar-tableCell',
      'aria-disabled': disabled,
      'aria-selected': selected,
      'aria-invalid': invalid,
      'aria-label': title + rangeSelectionPrompt,
      title: disabled ? null : title,
      onClick: disabled ? null : function (e) {
        return onClick(e, date.clone());
      },
      onMouseDown: disabled ? null : function (e) {
        return onMouseDown(e, date.clone());
      },
      onMouseEnter: disabled ? null : function (e) {
        return onHighlight(e, date.clone());
      },
      tabIndex: disabled ? null : -1 },
    _react2.default.createElement(
      'span',
      {
        role: 'presentation',
        className: (0, _classnames2.default)('spectrum-Calendar-date', {
          'is-today': isToday,
          'is-selected': selected,
          'is-focused': focused,
          'is-disabled': disabled,
          'is-outsideMonth': !isCurrentMonth,
          'is-range-start': isRangeSelection && isRangeStart,
          'is-range-end': isRangeSelection && isRangeEnd,
          'is-range-selection': isRangeSelection && selected,
          'is-selection-start': isRangeSelection && isSelectionStart,
          'is-selection-end': isRangeSelection && isSelectionEnd
        }) },
      date.date()
    )
  );
};

CalendarCell.displayName = 'CalendarCell';