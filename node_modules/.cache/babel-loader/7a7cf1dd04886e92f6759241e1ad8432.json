{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar _CollectionView2 = require('./CollectionView.js');\n\nvar _CollectionView3 = _interopRequireDefault(_CollectionView2);\n\nvar _DragTarget = require('./DragTarget');\n\nvar _DragTarget2 = _interopRequireDefault(_DragTarget);\n\nvar _DropOperation = require('./DropOperation');\n\nvar _DropOperation2 = _interopRequireDefault(_DropOperation);\n\nvar _IndexPath = require('./IndexPath');\n\nvar _IndexPath2 = _interopRequireDefault(_IndexPath);\n\nvar _Point = require('./Point');\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Range = require('./Range');\n\nvar _Range2 = _interopRequireDefault(_Range);\n\nvar _raf = require('raf');\n\nvar _raf2 = _interopRequireDefault(_raf);\n\nvar _Selection = require('./Selection');\n\nvar _Selection2 = _interopRequireDefault(_Selection);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar SCROLLTOITEM_DURATION = 200;\n/**\n * The EditableCollectionView class extends {@link CollectionView} with support for multiple selection,\n * keyboard interaction, drag and drop, and content reordering. It interacts with your {@link DataSource}\n * to allow users to drop new items and sections into the collection view to be inserted, drag and drop\n * views in the collection view to allow reordering of items or sections, and supports deletions of the\n * selected items via keyboard interaction. It also extends the collection view's delegate with additional\n * methods in {@link EditableCollectionViewDelegate} to allow overriding some of this behavior. Additionally,\n * the {@link Layout} is involved very closely in determining the behavior of views during drag and drop,\n * and keyboard selection behavior.\n */\n\nvar EditableCollectionView = function (_CollectionView) {\n  _inherits(EditableCollectionView, _CollectionView);\n\n  function EditableCollectionView() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, EditableCollectionView);\n    /**\n     * Whether the user can select items. Default is `true`.\n     * @type {boolean}\n     */\n\n\n    var _this = _possibleConstructorReturn(this, (EditableCollectionView.__proto__ || Object.getPrototypeOf(EditableCollectionView)).call(this, options));\n\n    _this.canSelectItems = options.canSelectItems !== false;\n    /**\n     * Whether the user can select multiple items at once. Default is `true`.\n     * @type {boolean}\n     */\n\n    _this.allowsMultipleSelection = options.allowsMultipleSelection !== false;\n    /**\n     * Whether the user can select no items. Default is `true`.\n     * @type {boolean}\n     */\n\n    _this.allowsEmptySelection = options.allowsEmptySelection !== false;\n    /**\n     * The default selection mode: either 'replace' or 'toggle'. Default is 'replace'.\n     * @type {string}\n     */\n\n    _this.selectionMode = options.selectionMode || 'replace';\n    /**\n     * The keyboard interaction mode: either 'selection' or 'focus'. Controls arrow key behavior.\n     * Default is 'selection' if canSelectItems is enabled, otherwise 'focus'.\n     * @type {string}\n     */\n\n    _this.keyboardMode = options.keyboardMode || (_this.canSelectItems ? 'selection' : 'focus');\n    /**\n     * Whether to emit selection changes on mouse up. Default is `false`,\n     * meaning emit on mouse down.\n     * @type {boolean}\n     */\n\n    _this.selectOnMouseUp = options.selectOnMouseUp || false;\n    /**\n     * Whether the user can drag items. Default is `false`.\n     * @type {boolean}\n     */\n\n    _this.canDragItems = options.canDragItems || false;\n    /**\n     * Whether the user can reorder items via drag and drop. Default is `false`.\n     * @type {boolean}\n     */\n\n    _this.canReorderItems = options.canReorderItems || false;\n    /**\n     * Whether the user can reorder sections via drag and drop. Default is `false`.\n     * @type {boolean}\n     */\n\n    _this.canReorderSections = options.canReorderSections || false;\n    /**\n     * Whether the collection view accepts drops. Default is `false`.\n     * If `true`, the collection view accepts all types of drops. Alternatively,\n     * it can be set to an array of accepted drop types.\n     * @type {boolean|string[]}\n     */\n\n    _this.acceptsDrops = options.acceptsDrops || false;\n    /**\n     * Whether the user can delete items using the keyboard. Default is `false`.\n     * @type {boolean}\n     */\n\n    _this.canDeleteItems = options.canDeleteItems || false;\n    /**\n     * The collection view delegate. The delegate is used by the collection view to create and configure views,\n     * and can be used to customize drag and drop behavior.\n     * @type {EditableCollectionViewDelegate}\n     */\n\n    _this.delegate = _this.delegate;\n    _this._selection = new _Selection2.default(_this._content, {\n      allowsMultipleSelection: _this.allowsMultipleSelection,\n      allowsEmptySelection: _this.allowsEmptySelection\n    });\n    _this._mouseOffset = null;\n    _this._dragTarget = null;\n    _this._dropTarget = null;\n    _this._selectOnMouseUp = null; // Make keyboard focusable\n\n    _this.setAttribute('tabIndex', -1); // add aria-multiselectable if attribute is present\n\n\n    if (options['aria-multiselectable']) {\n      _this.setAttribute('aria-multiselectable', _this.allowsMultipleSelection);\n    } // Bind events\n\n\n    _this.mouseDown = _this.mouseDown.bind(_this);\n    _this.mouseUp = _this.mouseUp.bind(_this);\n    _this.keyDown = _this.keyDown.bind(_this);\n    _this.onFocus = _this.onFocus.bind(_this);\n    _this.onBlur = _this.onBlur.bind(_this);\n\n    _this._setupEvents();\n\n    return _this;\n  }\n\n  _createClass(EditableCollectionView, [{\n    key: '_setupEvents',\n    value: function _setupEvents() {\n      this.onEvent('mouseDown', this.mouseDown);\n      this.onEvent('mouseUp', this.mouseUp);\n      this.onEvent('keyDown', this.keyDown);\n      this.onEvent('focus', this.onFocus);\n      this.onEvent('blur', this.onBlur);\n      this.backend.registerDragEvents(this);\n    }\n  }, {\n    key: '_teardownEvents',\n    value: function _teardownEvents() {\n      this.offEvent('mouseDown', this.mouseDown);\n      this.offEvent('mouseUp', this.mouseUp);\n      this.offEvent('keyDown', this.keyDown);\n      this.offEvent('focus', this.onFocus);\n      this.offEvent('blur', this.onBlur);\n      this.backend.unregisterDragEvents(this);\n    }\n  }, {\n    key: '_setDataSource',\n    value: function _setDataSource(dataSource) {\n      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_setDataSource', this).call(this, dataSource);\n\n      this._selection = new _Selection2.default(this._content, {\n        allowsMultipleSelection: this.allowsMultipleSelection,\n        allowsEmptySelection: this.allowsEmptySelection\n      });\n    }\n  }, {\n    key: 'getReusableView',\n    value: function getReusableView(layoutInfo) {\n      var view = _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), 'getReusableView', this).call(this, layoutInfo);\n\n      if (layoutInfo.type !== 'item') {\n        return view;\n      }\n\n      this._updateViewState(view);\n\n      return view;\n    } // MARK: selection support\n\n  }, {\n    key: 'mouseDown',\n    value: function mouseDown(e) {\n      var point = this.convertPoint(new _Point2.default(e.clientX, e.clientY));\n      var index = this.indexPathAtPoint(point);\n\n      if (!index) {\n        if (!e.metaKey && !e.shiftKey) {\n          this.clearSelection();\n        } // Emit an event when the user clicks on the background (e.g. not on an item view)\n\n\n        this.emit('backgroundClick', point);\n        return;\n      }\n\n      var layoutInfo = this.layout.getLayoutInfo('item', index.section, index.index);\n      this._mouseOffset = new _Point2.default(point.x - layoutInfo.rect.x, point.y - layoutInfo.rect.y);\n      this.focusItem(index); // If clicking on an already selected index without any modifier keys, replace the selection\n      // with that index on mouse up.\n\n      if (!e.metaKey && !e.shiftKey && this._selection.contains(index)) {\n        this._selectOnMouseUp = index;\n      } else {\n        this.selectItem(index, e.metaKey || this.selectionMode === 'toggle', e.shiftKey, !this.selectOnMouseUp);\n      }\n    }\n  }, {\n    key: 'mouseUp',\n    value: function mouseUp(e) {\n      if (this._selectOnMouseUp != null) {\n        this.selectItem(this._selectOnMouseUp, this.selectionMode === 'toggle');\n        this._selectOnMouseUp = null;\n      }\n\n      if (this.selectOnMouseUp) {\n        this.emit('selectionChanged', this.selectedIndexPaths);\n      }\n    }\n    /**\n     * Selects the item at the given IndexPath. By default it replaces the current\n     * selection, unless the `toggle` or `extend` options are true.\n     * @param {IndexPath} indexPath - The IndexPath to select\n     * @param {boolean} toggle - Whether to toggle the IndexPath.\n     *    Adds it to the selection if not already in it, or removes it if it is.\n     * @param {boolean} extend - Whether to extend the selection to the given IndexPath.\n     *    If true, the all items between the current selection anchor and the given IndexPath\n     *    are selected\n     * @param {boolean} emit - Whether to emit the `selectionChanged` event\n     */\n\n  }, {\n    key: 'selectItem',\n    value: function selectItem(indexPath) {\n      var toggle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var extend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var emit = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n\n      if (!indexPath || !this.canSelectItems) {\n        return;\n      }\n\n      if (this.delegate.shouldSelectItem && !this.delegate.shouldSelectItem(indexPath)) {\n        return;\n      }\n\n      if (extend) {\n        this._selection.extendTo(indexPath);\n      } else if (toggle) {\n        this._selection.toggleIndexPath(indexPath);\n      } else {\n        this._selection.replaceWith(indexPath);\n      }\n\n      this._updateSelection(emit);\n    }\n    /**\n     * Clears the selection\n     */\n\n  }, {\n    key: 'clearSelection',\n    value: function clearSelection() {\n      this._selection.clear();\n\n      this._updateSelection();\n    }\n    /**\n     * Selects all items in the collection view\n     */\n\n  }, {\n    key: 'selectAll',\n    value: function selectAll() {\n      if (!this.canSelectItems) {\n        return;\n      }\n\n      this._selection.selectAll();\n\n      this._updateSelection();\n    }\n  }, {\n    key: '_updateSelection',\n    value: function _updateSelection(emit) {\n      if (!this.canSelectItems) {\n        return;\n      }\n\n      this._updateVisibleViewStates();\n\n      if (emit !== false) {\n        this.emit('selectionChanged', this.selectedIndexPaths);\n      }\n    }\n  }, {\n    key: '_updateVisibleViewStates',\n    value: function _updateVisibleViewStates() {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this._visibleViews.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var view = _step.value;\n\n          this._updateViewState(view);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }, {\n    key: '_updateViewState',\n    value: function _updateViewState(view) {\n      var layoutInfo = view.layoutInfo;\n\n      if (layoutInfo.type !== 'item') {\n        return;\n      }\n\n      var indexPath = new _IndexPath2.default(layoutInfo.section, layoutInfo.index);\n      view.setState('selected', this._selection.contains(indexPath));\n      view.setState('focused', this._focusedIndexPath && this._focusedIndexPath.equals(indexPath));\n    }\n    /**\n     * The currently selected IndexPaths\n     * @type {IndexPathSet}\n     */\n\n  }, {\n    key: 'focusItem',\n\n    /**\n     * Focus the item at the given IndexPath.\n     * @param {IndexPath} indexPath - The IndexPath to of item to focus\n     */\n    value: function focusItem(indexPath) {\n      var _this2 = this;\n\n      if (!indexPath || indexPath.equals(this._focusedIndexPath) && !this.getItemView(indexPath.section, indexPath.index)) {\n        return;\n      }\n\n      this._focusedIndexPath = indexPath;\n\n      if (this._scrollAnimation) {\n        if (this._focusItemRaf) {\n          _raf2.default.cancel(this._focusItemRaf);\n        }\n\n        this._focusItemRaf = (0, _raf2.default)(function () {\n          return _this2._focusItemNow(indexPath);\n        });\n      } else {\n        this._focusItemNow(indexPath);\n      }\n    }\n  }, {\n    key: '_focusItemNow',\n    value: function _focusItemNow(indexPath) {\n      var _this3 = this;\n\n      if (!indexPath) {\n        return;\n      }\n\n      var view = this.getItemView(indexPath.section, indexPath.index);\n      this._focusItemRaf = null;\n\n      var _focusItemView = function _focusItemView() {\n        view = _this3.getItemView(indexPath.section, indexPath.index);\n\n        if (!view) {\n          return;\n        }\n\n        _this3.setAttribute('tabIndex', -1);\n\n        (0, _raf2.default)(function () {\n          return view.focus();\n        });\n      }; // If scrolling, and view is not yet present in the viewport,\n\n\n      if (this._scrollAnimation && !view) {\n        // focus the EditableCollectionView until animation completes,\n        this.focus(); // then restore focus to the appropriate item.\n\n        this._scrollAnimation.then(_focusItemView);\n      } else {\n        // Otherwise, focus the appropriate item.\n        _focusItemView();\n      } // update focused state and tabIndex for visible views\n\n\n      this._updateVisibleViewStates();\n    } // MARK: drag and drop support\n\n  }, {\n    key: 'dragStart',\n    value: function dragStart(event) {\n      var point = this.convertPoint(new _Point2.default(event.clientX, event.clientY));\n      var target = this.layout.getDragTarget(point);\n\n      if (!target) {\n        return _DropOperation2.default.NONE;\n      }\n\n      if (target.type === 'section' && !this.canReorderSections) {\n        return _DropOperation2.default.NONE;\n      }\n\n      if (target.type === 'item' && !(this.canReorderItems || this.canDragItems)) {\n        return _DropOperation2.default.NONE;\n      }\n\n      var indexPaths = this.selectedIndexPaths;\n\n      if (this.delegate.shouldDrag && !this.delegate.shouldDrag(target, indexPaths)) {\n        return _DropOperation2.default.NONE;\n      }\n\n      var dragView = this._getDragView(target, indexPaths);\n\n      if (dragView) {\n        dragView.renderBackendView(this.backend);\n        this.backend.setDragImage(event, dragView);\n      } // Ask the delegate for drag data if possible, otherwise use a default format\n\n\n      if (this.delegate.prepareDragData) {\n        this.delegate.prepareDragData(target, event.dataTransfer, indexPaths);\n      } else {\n        var items = void 0;\n\n        if (target.type === 'section') {\n          items = this._content.getItemsInSection(target.indexPath.section);\n        } else {\n          items = [];\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = indexPaths[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var indexPath = _step2.value;\n              items.push(this.getItem(indexPath));\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n\n        event.dataTransfer.setData('CollectionViewData', JSON.stringify(items));\n      }\n\n      this._selectOnMouseUp = null;\n      this._dragTarget = target; // Default to allowing all drop operations for this drag, but allow the delegate to override.\n\n      var allowedOperations = _DropOperation2.default.ALL;\n\n      if (this.delegate.getAllowedDropOperations) {\n        allowedOperations = this.delegate.getAllowedDropOperations(target, indexPaths);\n      }\n\n      return allowedOperations;\n    }\n  }, {\n    key: '_getDragView',\n    value: function _getDragView(target, indexPaths) {\n      var dragView = this._getDragViewFromDelegate(target, indexPaths);\n\n      if (dragView) {\n        return dragView;\n      }\n\n      var view = this.getItemView(target.indexPath.section || 0, target.indexPath.index || 0);\n\n      if (!view) {\n        return null;\n      }\n\n      return view;\n    }\n  }, {\n    key: '_getDragViewFromDelegate',\n    value: function _getDragViewFromDelegate(target, indexPaths) {\n      if (this.delegate.getDragView) {\n        return this.delegate.getDragView(target, indexPaths);\n      }\n    }\n  }, {\n    key: '_shouldAcceptDrop',\n    value: function _shouldAcceptDrop(event) {\n      if (this.canReorderItems && this._dragTarget) {\n        return true;\n      }\n\n      if (this.acceptsDrops) {\n        // If this.acceptsDrops is an array of types, check if the drag\n        // has any of the accepted types.\n        if (Array.isArray(this.acceptsDrops)) {\n          var types = new Set(event.dataTransfer.types);\n\n          if (!this.acceptsDrops.some(function (type) {\n            return types.has(type);\n          })) {\n            return false;\n          }\n        } // Ask the delegate if it has a shouldAcceptDrop method.\n\n\n        if (this.delegate.shouldAcceptDrop && !this.delegate.shouldAcceptDrop(event)) {\n          return false;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: 'dragEntered',\n    value: function dragEntered(event, allowedOperations) {\n      if (this._shouldAcceptDrop(event)) {\n        this._enableTransitions();\n\n        return _DropOperation2.default.MOVE;\n      }\n\n      return _DropOperation2.default.NONE;\n    }\n  }, {\n    key: '_getDropTargetView',\n    value: function _getDropTargetView(dropTarget) {\n      if (dropTarget && dropTarget.dropPosition === _DragTarget2.default.DROP_ON) {\n        return this.getView(dropTarget.type, dropTarget.indexPath.section, dropTarget.indexPath.index);\n      }\n\n      return null;\n    }\n  }, {\n    key: '_setDropTarget',\n    value: function _setDropTarget(dropTarget) {\n      if (this._dropTarget && dropTarget && this._dropTarget.equals(dropTarget)) {\n        return false;\n      }\n\n      var dropTargetView = this._getDropTargetView(this._dropTarget);\n\n      if (dropTargetView) {\n        dropTargetView.removeState('drop-target');\n      }\n\n      dropTargetView = this._getDropTargetView(dropTarget);\n\n      if (dropTargetView) {\n        dropTargetView.addState('drop-target');\n      }\n\n      this._dropTarget = dropTarget;\n\n      if (typeof this.delegate.dropTargetUpdated === 'function') {\n        this.delegate.dropTargetUpdated(dropTarget);\n      }\n\n      return true;\n    }\n  }, {\n    key: 'dragMoved',\n    value: function dragMoved(event, allowedOperations) {\n      var point = this.convertPoint(new _Point2.default(event.clientX, event.clientY));\n      var target = this.layout.getDropTarget(point); // Call the delegate to override the target from the layout\n\n      if (target && this.delegate.getDropTarget) {\n        target = this.delegate.getDropTarget(target, point);\n      }\n\n      var dropOperation = _DropOperation2.default.NONE;\n\n      if (target) {\n        // Ask the delegate to get the drop operation,\n        // or default to the first allowed operation.\n        if (this.delegate.getDropOperation) {\n          dropOperation = this.delegate.getDropOperation(target, allowedOperations);\n        } else {\n          // Get the least significant bit that is set\n          dropOperation = allowedOperations & -allowedOperations;\n        }\n      }\n\n      if (this._setDropTarget(target)) {\n        this.relayoutNow();\n      }\n\n      var scrollBottom = this.size.height - 60;\n      var scrollTop = 60;\n      var scrollLeft = 60;\n      var scrollRight = this.size.width - 60;\n      var x = point.x - this._contentOffset.x;\n      var y = point.y - this._contentOffset.y;\n\n      if (x < scrollLeft || x > scrollRight || y < scrollTop || y > scrollBottom) {\n        var scrollSpeedX = 0;\n        var scrollSpeedY = 0;\n\n        if (x < scrollLeft) {\n          scrollSpeedX = x - scrollLeft;\n        } else if (x > scrollRight) {\n          scrollSpeedX = x - scrollRight;\n        }\n\n        if (y < scrollTop) {\n          scrollSpeedY = y - scrollTop;\n        } else if (y > scrollBottom) {\n          scrollSpeedY = y - scrollBottom;\n        }\n\n        this._scroll(event, scrollSpeedX, scrollSpeedY);\n      } else {\n        this._stopScrolling();\n      }\n\n      return dropOperation;\n    }\n  }, {\n    key: '_scroll',\n    value: function _scroll(event, scrollSpeedX, scrollSpeedY) {\n      var _this4 = this;\n\n      this._scrollSpeedX = scrollSpeedX * 0.33;\n      this._scrollSpeedY = scrollSpeedY * 0.33;\n\n      var frame = function frame() {\n        _this4.setContentOffset(new _Point2.default(_this4._contentOffset.x + _this4._scrollSpeedX, _this4._contentOffset.y + _this4._scrollSpeedY));\n\n        if (_this4._scrollTimer) {\n          _this4._scrollTimer = (0, _raf2.default)(frame);\n        }\n      };\n\n      this._scrollTimer = this._scrollTimer || (0, _raf2.default)(frame);\n    }\n  }, {\n    key: '_stopScrolling',\n    value: function _stopScrolling() {\n      if (this._scrollTimer) {\n        _raf2.default.cancel(this._scrollTimer);\n\n        this._scrollTimer = null;\n      }\n    }\n  }, {\n    key: 'dragExited',\n    value: function dragExited() {\n      var _this5 = this;\n\n      this._setDropTarget(null);\n\n      this.relayoutNow();\n\n      this._stopScrolling();\n\n      if (!this._dragTarget) {\n        setTimeout(function () {\n          if (!_this5._dragTarget) {\n            _this5._disableTransitions();\n          }\n        }, this.transitionDuration);\n      }\n    }\n  }, {\n    key: 'dragEnd',\n    value: function dragEnd(event, dropOperation) {\n      this.dragExited();\n      var target = this._dragTarget;\n      this._dragTarget = null;\n\n      this._setDropTarget(null);\n\n      if (!this._transaction) {\n        this._disableTransitions();\n      }\n\n      if (dropOperation && this.delegate.dragAccepted) {\n        this.delegate.dragAccepted(target, dropOperation);\n      }\n    }\n  }, {\n    key: 'drop',\n    value: function drop(event, dropOperation) {\n      var _this6 = this;\n\n      var dropTarget = this._dropTarget;\n\n      if (!dropTarget) {\n        return;\n      }\n\n      this._setDropTarget(null);\n\n      if (this._dragTarget) {\n        var dragTarget = this._dragTarget;\n        (0, _raf2.default)(function () {\n          _this6.dataSource.performReorder(dragTarget, dropTarget, dropOperation, _this6._selection.getIndexPathSet());\n        });\n      } else {\n        var items = null; // Ask the delegate to deserialize the drag data for us, otherwise try the default format\n\n        if (this.delegate.itemsForDrop) {\n          items = this.delegate.itemsForDrop(dropTarget, event.dataTransfer);\n        } else {\n          var json = event.dataTransfer.getData('CollectionViewData');\n          items = json && JSON.parse(json);\n        }\n\n        if (!Array.isArray(items)) {\n          return;\n        }\n\n        (0, _raf2.default)(function () {\n          _this6.dataSource.performDrop(dropTarget, dropOperation, items);\n        });\n      }\n    } // MARK: transactions\n\n  }, {\n    key: '_performTransaction',\n    value: function _performTransaction(transaction) {\n      // Copy selection so we can modify safely during the transaction\n      transaction.selection = this._selection.copy();\n\n      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performTransaction', this).call(this, transaction); // If the selection was modified, update the real one\n\n\n      if (!transaction.selection.equals(this._selection)) {\n        this._selection = transaction.selection;\n\n        this._updateSelection();\n      }\n    }\n  }, {\n    key: '_performInsertItem',\n    value: function _performInsertItem(item, indexPath) {\n      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performInsertItem', this).call(this, item, indexPath);\n\n      this._transaction.selection.adjustForInsertionInSection(indexPath.section, new _Range2.default(indexPath.index, indexPath.index));\n    }\n  }, {\n    key: '_performRemoveItem',\n    value: function _performRemoveItem(indexPath) {\n      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performRemoveItem', this).call(this, indexPath);\n\n      this._transaction.selection.adjustForDeletionInSection(indexPath.section, new _Range2.default(indexPath.index, indexPath.index));\n    }\n  }, {\n    key: '_performMoveItem',\n    value: function _performMoveItem(from, to) {\n      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performMoveItem', this).call(this, from, to);\n\n      this._transaction.selection.adjustForMove(from, to);\n    }\n  }, {\n    key: '_performInsertSection',\n    value: function _performInsertSection(section, items) {\n      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performInsertSection', this).call(this, section, items);\n\n      this._transaction.selection.adjustForInsertedSection(section);\n    }\n  }, {\n    key: '_performRemoveSection',\n    value: function _performRemoveSection(section) {\n      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performRemoveSection', this).call(this, section);\n\n      this._transaction.selection.adjustForDeletedSection(section);\n    }\n  }, {\n    key: '_performMoveSection',\n    value: function _performMoveSection(fromSection, toSection) {\n      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performMoveSection', this).call(this, fromSection, toSection);\n\n      this._transaction.selection.adjustForMovedSection(fromSection, toSection);\n    }\n  }, {\n    key: '_performReloadSection',\n    value: function _performReloadSection(section, items) {\n      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), '_performReloadSection', this).call(this, section, items);\n\n      this._transaction.selection.adjustForReloadedSection(section);\n    } // MARK: keyboard support\n\n  }, {\n    key: 'keyDown',\n    value: function keyDown(event) {\n      this.emit('keyDown', event);\n\n      if (event.isDefaultPrevented && event.isDefaultPrevented()) {\n        return;\n      }\n\n      switch (event.keyCode) {\n        case 13: // enter\n\n        case 32:\n          // space\n          event.preventDefault();\n          this.selectItem(this._focusedIndexPath, event.metaKey || this.selectionMode === 'toggle', event.shiftKey);\n          break;\n\n        case 37:\n          // left\n          event.preventDefault();\n\n          if (event.shiftKey) {\n            return this.selectLeft();\n          }\n\n          return this.moveLeft();\n\n        case 38:\n          // up\n          event.preventDefault();\n\n          if (event.shiftKey) {\n            return this.selectUp();\n          }\n\n          return this.moveUp();\n\n        case 39:\n          // right\n          event.preventDefault();\n\n          if (event.shiftKey) {\n            return this.selectRight();\n          }\n\n          return this.moveRight();\n\n        case 40:\n          // down\n          event.preventDefault();\n\n          if (event.shiftKey) {\n            return this.selectDown();\n          }\n\n          return this.moveDown();\n\n        case 27:\n          // escape\n          event.preventDefault();\n          return this.clearSelection();\n\n        case 65:\n          // A\n          if (event.metaKey) {\n            event.preventDefault();\n            this.selectAll();\n          }\n\n          return;\n\n        case 46: // delete\n\n        case 8:\n          // backspace\n          if (this.canDeleteItems) {\n            event.preventDefault();\n          }\n\n          return this.delete();\n      }\n    }\n  }, {\n    key: 'onFocus',\n    value: function onFocus(event) {\n      this.emit('focus', event);\n\n      if (!this.backendView) {\n        return;\n      }\n\n      var node = this.getDOMNode();\n\n      if (node === event.target) {\n        return;\n      } // prevent scrollview from scrolling on focus\n\n\n      if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object' && 'scrollTop' in node) {\n        node.scrollTop = 0;\n      }\n\n      var focusedIndexPath = void 0;\n      var restoringFocus = node === event.relatedTarget;\n\n      if (restoringFocus) {\n        focusedIndexPath = this._focusedIndexPath;\n      } else {\n        focusedIndexPath = this.indexPathAtDOMNode(event.target);\n      }\n\n      if (focusedIndexPath) {\n        this._focusedIndexPath = focusedIndexPath; // Select if keyboardMode is selection, selectionMode is toggle, and selection has not already happened.\n\n        if (this.keyboardMode === 'selection' && this.selectionMode === 'toggle' && this._selection.isEmpty) {\n          this.selectItem(focusedIndexPath, false, false);\n        }\n\n        if (!restoringFocus) {\n          this.scrollToItem(focusedIndexPath, SCROLLTOITEM_DURATION);\n        } // update focused state and tabIndex for visible views\n\n\n        this._updateVisibleViewStates();\n      }\n    }\n  }, {\n    key: 'onBlur',\n    value: function onBlur(event) {\n      this.emit('blur', event);\n    }\n  }, {\n    key: 'scroll',\n    value: function scroll(e) {\n      var _this7 = this;\n\n      _get(EditableCollectionView.prototype.__proto__ || Object.getPrototypeOf(EditableCollectionView.prototype), 'scroll', this).call(this, e);\n\n      var indexPath = this._focusedIndexPath;\n\n      if (indexPath) {\n        var view = this.getItemView(indexPath.section, indexPath.index); // if the focused item has scrolled out of view and no longer exists in DOM\n\n        if (!view && this.attrs.tabIndex !== 0) {\n          this.setAttribute('tabIndex', 0); // set focus to the collection view and make sure that it can still receive focus with the tab key\n\n          this.focus();\n        } else if (view && this.attrs.tabIndex !== -1) {\n          // otherwise the collection view itself should not receive focus with the tab key,\n          this.setAttribute('tabIndex', -1); // focus should be restored to the focused item\n\n          (0, _raf2.default)(function () {\n            return _this7.focusItem(indexPath);\n          });\n        }\n      }\n    }\n  }, {\n    key: '_moveSelection',\n    value: function _moveSelection(method, indexPath) {\n      var extend = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var select = true; // If keyboardMode is focus, move the focused item instead of changing the selection.\n\n      if (this._focusedIndexPath) {\n        indexPath = this._focusedIndexPath;\n      }\n\n      if (this.keyboardMode === 'focus') {\n        select = extend;\n      }\n\n      if (!indexPath) {\n        return;\n      }\n\n      indexPath = this.layout[method](indexPath);\n\n      if (select) {\n        this.selectItem(indexPath, false, extend);\n      }\n\n      this.scrollToItem(indexPath, SCROLLTOITEM_DURATION);\n      this.focusItem(indexPath);\n    }\n    /**\n     * Selects the item above the currently selected one, replacing the existing selection.\n     */\n\n  }, {\n    key: 'moveUp',\n    value: function moveUp() {\n      this._moveSelection('indexPathAbove', this._selection.firstIndexPath);\n    }\n    /**\n     * Selects the item below the currently selected one, replacing the existing selection.\n     */\n\n  }, {\n    key: 'moveDown',\n    value: function moveDown() {\n      this._moveSelection('indexPathBelow', this._selection.lastIndexPath);\n    }\n    /**\n     * Selects the item to the left of the currently selected one, replacing the existing selection.\n     */\n\n  }, {\n    key: 'moveLeft',\n    value: function moveLeft() {\n      this._moveSelection('indexPathLeftOf', this._selection.firstIndexPath);\n    }\n    /**\n     * Selects the item to the right of the currently selected one, replacing the existing selection.\n     */\n\n  }, {\n    key: 'moveRight',\n    value: function moveRight() {\n      this._moveSelection('indexPathRightOf', this._selection.lastIndexPath);\n    }\n    /**\n     * Selects the item above the currently selected one, extending the existing selection.\n     */\n\n  }, {\n    key: 'selectUp',\n    value: function selectUp() {\n      this._moveSelection('indexPathAbove', this._selection.current, true);\n    }\n    /**\n     * Selects the item below the currently selected one, extending the existing selection.\n     */\n\n  }, {\n    key: 'selectDown',\n    value: function selectDown() {\n      this._moveSelection('indexPathBelow', this._selection.current, true);\n    }\n    /**\n     * Selects the item to the left of the currently selected one, extending the existing selection.\n     */\n\n  }, {\n    key: 'selectLeft',\n    value: function selectLeft() {\n      this._moveSelection('indexPathLeftOf', this._selection.current, true);\n    }\n    /**\n     * Selects the item to the right of the currently selected one, extending the existing selection.\n     */\n\n  }, {\n    key: 'selectRight',\n    value: function selectRight() {\n      this._moveSelection('indexPathRightOf', this._selection.current, true);\n    }\n    /**\n     * Triggers a deletion of the currently selected items via the data source\n     */\n\n  }, {\n    key: 'delete',\n    value: function _delete() {\n      var selectedIndexPaths = this.selectedIndexPaths;\n      var shouldDelete = this.canDeleteItems && (!this.delegate.shouldDeleteItems || this.delegate.shouldDeleteItems(selectedIndexPaths));\n\n      if (shouldDelete) {\n        this.dataSource.removeItems(selectedIndexPaths);\n      }\n    }\n  }, {\n    key: 'selectedIndexPaths',\n    get: function get() {\n      return this._selection.getIndexPathSet();\n    },\n    set: function set(indexPaths) {\n      if (!this.canSelectItems) {\n        return;\n      }\n\n      this._selection.clear();\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = indexPaths[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var indexPath = _step3.value;\n\n          this._selection.toggleIndexPath(indexPath);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      this._updateSelection(false);\n    }\n    /**\n     * The currently selected IndexPath\n     * @type {IndexPath}\n     */\n\n  }, {\n    key: 'focusedIndexPath',\n    get: function get() {\n      return this._focusedIndexPath;\n    }\n  }]);\n\n  return EditableCollectionView;\n}(_CollectionView3.default);\n\nexports.default = EditableCollectionView;","map":null,"metadata":{},"sourceType":"script"}