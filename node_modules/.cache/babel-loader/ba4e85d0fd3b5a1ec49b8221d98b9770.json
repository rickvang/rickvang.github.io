{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _DragTarget = require('./DragTarget');\n\nvar _DragTarget2 = _interopRequireDefault(_DragTarget);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * {@link CollectionView} supports arbitrary layout objects, which compute what views are visible, and how\n * to position and style them. However, layouts do not create the views themselves directly. Instead,\n * layouts produce lightweight {@link LayoutInfo} objects which describe various properties of a view,\n * such as its position and size. The {@link CollectionView} is then responsible for creating the actual\n * views as needed, based on this layout information.\n *\n * Every layout extends from the {@link Layout} abstract base class. Layouts must implement a minimum of the\n * two methods listed below. All other methods can be optionally overridden to implement custom behavior.\n *\n * - {@link getVisibleLayoutInfos}\n * - {@link getLayoutInfo}\n */\n\n\nvar Layout = function () {\n  function Layout() {\n    _classCallCheck(this, Layout);\n    /**\n     * The CollectionView the layout is currently attached to\n     * @type {CollectionView}\n     */\n\n\n    this.collectionView = null;\n  }\n  /**\n   * Returns whether the layout should invalidate in response to\n   * visible rectangle changes. By default, it only invalidates\n   * when the collection view's size changes. Return true always\n   * to make the layout invalidate while scrolling (e.g. sticky headers).\n   * @param {Rect} rect\n   * @return {boolean}\n   */\n\n\n  _createClass(Layout, [{\n    key: 'shouldInvalidate',\n    value: function shouldInvalidate(rect) {\n      // By default, invalidate when the size changes\n      var size = this.collectionView.size;\n      return rect.width !== size.width || rect.height !== size.height;\n    }\n    /**\n     * This method allows the layout to perform any pre-computation\n     * it needs to in order to prepare {@link LayoutInfo}s for retrieval.\n     * Called by the collection view before {@link getVisibleLayoutInfos}\n     * or {@link getLayoutInfo} are called.\\\n     * @param {object} invalidationContext\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(invalidationContext) {}\n    /**\n     * Returns an array of {@link LayoutInfo} objects which are inside the given rectangle.\n     * Should be implemented by subclasses.\n     * @abstract\n     * @param {Rect} rect - The rectangle that should contain the returned LayoutInfo objects\n     * @return {LayoutInfo[]}\n     */\n\n  }, {\n    key: 'getVisibleLayoutInfos',\n    value: function getVisibleLayoutInfos(rect) {\n      throw new Error('getVisibleLayoutInfos must be implemented by Layout subclasses');\n    }\n    /**\n     * Returns a {@link LayoutInfo} for the given type, section, and index.\n     * Should be implemented by subclasses.\n     * @abstract\n     * @param {string} type - The type of the LayoutInfo to retrieve\n     * @param {number} section - The section of the LayoutInfo to retrieve\n     * @param {index} index - The index of the LayoutInfo to retrieve\n     * @return {LayoutInfo}\n     */\n\n  }, {\n    key: 'getLayoutInfo',\n    value: function getLayoutInfo(type, section, index) {\n      throw new Error('getLayoutInfo must be implemented by Layout subclasses');\n    }\n    /**\n     * Returns a {@link DragTarget} describing a view at the given point to be dragged.\n     * Return `null` to cancel the drag. The default implementation returns the view at the given point.\n     * @param {Point} point - The point at which the drag occurred\n     * @return {?DragTarget}\n     */\n\n  }, {\n    key: 'getDragTarget',\n    value: function getDragTarget(point) {\n      var target = this.collectionView.indexPathAtPoint(point);\n\n      if (!target) {\n        return null;\n      }\n\n      return new _DragTarget2.default('item', target);\n    }\n    /**\n     * Returns a {@link DragTarget} object describing where a drop should occur. Return `null`\n     * to reject the drop. The dropped items will be inserted before the resulting target.\n     * @param {Point} point - The point at which the drop occurred\n     * @return {?DragTarget}\n     */\n\n  }, {\n    key: 'getDropTarget',\n    value: function getDropTarget(point) {\n      return null;\n    }\n    /**\n     * Returns the starting attributes for an animated insertion.\n     * The view is animated from this {@link LayoutInfo} to the one returned by {@link getLayoutInfo}.\n     * The default implementation just returns a copy of the result of calling {@link getLayoutInfo}.\n     *\n     * @param {string} type - The type of the LayoutInfo to retrieve\n     * @param {number} section - The section of the LayoutInfo to retrieve\n     * @param {index} index - The index of the LayoutInfo to retrieve\n     * @return {LayoutInfo}\n     */\n\n  }, {\n    key: 'getInitialLayoutInfo',\n    value: function getInitialLayoutInfo(type, section, index) {\n      return this.getLayoutInfo(type, section, index).copy();\n    }\n    /**\n     * Returns the ending attributes for an animated removal.\n     * The view is animated from the {@link LayoutInfo} returned by {@link getLayoutInfo}\n     * to the one returned by this method. The default implementation returns a copy of\n     * the starting {@link LayoutInfo}.\n     *\n     * @param {string} type - The type of the LayoutInfo to retrieve\n     * @param {number} section - The section of the LayoutInfo to retrieve\n     * @param {index} index - The index of the LayoutInfo to retrieve\n     * @return {LayoutInfo}\n     */\n\n  }, {\n    key: 'getFinalLayoutInfo',\n    value: function getFinalLayoutInfo(type, section, index) {\n      var key = [type, section, index].join(':');\n      return this.collectionView._transaction.finalLayoutInfo.get(key).copy();\n    }\n    /**\n     * Called to notify the layout of an item insertion.\n     * Does nothing by default.\n     * @param {IndexPath} indexPath - The inserted IndexPath\n     */\n\n  }, {\n    key: 'itemInserted',\n    value: function itemInserted(indexPath) {}\n    /**\n     * Called to notify the layout of an item removal.\n     * Does nothing by default.\n     * @param {IndexPath} indexPath - The removed IndexPath\n     */\n\n  }, {\n    key: 'itemRemoved',\n    value: function itemRemoved(indexPath) {}\n    /**\n     * Called to notify the layout of an item move.\n     * Does nothing by default.\n     * @param {IndexPath} from - The source IndexPath\n     * @param {IndexPath} to - The destination IndexPath\n     */\n\n  }, {\n    key: 'itemMoved',\n    value: function itemMoved(from, to) {}\n    /**\n     * Called to notify the layout of an item replacement.\n     * Does nothing by default.\n     * @param {IndexPath} indexPath - The replaced IndexPath\n     */\n\n  }, {\n    key: 'itemReplaced',\n    value: function itemReplaced(indexPath) {}\n    /**\n     * Called to notify the layout of a section insertion.\n     * Does nothing by default.\n     * @param {number} section - The inserted section\n     */\n\n  }, {\n    key: 'sectionInserted',\n    value: function sectionInserted(section) {}\n    /**\n     * Called to notify the layout of a section removal.\n     * Does nothing by default.\n     * @param {number} section - The remove section\n     */\n\n  }, {\n    key: 'sectionRemoved',\n    value: function sectionRemoved(section) {}\n    /**\n     * Called to notify the layout of a section insertion.\n     * Does nothing by default.\n     * @param {number} fromSection - The source section\n     * @param {number} toSection - The destination section\n     */\n\n  }, {\n    key: 'sectionMoved',\n    value: function sectionMoved(fromSection, toSection) {}\n    /**\n     * Called to notify the layout of a section replacement.\n     * Does nothing by default.\n     * @param {number} section - The replaced section\n     */\n\n  }, {\n    key: 'sectionReplaced',\n    value: function sectionReplaced(section) {}\n    /**\n     * Returns the {@link IndexPath} visually above the given one, or `null` for none.\n     * Used for keyboard navigation. Should be implemented by subclasses, returns `null`\n     * by default.\n     * @param {IndexPath} indexPath\n     * @return {IndexPath}\n     */\n\n  }, {\n    key: 'indexPathAbove',\n    value: function indexPathAbove(indexPath) {\n      return null;\n    }\n    /**\n     * Returns the {@link IndexPath} visually below the given one, or `null` for none.\n     * Used for keyboard navigation. Should be implemented by subclasses, returns `null`\n     * by default.\n     * @param {IndexPath} indexPath\n     * @return {IndexPath}\n     */\n\n  }, {\n    key: 'indexPathBelow',\n    value: function indexPathBelow(indexPath) {\n      return null;\n    }\n    /**\n     * Returns the {@link IndexPath} visually to the left of the given one, or `null` for none.\n     * Used for keyboard navigation. Should be implemented by subclasses, returns `null`\n     * by default.\n     * @param {IndexPath} indexPath\n     * @return {IndexPath}\n     */\n\n  }, {\n    key: 'indexPathLeftOf',\n    value: function indexPathLeftOf(indexPath) {\n      return null;\n    }\n    /**\n     * Returns the {@link IndexPath} visually to the right of the given one, or `null` for none.\n     * Used for keyboard navigation. Should be implemented by subclasses, returns `null`\n     * by default.\n     * @param {IndexPath} indexPath\n     * @return {IndexPath}\n     */\n\n  }, {\n    key: 'indexPathRightOf',\n    value: function indexPathRightOf(indexPath) {\n      return null;\n    }\n    /**\n     * Returns size of the content. By default, it returns collectionView's size.\n     * @return {Size}\n     */\n\n  }, {\n    key: 'getContentSize',\n    value: function getContentSize() {\n      var contentSize = this.collectionView.size.copy(); // backward compatibility - if there are contentWidth/contentHeight set, override content's size\n\n      if (this.contentWidth) {\n        contentSize.width = this.contentWidth;\n      }\n\n      if (this.contentHeight) {\n        contentSize.height = this.contentHeight;\n      }\n\n      return contentSize;\n    }\n  }]);\n\n  return Layout;\n}();\n\nexports.default = Layout;","map":null,"metadata":{},"sourceType":"script"}