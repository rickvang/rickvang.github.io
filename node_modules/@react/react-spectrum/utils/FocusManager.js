'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TABBABLE_ELEMENT_SELECTOR = exports.FOCUSABLE_ELEMENT_SELECTOR = exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class;

exports.trapFocus = trapFocus;

var _autobindDecorator = require('autobind-decorator');

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

var _events = require('./events');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _string = require('./string');

var _scrollToDOMNode = require('./scrollToDOMNode');

var _scrollToDOMNode2 = _interopRequireDefault(_scrollToDOMNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var WHITESPACE_REGEXP = /[\n\r]+|[\s]{1,}/g;
var DELAY_BEFORE_AUTOFOCUS = 20;

var FocusManager = (0, _autobindDecorator2.default)(_class = function (_React$Component) {
  _inherits(FocusManager, _React$Component);

  function FocusManager() {
    var _ref;

    var _temp, _this, _ret;

    _classCallCheck(this, FocusManager);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = FocusManager.__proto__ || Object.getPrototypeOf(FocusManager)).call.apply(_ref, [this].concat(args))), _this), _this.keysSoFar = '', _this.keyClearTimeout = null, _temp), _possibleConstructorReturn(_this, _ret);
  }

  _createClass(FocusManager, [{
    key: 'getItems',
    value: function getItems() {
      var selected = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var _props = this.props,
          itemSelector = _props.itemSelector,
          selectedItemSelector = _props.selectedItemSelector,
          includeSelf = _props.includeSelf;

      var selector = selected && selectedItemSelector ? selectedItemSelector : itemSelector;
      var node = _reactDom2.default.findDOMNode(this);
      var array = [];
      if (includeSelf && node.matches(selector)) {
        array.push(node);
      }
      return array.concat(Array.from(node.querySelectorAll(selector)));
    }
  }, {
    key: 'onFocusFirst',
    value: function onFocusFirst(e) {
      var items = this.getItems();
      if (items.length && (!e || items.indexOf(e.target) !== -1)) {
        if (e) {
          e.preventDefault();
        }

        items[0].focus();
      }
    }
  }, {
    key: 'onFocusLast',
    value: function onFocusLast(e) {
      var items = this.getItems();
      if (items.length && (!e || items.indexOf(e.target) !== -1)) {
        if (e) {
          e.preventDefault();
        }

        items[items.length - 1].focus();
      }
    }
  }, {
    key: 'onFocusPrevious',
    value: function onFocusPrevious(e) {
      var items = this.getItems();
      if (items.length && e && items.indexOf(e.target) !== -1) {
        e.preventDefault();

        var index = items.indexOf(e.target) - 1;
        if (index < 0) {
          index = items.length - 1;
        }
        items[index].focus();
      }
    }
  }, {
    key: 'onFocusNext',
    value: function onFocusNext(e) {
      var items = this.getItems();
      if (items.length && e && items.indexOf(e.target) !== -1) {
        e.preventDefault();

        var index = items.indexOf(e.target) + 1;
        if (index >= items.length) {
          index = 0;
        }
        items[index].focus();
      }
    }
  }, {
    key: 'onPageUp',
    value: function onPageUp(e) {
      if (this.props.ignorePageUpPageDown) {
        return;
      }

      var items = this.getItems();
      if (items.length && e && items.indexOf(e.target) !== -1) {
        e.preventDefault();

        var listNode = _reactDom2.default.findDOMNode(this);
        var nextPage = Math.max(e.target.offsetTop + e.target.offsetHeight - listNode.clientHeight, 0);
        var index = items.indexOf(e.target);
        var item = items.slice(0, index).reverse().find(function (item) {
          return item.offsetTop < nextPage;
        });

        if (item) {
          item.focus();
          (0, _scrollToDOMNode2.default)(item, listNode, true);
        } else {
          this.onFocusFirst(e);
        }
      }
    }
  }, {
    key: 'onPageDown',
    value: function onPageDown(e) {
      if (this.props.ignorePageUpPageDown) {
        return;
      }

      var items = this.getItems();
      if (items.length && e && items.indexOf(e.target) !== -1) {
        e.preventDefault();

        var listNode = _reactDom2.default.findDOMNode(this);
        var nextPage = Math.min(e.target.offsetTop + listNode.clientHeight, listNode.scrollHeight + listNode.clientHeight);
        var index = items.indexOf(e.target) + 1;
        var item = items.slice(index).find(function (item) {
          return item.offsetTop + item.offsetHeight > nextPage;
        });

        if (item) {
          item.focus();
          (0, _scrollToDOMNode2.default)(item, listNode, true);
        } else {
          this.onFocusLast(e);
        }
      }
    }
  }, {
    key: 'findItemToFocus',
    value: function findItemToFocus(e) {
      var target = e.target,
          shiftKey = e.shiftKey,
          charCode = e.charCode;


      var character = (0, _string.removeDiacritics)(String.fromCharCode(charCode)).toUpperCase();

      var items = this.getItems();

      if (this.keysSoFar === '' || character === this.keysSoFar || shiftKey) {
        // reverse order if shiftKey is pressed
        if (shiftKey) {
          items = items.reverse();
        }
        this.searchIndex = items.indexOf(target);
      }

      if (character !== this.keysSoFar) {
        this.keysSoFar += character;
      }

      this.clearKeysSoFarAfterDelay();

      var item = this.findMatchInRange(items, this.searchIndex + 1, items.length);

      if (!item) {
        item = this.findMatchInRange(items, 0, this.searchIndex);
      }

      if (item) {
        item.focus();
      }
    }
  }, {
    key: 'clearKeysSoFarAfterDelay',
    value: function clearKeysSoFarAfterDelay() {
      var _this2 = this;

      if (this.keyClearTimeout) {
        clearTimeout(this.keyClearTimeout);
      }
      this.keyClearTimeout = setTimeout(function () {
        return _this2.keysSoFar = '';
      }, 500);
    }
  }, {
    key: 'findMatchInRange',
    value: function findMatchInRange(items, startIndex, endIndex) {
      // Find the first item starting with the keysSoFar substring, searching in the specified range of items
      for (var i = startIndex; i < endIndex; i++) {
        var label = items[i].innerText || items[i].textContent;
        if (label && (0, _string.removeDiacritics)(label).replace(WHITESPACE_REGEXP, '').toUpperCase().indexOf(this.keysSoFar) === 0) {
          return items[i];
        }
      }
      return null;
    }

    /**
     * Handle keydown event
     * @param {Event} e Event object
     */

  }, {
    key: 'onKeyDown',
    value: function onKeyDown(e) {
      if (e.isPropagationStopped()) {
        return;
      }

      _events.interpretKeyboardEvent.call(this, e, this.props.orientation);
    }

    /**
     * Handle keypress event
     * @param {Event} e Event object
     */

  }, {
    key: 'onKeyPress',
    value: function onKeyPress(e) {
      if (e.isPropagationStopped()) {
        return;
      }

      this.findItemToFocus(e);
    }

    /**
     * When an item receives focus, it should have tabIndex === 0 and all other items should have tabIndex === -1
     * @param {Event} e Event object
     */

  }, {
    key: 'onFocus',
    value: function onFocus(e) {
      if (e.isPropagationStopped()) {
        return;
      }

      this.getItems().forEach(function (item) {
        return item.tabIndex = item === e.target ? 0 : -1;
      });
    }

    /**
     * When an item loses focus, set the appropriate tabIndex on each item based on its selected state.
     * If the item losing focus is selected,
     * it should be the only item to receive focus on shift+tab or tab back to the control,
     * However, if the item losing focus is not selected,
     * any of the selected items should receive focus on shift+tab or tab.
     * @param {Event} e Event object
     */

  }, {
    key: 'onBlur',
    value: function onBlur(e) {
      if (e.isPropagationStopped()) {
        return;
      }

      var selectedItems = this.getItems(true);

      // If there are selected items,
      if (selectedItems.length) {
        // store whether item losing focus is selected.
        var targetSelected = selectedItems.indexOf(e.target) !== -1;

        this.getItems().forEach(function (item) {

          // store whether the current item is selected.
          var selected = selectedItems.indexOf(item) !== -1;

          // If the current item is the item losing focus and it is selected,
          // or the current item is selected and the item losing focus is not selected,
          // set tabIndex === 0, otherwise set tabIndex === -1.
          item.tabIndex = item === e.target && targetSelected || !targetSelected && selected ? 0 : -1;
        });
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this3 = this;

      var _props2 = this.props,
          autoFocus = _props2.autoFocus,
          selectedItemSelector = _props2.selectedItemSelector;

      if (autoFocus) {
        var selectedItem = selectedItemSelector ? _reactDom2.default.findDOMNode(this).querySelector(selectedItemSelector) : null;

        // wait a frame before trying to shift focus
        this.focusTimer = setTimeout(function () {
          if (selectedItem) {
            selectedItem.focus();
          } else {
            _this3.onFocusFirst();
          }
        }, DELAY_BEFORE_AUTOFOCUS);
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearTimeout(this.focusTimer);
    }
  }, {
    key: 'render',
    value: function render() {
      var _props3 = this.props,
          children = _props3.children,
          disabled = _props3.disabled,
          manageTabIndex = _props3.manageTabIndex,
          typeToSelect = _props3.typeToSelect;

      var child = _react2.default.Children.only(children);
      var _child$props = child.props,
          onKeyDown = _child$props.onKeyDown,
          onKeyPress = _child$props.onKeyPress,
          onFocus = _child$props.onFocus,
          onBlur = _child$props.onBlur;

      return _react2.default.cloneElement(child, {
        onKeyDown: !disabled ? (0, _events.chain)(onKeyDown, this.onKeyDown) : onKeyDown,
        onKeyPress: typeToSelect && !disabled ? (0, _events.chain)(onKeyPress, this.onKeyPress) : onKeyPress,
        onFocus: manageTabIndex && !disabled ? (0, _events.chain)(onFocus, this.onFocus) : onFocus,
        onBlur: manageTabIndex && !disabled ? (0, _events.chain)(onBlur, this.onBlur) : onBlur
      });
    }
  }]);

  return FocusManager;
}(_react2.default.Component)) || _class;

FocusManager.propTypes = {

  /**
   * A selector of focusable elements to manage focus between
   */
  itemSelector: _propTypes2.default.string.isRequired,

  /**
   * Whether to use roving tabIndex so that only one element within the group can receive focus with tab key at a time.
   */
  manageTabIndex: _propTypes2.default.bool,

  /**
   * Orientation of items; "horizontal" orientation ignores up/down arrow keys, "vertical" orientation ignores left/right arrow keys, "both" handles up/left and down/right.
   */
  orientation: _propTypes2.default.oneOf(['horizontal', 'vertical', 'both']),

  /**
   * A selector of selected elements
   */
  selectedItemSelector: _propTypes2.default.string,

  /**
   * Whether to disable focus management
   */
  disabled: _propTypes2.default.bool,

  /**
   * Whether to include alphanumeric typing as a way to move focus to items in a list.
   */
  typeToSelect: _propTypes2.default.bool,

  /**
   * Whether to include the child wrapper element in the group of elements that can receive focus.
   */
  includeSelf: _propTypes2.default.bool,

  /**
   * Whether to ignore PageUp and PageDown events to move focus between items.
   */
  ignorePageUpPageDown: _propTypes2.default.bool,

  /**
   * Whether to autoFocus first selected item or first item.
   */
  autoFocus: _propTypes2.default.bool
};
FocusManager.defaultProps = {
  manageTabIndex: true,
  orientation: 'vertical',
  typeToSelect: false,
  includeSelf: false,
  ignorePageUpPageDown: false
};
exports.default = FocusManager;


var focusableElements = ['input:not([disabled]):not([type=hidden])', 'select:not([disabled])', 'textarea:not([disabled])', 'button:not([disabled])', 'a[href]', 'area[href]', 'summary', 'iframe', 'object', 'embed', 'audio[controls]', 'video[controls]', '[contenteditable]'];

var FOCUSABLE_ELEMENT_SELECTOR = exports.FOCUSABLE_ELEMENT_SELECTOR = focusableElements.join(',') + ',[tabindex]';

focusableElements.push('[tabindex]:not([tabindex="-1"])');

var TABBABLE_ELEMENT_SELECTOR = exports.TABBABLE_ELEMENT_SELECTOR = focusableElements.join(':not([tabindex="-1"]),');

function trapFocus(componentOrElement, event) {
  var type = event.type,
      key = event.key,
      shiftKey = event.shiftKey,
      target = event.target;


  var node = void 0;
  var tabbables = void 0;
  var tabbable = void 0;
  var first = void 0;
  var last = void 0;

  if (type === 'keydown' || type === 'focus') {
    node = _reactDom2.default.findDOMNode(componentOrElement);
    if (node) {
      // find tabbable elements within container element
      tabbables = Array.from(node.querySelectorAll(TABBABLE_ELEMENT_SELECTOR)).filter(function (el) {
        return el !== node;
      });
      first = tabbables[0];
      last = tabbables[tabbables.length - 1];
    }
  }

  // If navigating using the tab key,
  if (type === 'keydown' && key === 'Tab') {
    if (node) {
      if (shiftKey) {
        // with focus on first tabbable element, navigating backwards,
        if (target === first) {
          // focus the last tabbable element
          tabbable = last;
        }
        // otherwise, with focus on last tabbable element, navigating forwards,
      } else if (target === last) {
        // focus the first tabbable element.
        tabbable = first;
      }
    }
  } else if (type === 'focus') {
    if (target === node) {
      tabbable = first;
    }
  }
  if (tabbable) {
    event.preventDefault();
    event.stopPropagation();
    tabbable.focus();
  }
}