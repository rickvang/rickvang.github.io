'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var DEFAULT_OPTIONS = {
  cacheSize: 500,
  maxConcurrentDownloads: 10
};

// static callback for use when preloading images.
var PRELOAD_CB = function PRELOAD_CB() {};

/**
 * This class caches images locally during a browser session,
 * and ensures that images are not reloaded from the network
 * as users scroll around. It can also preload images in advance.
 */

var ImageCache = exports.ImageCache = function () {
  function ImageCache(options) {
    _classCallCheck(this, ImageCache);

    this.options = Object.assign({}, DEFAULT_OPTIONS, options);

    this._cache = new Map();
    this._callbacks = {};
    this._xhr = {};
    this._queue = [];
    this._active = 0;
  }

  _createClass(ImageCache, [{
    key: '_loadImage',
    value: function _loadImage(url, options, callback) {
      // If the image is already loading, just add the callback
      if (this._callbacks[url]) {
        this._callbacks[url].add(callback);
        return;
      }

      // Save callback, and enqueue the url to load.
      this._callbacks[url] = new Set([callback]);
      this._enqueue(this._load.bind(this, url, options));
    }
  }, {
    key: '_enqueue',
    value: function _enqueue(fn) {
      this._queue.push(fn);
      this._runQueue();
    }
  }, {
    key: '_runQueue',
    value: function _runQueue() {
      var _this = this;

      // Run items from the queue until we reach the maximum concurrency limit
      while (this._queue.length > 0 && this._active < this.options.maxConcurrentDownloads) {
        var fn = this._queue.shift();
        this._active++;
        fn(function () {
          _this._active--;
          _this._runQueue();
        });
      }
    }
  }, {
    key: '_load',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(url, options, callback) {
        var _this2 = this;

        var xhr, key;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (this._callbacks[url]) {
                  _context.next = 3;
                  break;
                }

                callback();
                return _context.abrupt('return');

              case 3:
                xhr = new XMLHttpRequest();

                xhr.open('GET', url);
                xhr.responseType = 'blob';

                if (options.headers) {
                  for (key in options.headers) {
                    xhr.setRequestHeader(key, options.headers[key]);
                  }
                }

                xhr.addEventListener('load', function () {
                  var blobURL = URL.createObjectURL(xhr.response);
                  _this2.set(url, blobURL);
                  _this2._callback(url, null, blobURL);
                  callback();
                });

                xhr.addEventListener('error', function (err) {
                  _this2._callback(url, err);
                  callback();
                });

                xhr.addEventListener('abort', function () {
                  callback();
                });

                this._xhr[url] = xhr;
                xhr.send();

              case 12:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function _load(_x, _x2, _x3) {
        return _ref.apply(this, arguments);
      }

      return _load;
    }()
  }, {
    key: '_callback',
    value: function _callback(url, err, blobURL) {
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._callbacks[url][Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var callback = _step.value;

          callback(err, blobURL);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      delete this._callbacks[url];
      delete this._xhr[url];
    }
  }, {
    key: 'set',
    value: function set(url, blobURL) {
      // If the cache exceeds the maximum, delete the first key in the map,
      // which corresponds to the least recently used item.
      if (this._cache.size >= this.options.cacheSize) {
        var toDelete = this._cache.keys().next().value;
        this.delete(toDelete);
      }

      this._cache.set(url, blobURL);
    }
  }, {
    key: 'delete',
    value: function _delete(url) {
      var blobURL = this._cache.get(url);
      if (blobURL) {
        URL.revokeObjectURL(blobURL);
        this._cache.delete(url);
      }
    }

    /**
     * Checks whether an image URL exists in the cache.
     */

  }, {
    key: 'has',
    value: function has(url) {
      return this._cache.has(url);
    }

    /**
     * Gets a blob URL for an image if it exists already in the cache.
     */

  }, {
    key: 'getCached',
    value: function getCached(url) {
      var blobURL = this._cache.get(url);
      if (blobURL) {
        // re-insert the blob url at the end of the map for LRU eviction strategy.
        this._cache.delete(url);
        this._cache.set(url, blobURL);
      }

      return blobURL;
    }

    /**
     * Gets a blob url for an image and calls the callback. If the image is not already cached, 
     * it will be queued and loaded.
     * @param {string} url
     * @param {?object} options
     * @param {function} callback
     */

  }, {
    key: 'get',
    value: function get(url, options, callback) {
      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      if (/^blob:/.test(url)) {
        return callback(null, url);
      }

      var blobURL = this.getCached(url);
      if (blobURL) {
        return callback(null, blobURL);
      }

      this._loadImage(url, options, callback);
    }

    /**
     * Aborts loading an image by URL for the provided callback function.
     */

  }, {
    key: 'abort',
    value: function abort(url, callback) {
      // Ignore if this url is not currently loading, or the callback wasn't found.
      if (!this._callbacks[url] || !this._callbacks[url].has(callback)) {
        return;
      }

      // Delete the callback from the list. If it is the last one, continue.
      this._callbacks[url].delete(callback);
      if (this._callbacks[url].size > 0) {
        return;
      }

      // Abort the request, if one is in progress.
      if (this._xhr[url]) {
        this._xhr[url].abort();
        delete this._xhr[url];
      }

      delete this._callbacks[url];
    }

    /**
     * Queues an image to be preloaded
     */

  }, {
    key: 'preload',
    value: function preload(url) {
      this.get(url, PRELOAD_CB);
    }

    /**
     * Aborts an image preload
     */

  }, {
    key: 'abortPreload',
    value: function abortPreload(url) {
      this.abort(url, PRELOAD_CB);
    }
  }]);

  return ImageCache;
}();

exports.default = new ImageCache();