{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/rvang/Desktop/Spectrum/testapp/node_modules/@babel/runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _IndexPath = require('./IndexPath');\n\nvar _IndexPath2 = _interopRequireDefault(_IndexPath);\n\nvar _IndexSet = require('./IndexSet');\n\nvar _IndexSet2 = _interopRequireDefault(_IndexSet);\n\nvar _Range = require('./Range');\n\nvar _Range2 = _interopRequireDefault(_Range);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * The IndexPathSet class stores a sorted set of {@link IndexPath} values.\n * It works like an {@link IndexSet}, but instead of storing integer\n * indexes, it stores {@link IndexPath} values instead.\n * Interally, it is stored as a multi-level {@link IndexSet}.\n */\n\n\nvar IndexPathSet = function () {\n  /**\n   * Creates a new IndexPathSet\n   */\n  function IndexPathSet() {\n    _classCallCheck(this, IndexPathSet);\n\n    this.sectionIndexes = new _IndexSet2.default();\n    this.sectionIndexSets = new Map();\n  }\n  /**\n   * Adds an IndexPath to the set\n   * @param {IndexPath} indexPath an IndexPath to add\n   */\n\n\n  _createClass(IndexPathSet, [{\n    key: 'addIndexPath',\n    value: function addIndexPath(indexPath) {\n      this.addRangeInSection(indexPath.section, new _Range2.default(indexPath.index, indexPath.index));\n    }\n    /**\n     * Removes an IndexPath from the set\n     * @param {IndexPath} indexPath an IndexPath to remove\n     */\n\n  }, {\n    key: 'removeIndexPath',\n    value: function removeIndexPath(indexPath) {\n      this.removeRangeInSection(indexPath.section, new _Range2.default(indexPath.index, indexPath.index));\n    }\n    /**\n     * Adds a range of indices in the given section to the set\n     * @param {number} section the section to add to\n     * @param {Range} range the range to add\n     */\n\n  }, {\n    key: 'addRangeInSection',\n    value: function addRangeInSection(section, range) {\n      if (!this.sectionIndexSets.has(section)) {\n        this.sectionIndexSets.set(section, new _IndexSet2.default());\n        this.sectionIndexes.addIndex(section);\n      }\n\n      this.sectionIndexSets.get(section).addRange(range);\n    }\n    /**\n     * Removes a range of indices in the given section from the set\n     * @param {number} section the section to remove from\n     * @param {Range} range the range to remove\n     */\n\n  }, {\n    key: 'removeRangeInSection',\n    value: function removeRangeInSection(section, range) {\n      var indexSet = this.sectionIndexSets.get(section);\n\n      if (indexSet) {\n        indexSet.removeRange(range);\n\n        if (indexSet.isEmpty) {\n          this.removeSection(section);\n        }\n      }\n    }\n    /**\n     * Removes all items in the given section\n     * @param {number} section - the section to remove\n     */\n\n  }, {\n    key: 'removeSection',\n    value: function removeSection(section) {\n      this.sectionIndexes.removeIndex(section);\n      this.sectionIndexSets.delete(section);\n    }\n    /**\n     * Returns whether the given IndexPath is in the set\n     * @param {IndexPath} indexPath the IndexPath to check\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'contains',\n    value: function contains(indexPath) {\n      var indexSet = this.sectionIndexSets.get(indexPath.section);\n\n      if (!indexSet) {\n        return false;\n      }\n\n      return indexSet.containsIndex(indexPath.index);\n    }\n    /**\n     * Toggles the given IndexPath\n     * @param {IndexPath} indexPath the IndexPath to toggle\n     */\n\n  }, {\n    key: 'toggleIndexPath',\n    value: function toggleIndexPath(indexPath) {\n      if (this.contains(indexPath)) {\n        this.removeIndexPath(indexPath);\n      } else {\n        this.addIndexPath(indexPath);\n      }\n    }\n    /**\n     * Removes all of the IndexPaths from the set\n     */\n\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.sectionIndexes.clear();\n      this.sectionIndexSets.clear();\n    }\n    /**\n     * Increments the IndexPaths above the range index in\n     * the given section by the range length\n     * @param {number} section the section to adjust\n     * @param {Range} range the range to adjust by\n     */\n\n  }, {\n    key: 'adjustForInsertionInSection',\n    value: function adjustForInsertionInSection(section, range) {\n      var indexSet = this.sectionIndexSets.get(section);\n\n      if (!indexSet) {\n        return;\n      }\n\n      indexSet.adjustForInsertedRange(range);\n    }\n    /**\n     * Decrements the IndexPaths above the range index in\n     * the given section by the range length\n     * @param {number} section the section to adjust\n     * @param {Range} range the range to adjust by\n     */\n\n  }, {\n    key: 'adjustForDeletionInSection',\n    value: function adjustForDeletionInSection(section, range) {\n      var indexSet = this.sectionIndexSets.get(section);\n\n      if (!indexSet) {\n        return;\n      }\n\n      indexSet.adjustForDeletedRange(range);\n\n      if (indexSet.isEmpty) {\n        this.sectionIndexSets.delete(section);\n        this.sectionIndexes.removeIndex(section);\n      }\n    }\n    /**\n     * Adjusts the IndexPaths in the set for a item move\n     * @param {IndexPath} from the source index path\n     * @param {IndexPath} to the destination index path\n     */\n\n  }, {\n    key: 'adjustForMove',\n    value: function adjustForMove(from, to) {\n      var contains = this.contains(from);\n      this.adjustForDeletionInSection(from.section, new _Range2.default(from.index, from.index));\n      this.adjustForInsertionInSection(to.section, new _Range2.default(to.index, to.index));\n\n      if (contains) {\n        this.addIndexPath(to);\n      }\n    }\n  }, {\n    key: '_adjustSectionIndexSets',\n    value: function _adjustSectionIndexSets(section, dir) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = Array.from(this.sectionIndexSets)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _slicedToArray(_step.value, 2),\n              sectionIndex = _step$value[0],\n              indexSet = _step$value[1];\n\n          if (sectionIndex >= section) {\n            this.sectionIndexSets.delete(sectionIndex);\n            this.sectionIndexSets.set(sectionIndex + dir, indexSet);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\n     * Adjusts the IndexPaths in the set for an insertion of a new section\n     * @param {number} section the index of the inserted section\n     */\n\n  }, {\n    key: 'adjustForInsertedSection',\n    value: function adjustForInsertedSection(section) {\n      this.sectionIndexes.adjustForInsertedRange(new _Range2.default(section, section));\n\n      this._adjustSectionIndexSets(section, +1);\n    }\n    /**\n     * Adjusts the IndexPaths in the set for an deletion of a section\n     * @param {number} section the index of the deleted section\n     */\n\n  }, {\n    key: 'adjustForDeletedSection',\n    value: function adjustForDeletedSection(section) {\n      this.sectionIndexes.adjustForDeletedRange(new _Range2.default(section, section));\n      this.sectionIndexSets.delete(section);\n\n      this._adjustSectionIndexSets(section, -1);\n    }\n    /**\n     * Adjusts the IndexPaths in the set for a section move\n     * @param {number} fromSection the index of the source section\n     * @param {number} toSection the index of the destination section\n     */\n\n  }, {\n    key: 'adjustForMovedSection',\n    value: function adjustForMovedSection(fromSection, toSection) {\n      this.sectionIndexes.adjustForMove(fromSection, toSection);\n      var indexSet = this.sectionIndexSets.get(fromSection);\n\n      this._adjustSectionIndexSets(fromSection, -1);\n\n      this._adjustSectionIndexSets(toSection, +1);\n\n      if (indexSet) {\n        this.sectionIndexSets.set(toSection, indexSet);\n      }\n    }\n    /**\n     * The first IndexPath in the set, or null if the set is empty\n     * @type {IndexPath}\n     */\n\n  }, {\n    key: Symbol.iterator,\n\n    /**\n     * Returns an iterator over all of the IndexPaths in the set\n     * @return {Generator}\n     */\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function value() {\n      var _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, section, indexSet, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, index;\n\n      return _regeneratorRuntime.wrap(function value$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iteratorNormalCompletion2 = true;\n              _didIteratorError2 = false;\n              _iteratorError2 = undefined;\n              _context.prev = 3;\n              _iterator2 = this.sectionIndexes[Symbol.iterator]();\n\n            case 5:\n              if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {\n                _context.next = 37;\n                break;\n              }\n\n              section = _step2.value;\n              indexSet = this.sectionIndexSets.get(section);\n              _iteratorNormalCompletion3 = true;\n              _didIteratorError3 = false;\n              _iteratorError3 = undefined;\n              _context.prev = 11;\n              _iterator3 = indexSet[Symbol.iterator]();\n\n            case 13:\n              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n                _context.next = 20;\n                break;\n              }\n\n              index = _step3.value;\n              _context.next = 17;\n              return new _IndexPath2.default(section, index);\n\n            case 17:\n              _iteratorNormalCompletion3 = true;\n              _context.next = 13;\n              break;\n\n            case 20:\n              _context.next = 26;\n              break;\n\n            case 22:\n              _context.prev = 22;\n              _context.t0 = _context['catch'](11);\n              _didIteratorError3 = true;\n              _iteratorError3 = _context.t0;\n\n            case 26:\n              _context.prev = 26;\n              _context.prev = 27;\n\n              if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n              }\n\n            case 29:\n              _context.prev = 29;\n\n              if (!_didIteratorError3) {\n                _context.next = 32;\n                break;\n              }\n\n              throw _iteratorError3;\n\n            case 32:\n              return _context.finish(29);\n\n            case 33:\n              return _context.finish(26);\n\n            case 34:\n              _iteratorNormalCompletion2 = true;\n              _context.next = 5;\n              break;\n\n            case 37:\n              _context.next = 43;\n              break;\n\n            case 39:\n              _context.prev = 39;\n              _context.t1 = _context['catch'](3);\n              _didIteratorError2 = true;\n              _iteratorError2 = _context.t1;\n\n            case 43:\n              _context.prev = 43;\n              _context.prev = 44;\n\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n\n            case 46:\n              _context.prev = 46;\n\n              if (!_didIteratorError2) {\n                _context.next = 49;\n                break;\n              }\n\n              throw _iteratorError2;\n\n            case 49:\n              return _context.finish(46);\n\n            case 50:\n              return _context.finish(43);\n\n            case 51:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, value, this, [[3, 39, 43, 51], [11, 22, 26, 34], [27,, 29, 33], [44,, 46, 50]]);\n    })\n    /**\n     * Returns a iterator that emits all IndexPaths in the set in reverse\n     * @type {Iterator}\n     */\n\n  }, {\n    key: 'equals',\n\n    /**\n     * Returns whether this set is equal to another one\n     * @param {IndexPathSet} other an IndexPathSet to compare\n     * @return {boolean}\n     */\n    value: function equals(other) {\n      if (!other || !(other instanceof IndexPathSet)) {\n        return false;\n      }\n\n      if (other === this) {\n        return true;\n      }\n\n      if (!other.sectionIndexes.equals(this.sectionIndexes)) {\n        return false;\n      }\n\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this.sectionIndexes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var section = _step4.value;\n\n          if (!this.sectionIndexSets.get(section).equals(other.sectionIndexSets.get(section))) {\n            return false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Returns a copy of this IndexPathSet\n     * @return {IndexPathSet}\n     */\n\n  }, {\n    key: 'copy',\n    value: function copy() {\n      var res = new this.constructor();\n      res.sectionIndexes.addIndexSet(this.sectionIndexes);\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = this.sectionIndexSets[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _step5$value = _slicedToArray(_step5.value, 2),\n              section = _step5$value[0],\n              indexSet = _step5$value[1];\n\n          res.sectionIndexSets.set(section, indexSet.copy());\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: 'firstIndexPath',\n    get: function get() {\n      var firstSection = this.sectionIndexes.firstIndex;\n\n      if (firstSection === -1) {\n        return null;\n      }\n\n      return new _IndexPath2.default(firstSection, this.sectionIndexSets.get(firstSection).firstIndex);\n    }\n    /**\n     * The last IndexPath in the set, or null if the set is empty\n     * @type {IndexPath}\n     */\n\n  }, {\n    key: 'lastIndexPath',\n    get: function get() {\n      var lastSection = this.sectionIndexes.lastIndex;\n\n      if (lastSection === -1) {\n        return null;\n      }\n\n      return new _IndexPath2.default(lastSection, this.sectionIndexSets.get(lastSection).lastIndex);\n    }\n    /**\n     * The number of IndexPaths in the set\n     * @type {number}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n      var length = 0;\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this.sectionIndexSets.values()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var indexSet = _step6.value;\n          length += indexSet.length;\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      return length;\n    }\n    /**\n     * Whether the set is empty\n     * @type {boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get() {\n      return this.sectionIndexes.isEmpty;\n    }\n  }, {\n    key: 'reverseIterator',\n    get: function get() {\n      var self = this;\n      return _defineProperty({}, Symbol.iterator,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var _iteratorNormalCompletion7, _didIteratorError7, _iteratorError7, _iterator7, _step7, section, indexSet, _iteratorNormalCompletion8, _didIteratorError8, _iteratorError8, _iterator8, _step8, index;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _iteratorNormalCompletion7 = true;\n                _didIteratorError7 = false;\n                _iteratorError7 = undefined;\n                _context2.prev = 3;\n                _iterator7 = self.sectionIndexes.reverseIterator[Symbol.iterator]();\n\n              case 5:\n                if (_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done) {\n                  _context2.next = 37;\n                  break;\n                }\n\n                section = _step7.value;\n                indexSet = self.sectionIndexSets.get(section);\n                _iteratorNormalCompletion8 = true;\n                _didIteratorError8 = false;\n                _iteratorError8 = undefined;\n                _context2.prev = 11;\n                _iterator8 = indexSet.reverseIterator[Symbol.iterator]();\n\n              case 13:\n                if (_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done) {\n                  _context2.next = 20;\n                  break;\n                }\n\n                index = _step8.value;\n                _context2.next = 17;\n                return new _IndexPath2.default(section, index);\n\n              case 17:\n                _iteratorNormalCompletion8 = true;\n                _context2.next = 13;\n                break;\n\n              case 20:\n                _context2.next = 26;\n                break;\n\n              case 22:\n                _context2.prev = 22;\n                _context2.t0 = _context2['catch'](11);\n                _didIteratorError8 = true;\n                _iteratorError8 = _context2.t0;\n\n              case 26:\n                _context2.prev = 26;\n                _context2.prev = 27;\n\n                if (!_iteratorNormalCompletion8 && _iterator8.return) {\n                  _iterator8.return();\n                }\n\n              case 29:\n                _context2.prev = 29;\n\n                if (!_didIteratorError8) {\n                  _context2.next = 32;\n                  break;\n                }\n\n                throw _iteratorError8;\n\n              case 32:\n                return _context2.finish(29);\n\n              case 33:\n                return _context2.finish(26);\n\n              case 34:\n                _iteratorNormalCompletion7 = true;\n                _context2.next = 5;\n                break;\n\n              case 37:\n                _context2.next = 43;\n                break;\n\n              case 39:\n                _context2.prev = 39;\n                _context2.t1 = _context2['catch'](3);\n                _didIteratorError7 = true;\n                _iteratorError7 = _context2.t1;\n\n              case 43:\n                _context2.prev = 43;\n                _context2.prev = 44;\n\n                if (!_iteratorNormalCompletion7 && _iterator7.return) {\n                  _iterator7.return();\n                }\n\n              case 46:\n                _context2.prev = 46;\n\n                if (!_didIteratorError7) {\n                  _context2.next = 49;\n                  break;\n                }\n\n                throw _iteratorError7;\n\n              case 49:\n                return _context2.finish(46);\n\n              case 50:\n                return _context2.finish(43);\n\n              case 51:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee, this, [[3, 39, 43, 51], [11, 22, 26, 34], [27,, 29, 33], [44,, 46, 50]]);\n      }));\n    }\n  }]);\n\n  return IndexPathSet;\n}();\n\nexports.default = IndexPathSet;","map":null,"metadata":{},"sourceType":"script"}