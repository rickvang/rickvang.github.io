{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar _DOMBackend = require('./dom/DOMBackend');\n\nvar _DOMBackend2 = _interopRequireDefault(_DOMBackend);\n\nvar _Point = require('./Point');\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _raf = require('raf');\n\nvar _raf2 = _interopRequireDefault(_raf);\n\nvar _Scroller = require('./Scroller');\n\nvar _Scroller2 = _interopRequireDefault(_Scroller);\n\nvar _Size = require('./Size');\n\nvar _Size2 = _interopRequireDefault(_Size);\n\nvar _View2 = require('./View');\n\nvar _View3 = _interopRequireDefault(_View2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar MIN_DRAG_DELTA = 5;\nvar DECELERATION_FRICTION = 0.95;\nvar RUBBER_BAND_FRICTION = 0.55;\nvar ELASTIC_DECELERATION = 0.03;\nvar ELASTIC_ACCELERATION = 0.08;\nvar HIDE_INDICATORS = 0.1;\nvar MIN_VELOCITY = 0.01;\n\nvar ScrollView = function (_View) {\n  _inherits(ScrollView, _View);\n\n  function ScrollView() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ScrollView);\n\n    var _this = _possibleConstructorReturn(this, (ScrollView.__proto__ || Object.getPrototypeOf(ScrollView)).call(this));\n\n    _this.backend = options.backend || _DOMBackend2.default;\n\n    var _ref = options.rubberBandEffect ? options.rubberBandEffect : {\n      horizontal: false,\n      vertical: true\n    },\n        horizontal = _ref.horizontal,\n        vertical = _ref.vertical;\n\n    _this.horizontalRubberBand = horizontal;\n    _this.verticalRubberBand = vertical;\n    _this._size = new _Size2.default(0, 0);\n    _this._contentSize = new _Size2.default(0, 0);\n    _this._contentOffset = new _Point2.default(0, 0);\n    _this._lineOffset = 10;\n    _this._scrolling = false;\n    _this._scrollTimeout = null;\n    _this._scrollEndTime = 0; // Add an attribute so other things can detect that our fake scrollview is actually scrollable.\n\n    _this.setAttribute('data-scrollable', 'true');\n\n    _this.css({\n      position: 'relative',\n      overflow: 'hidden'\n    });\n\n    _this.bindScrollEvents();\n\n    _this.inner = new _View3.default();\n\n    _this.inner.css({\n      position: 'absolute',\n      transform: 'translate3d(0, 0, 0)'\n    }); // set id so that DOM element can be referenced for accessibility purposes\n\n\n    if (options['id']) {\n      _this.setAttribute('id', options['id']);\n    } // either use role set as prop or set WAI-ARIA role=\"presentation\" so that the viewport region has no role.\n\n\n    _this.setAttribute('role', options.role || 'presentation'); // accessibility attributes for labelling and/or describing element\n\n\n    if (options['aria-label']) {\n      _this.setAttribute('aria-label', options['aria-label']);\n    }\n\n    if (options['aria-labelledby']) {\n      _this.setAttribute('aria-labelledby', options['aria-labelledby']);\n    }\n\n    if (options['aria-describedby']) {\n      _this.setAttribute('aria-describedby', options['aria-describedby']);\n    } // set WAI-ARIA role=\"presentation\" so that the scrolling content region has no role.\n\n\n    _this.inner.setAttribute('role', 'presentation');\n\n    _this.addChild(_this.inner);\n\n    _this._decelerationAnimation = _this._decelerationAnimation.bind(_this);\n    _this.verticalScroller = new _Scroller2.default(_this);\n\n    _this.addChild(_this.verticalScroller);\n\n    _this.horizontalScroller = new _Scroller2.default(_this, 'horizontal');\n\n    _this.addChild(_this.horizontalScroller);\n\n    return _this;\n  }\n\n  _createClass(ScrollView, [{\n    key: 'bindScrollEvents',\n    value: function bindScrollEvents() {\n      this.onEvent('wheel', this.scroll.bind(this));\n      this.onEvent('touchStart', this.touchStart.bind(this));\n      this.onEvent('touchMove', this.touchMove.bind(this));\n      this.onEvent('touchEnd', this.touchEnd.bind(this));\n      this.onEvent('touchCancel', this.touchEnd.bind(this));\n      this.onEvent('scroll', this._onScroll.bind(this));\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      return _get(ScrollView.prototype.__proto__ || Object.getPrototypeOf(ScrollView.prototype), 'renderBackendView', this).call(this, this.backend);\n    }\n    /**\n     * Get the outer size of the scroll view\n     * @type {Size}\n     */\n\n  }, {\n    key: 'setSize',\n    value: function setSize(size) {\n      this._size = size;\n      this.inner.css({\n        width: size.width + 'px'\n      });\n      this.verticalScroller.updateScrollViewSize();\n      this.horizontalScroller.updateScrollViewSize();\n    }\n  }, {\n    key: 'setContentSize',\n    value: function setContentSize(size) {\n      var oldSize = this._contentSize;\n      this._contentSize = size;\n      this.inner.css({\n        width: size.width + 'px',\n        height: size.height + 'px'\n      });\n      this.verticalScroller.updateScrollViewSize();\n      this.horizontalScroller.updateScrollViewSize();\n\n      if (oldSize.height < this.size.height && oldSize.height > this.size.height) {\n        this.verticalScroller.flash();\n      }\n\n      if (oldSize.width < this.size.width && oldSize.width > this.size.width) {\n        this.horizontalScroller.flash();\n      }\n    }\n    /**\n     * Get the height of the scrollable content\n     * @type {number}\n     */\n\n  }, {\n    key: '_onScroll',\n\n    /**\n     * Prevent ScrollView itself from scrolling in response to focus events or screen reader\n     * @type {ScrollEvent} The scroll event\n     * @private\n     */\n    value: function _onScroll(e) {\n      e.preventDefault();\n      var node = this.getDOMNode();\n\n      if (node && node.scrollTop !== 0) {\n        node.scrollTop = 0;\n      }\n    }\n  }, {\n    key: 'scroll',\n    value: function scroll(e) {\n      var _this2 = this;\n\n      var deltaX = e.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? e.deltaX : e.deltaX * this._lineOffset; // TODO - lineOffset?\n\n      var deltaY = e.deltaMode === WheelEvent.DOM_DELTA_PIXEL ? e.deltaY : e.deltaY * this._lineOffset;\n\n      if (!this._scrolling) {\n        this.scrollStarted(deltaX, deltaY);\n      }\n\n      if (this.setContentOffset(new _Point2.default(this._contentOffset.x + deltaX, this._contentOffset.y + deltaY))) {\n        e.stopPropagation();\n        e.preventDefault();\n      } // So we don't constantly call clearTimeout and setTimeout,\n      // keep track of the current timeout time and only reschedule\n      // the timer when it is getting close.\n\n\n      var now = Date.now();\n\n      if (this._scrollEndTime <= now + 50) {\n        this._scrollEndTime = now + 300;\n        clearTimeout(this._scrollTimeout);\n        this._scrollTimeout = setTimeout(function () {\n          _this2.scrollEnded();\n        }, 300);\n      }\n    }\n  }, {\n    key: 'scrollStarted',\n    value: function scrollStarted(deltaX, deltaY) {\n      this._scrolling = true;\n      this.inner.css({\n        pointerEvents: 'none'\n      });\n\n      if (deltaX !== 0) {\n        this.horizontalScroller.scrollStarted();\n      }\n\n      if (deltaY !== 0) {\n        this.verticalScroller.scrollStarted();\n      }\n    }\n  }, {\n    key: 'scrollEnded',\n    value: function scrollEnded() {\n      this._scrolling = false;\n      this.inner.css({\n        pointerEvents: 'auto'\n      });\n      this.verticalScroller.scrollEnded();\n      this.horizontalScroller.scrollEnded();\n    }\n  }, {\n    key: '_rubberBand',\n    value: function _rubberBand(offset, d) {\n      var x = Math.abs(offset);\n      var res = RUBBER_BAND_FRICTION * x * d / (d + RUBBER_BAND_FRICTION * x);\n      return offset < 0 ? -res : res;\n    }\n    /**\n     * Updates offset of the inner scrollable view\n     * @param {Point} offset\n     * @returns {boolean} - true if offset changed, false otherwise\n     */\n\n  }, {\n    key: 'setContentOffset',\n    value: function setContentOffset(offset) {\n      // If decelerating, allow any offset, otherwise constrain it\n      var constrainedX = this._decelerating ? offset.x : Math.max(0, Math.min(this._contentSize.width - this.size.width, offset.x));\n      var constrainedY = this._decelerating ? offset.y : Math.max(0, Math.min(this._contentSize.height - this.size.height, offset.y)); // If dragging, allow rubber banding\n\n      if (this._dragging) {\n        if (this.horizontalRubberBand) {\n          constrainedX += this._rubberBand(offset.x - constrainedX, this.size.width);\n        }\n\n        if (this.verticalRubberBand) {\n          constrainedY += this._rubberBand(offset.y - constrainedY, this.size.height);\n        }\n      }\n\n      var newContentOffset = new _Point2.default(constrainedX, constrainedY);\n\n      if (this._contentOffset.equals(newContentOffset)) {\n        return false;\n      }\n\n      this._contentOffset = newContentOffset;\n      var transform = 'translate3d(' + -this._contentOffset.x + 'px, ' + -this._contentOffset.y + 'px, 0)';\n      this.inner.css({\n        WebkitTransform: transform,\n        transform: transform\n      });\n      var value = this._contentOffset.y / (this._contentSize.height - this.size.height);\n      this.verticalScroller.setValue(value);\n      value = this._contentOffset.x / (this._contentSize.width - this.size.width);\n      this.horizontalScroller.setValue(value);\n      this.emit('scroll', this._contentOffset); // Emit a fake scroll event on the actual DOM node so other things can pick it up.\n\n      this.triggerEvent('scroll');\n      return true;\n    }\n    /**\n     * Get the scroll content offset\n     * @type {number}\n     */\n\n  }, {\n    key: '_getEventX',\n    value: function _getEventX(e) {\n      // touch event\n      if (e.targetTouches && e.targetTouches.length >= 1) {\n        return e.targetTouches[0].clientX;\n      } // mouse event\n\n\n      return e.clientX;\n    }\n  }, {\n    key: '_getEventY',\n    value: function _getEventY(e) {\n      // touch event\n      if (e.targetTouches && e.targetTouches.length >= 1) {\n        return e.targetTouches[0].clientY;\n      } // mouse event\n\n\n      return e.clientY;\n    }\n  }, {\n    key: 'touchStart',\n    value: function touchStart(event) {\n      if (this._tracking) {\n        return;\n      }\n\n      event.preventDefault(); // Cancel the current deceleration animation\n\n      if (this._decelerating) {\n        this._decelerating = false;\n\n        _raf2.default.cancel(this._decelerationTimer);\n      }\n\n      this._tracking = true;\n      this._dragging = false;\n      this._maxPoint = this.size.height - this._contentSize.height;\n      this._startPosition = this._contentOffset;\n      this._startTouchPosition = new _Point2.default(this._getEventX(event), this._getEventY(event));\n      this._velocityX = 0;\n      this._velocityY = 0;\n    }\n  }, {\n    key: 'touchMove',\n    value: function touchMove(event) {\n      if (!this._tracking) {\n        return;\n      }\n\n      var x = this._getEventX(event);\n\n      var y = this._getEventY(event);\n\n      var deltaX = this._startTouchPosition.x - x;\n      var deltaY = this._startTouchPosition.y - y;\n\n      if (!this._dragging) {\n        if (Math.abs(deltaX) >= MIN_DRAG_DELTA || Math.abs(deltaY) >= MIN_DRAG_DELTA) {\n          this._dragging = true;\n          this._startTouchPosition = new _Point2.default(x, y);\n          this.verticalScroller.scrollStarted();\n          this.horizontalScroller.scrollStarted();\n        }\n      }\n\n      if (this._dragging) {\n        event.stopPropagation();\n        var lastContentOffset = this._contentOffset;\n        this.setContentOffset(new _Point2.default(this._startPosition.x + deltaX, this._startPosition.y + deltaY));\n        var v = this._contentOffset.x - lastContentOffset.x;\n        this._velocityX = 0.8 * v + 0.2 * this._velocityX;\n        v = this._contentOffset.y - lastContentOffset.y;\n        this._velocityY = 0.8 * v + 0.2 * this._velocityY;\n      }\n    }\n  }, {\n    key: 'touchEnd',\n    value: function touchEnd(event) {\n      this._tracking = false;\n\n      if (this._dragging) {\n        this._dragging = false;\n        event.stopPropagation();\n\n        this._decelerate(event);\n\n        if (!this._decelerating) {\n          this.verticalScroller.scrollEnded();\n          this.horizontalScroller.scrollEnded();\n        }\n      }\n    }\n  }, {\n    key: '_decelerate',\n    value: function _decelerate(event) {\n      var isRubberBanding = this._contentOffset.x < 0 || this._contentOffset.x > this._contentSize.width - this.size.width || this._contentOffset.y < 0 || this._contentOffset.y > this._contentSize.height - this.size.height;\n\n      if (Math.abs(this._velocityX) > 1 || Math.abs(this._velocityY) > 1 || isRubberBanding) {\n        this._decelerating = true;\n        this._decelerationTimer = (0, _raf2.default)(this._decelerationAnimation);\n      }\n    }\n  }, {\n    key: '_decelerationAnimation',\n    value: function _decelerationAnimation(t) {\n      if (!this._decelerating) {\n        return;\n      } // Decelerate\n\n\n      this._velocityX *= DECELERATION_FRICTION;\n      this._velocityY *= DECELERATION_FRICTION; // Bounce back if we hit the edge\n\n      var rubberBandX = 0;\n      var rubberBandY = 0;\n\n      if (this._contentOffset.x < 0) {\n        rubberBandX = -this._contentOffset.x;\n      } else if (this._contentOffset.x > this._contentSize.width - this.size.width) {\n        rubberBandX = this._contentSize.width - this.size.width - this._contentOffset.x;\n      }\n\n      if (this._contentOffset.y < 0) {\n        rubberBandY = -this._contentOffset.y;\n      } else if (this._contentOffset.y > this._contentSize.height - this.size.height) {\n        rubberBandY = this._contentSize.height - this.size.height - this._contentOffset.y;\n      }\n\n      if (rubberBandX !== 0) {\n        if (rubberBandX * this._velocityX <= 0) {\n          this._velocityX += rubberBandX * ELASTIC_DECELERATION;\n        } else {\n          this._velocityX = rubberBandX * ELASTIC_ACCELERATION;\n        }\n      }\n\n      if (rubberBandY !== 0) {\n        if (rubberBandY * this._velocityY <= 0) {\n          this._velocityY += rubberBandY * ELASTIC_DECELERATION;\n        } else {\n          this._velocityY = rubberBandY * ELASTIC_ACCELERATION;\n        }\n      }\n\n      this.setContentOffset(new _Point2.default(this._contentOffset.x + this._velocityX, this._contentOffset.y + this._velocityY));\n      var vX = Math.abs(this._velocityX);\n      var vY = Math.abs(this._velocityY);\n\n      if (vX < HIDE_INDICATORS) {\n        this.horizontalScroller.scrollEnded();\n      }\n\n      if (vY < HIDE_INDICATORS) {\n        this.verticalScroller.scrollEnded();\n      }\n\n      if (vX < MIN_VELOCITY && vY < MIN_VELOCITY) {\n        this._decelerating = false;\n      }\n\n      if (this._decelerating) {\n        this._decelerationTimer = (0, _raf2.default)(this._decelerationAnimation);\n      }\n    }\n  }, {\n    key: 'size',\n    get: function get() {\n      return this._size;\n    }\n    /**\n     * Set the outer size of the scroll view\n     * @type {Size}\n     */\n    ,\n    set: function set(size) {\n      this.setSize(size);\n    }\n  }, {\n    key: 'contentSize',\n    get: function get() {\n      return this._contentSize;\n    }\n    /**\n     * Set the height of the scrollable content\n     * @type {number}\n     */\n    ,\n    set: function set(contentSize) {\n      this.setContentSize(contentSize);\n    }\n  }, {\n    key: 'contentOffset',\n    get: function get() {\n      return this._contentOffset;\n    }\n    /**\n     * Set the scroll content offset\n     * @type {number}\n     */\n    ,\n    set: function set(offset) {\n      this.setContentOffset(offset);\n    }\n  }]);\n\n  return ScrollView;\n}(_View3.default);\n\nexports.default = ScrollView;","map":null,"metadata":{},"sourceType":"script"}