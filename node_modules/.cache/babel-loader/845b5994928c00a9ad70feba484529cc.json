{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexports.calculatePositionInternal = calculatePositionInternal;\nexports.default = calculatePosition;\n\nvar _style = require('dom-helpers/style');\n\nvar _style2 = _interopRequireDefault(_style);\n\nvar _offset = require('dom-helpers/query/offset');\n\nvar _offset2 = _interopRequireDefault(_offset);\n\nvar _position = require('dom-helpers/query/position');\n\nvar _position2 = _interopRequireDefault(_position);\n\nvar _scrollLeft = require('dom-helpers/query/scrollLeft');\n\nvar _scrollLeft2 = _interopRequireDefault(_scrollLeft);\n\nvar _scrollTop = require('dom-helpers/query/scrollTop');\n\nvar _scrollTop2 = _interopRequireDefault(_scrollTop);\n\nvar _ownerDocument = require('dom-helpers/ownerDocument');\n\nvar _ownerDocument2 = _interopRequireDefault(_ownerDocument);\n\nvar _reactDom = require('react-dom');\n\nvar _reactDom2 = _interopRequireDefault(_reactDom);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar AXIS = {\n  top: 'top',\n  bottom: 'top',\n  left: 'left',\n  right: 'left'\n};\nvar FLIPPED_DIRECTION = {\n  top: 'bottom',\n  bottom: 'top',\n  left: 'right',\n  right: 'left'\n};\nvar CROSS_AXIS = {\n  top: 'left',\n  left: 'top'\n};\nvar AXIS_SIZE = {\n  top: 'height',\n  left: 'width'\n};\nvar PARSED_PLACEMENT_CACHE = {};\n\nfunction getContainerDimensions(containerNode) {\n  var width = void 0,\n      height = void 0,\n      top = 0,\n      left = 0;\n  var scroll = {};\n\n  var containerDOMNode = _reactDom2.default.findDOMNode(containerNode);\n\n  if (containerDOMNode.tagName === 'BODY') {\n    width = window.innerWidth;\n    height = window.innerHeight;\n    scroll.top = (0, _scrollTop2.default)((0, _ownerDocument2.default)(containerDOMNode).documentElement) || (0, _scrollTop2.default)(containerDOMNode);\n    scroll.left = (0, _scrollLeft2.default)((0, _ownerDocument2.default)(containerDOMNode).documentElement) || (0, _scrollLeft2.default)(containerDOMNode);\n  } else {\n    var _getOffset = (0, _offset2.default)(containerDOMNode);\n\n    width = _getOffset.width;\n    height = _getOffset.height;\n    top = _getOffset.top;\n    left = _getOffset.left;\n    scroll.top = (0, _scrollTop2.default)(containerDOMNode);\n    scroll.left = (0, _scrollLeft2.default)(containerDOMNode);\n  }\n\n  return {\n    width: width,\n    height: height,\n    scroll: scroll,\n    top: top,\n    left: left\n  };\n}\n\nfunction getDelta(axis, offset, size, containerDimensions, padding) {\n  var containerScroll = containerDimensions.scroll[axis];\n  var containerHeight = containerDimensions[AXIS_SIZE[axis]];\n  var startEdgeOffset = offset - padding - containerScroll;\n  var endEdgeOffset = offset + padding - containerScroll + size;\n\n  if (startEdgeOffset < 0) {\n    return -startEdgeOffset;\n  } else if (endEdgeOffset > containerHeight) {\n    return Math.max(containerHeight - endEdgeOffset, -startEdgeOffset);\n  } else {\n    return 0;\n  }\n}\n\nfunction shouldFlip(axis, offset, size, padding, placement, flipContainerDimensions, containerOffsetWithBoundary) {\n  var containerScroll = flipContainerDimensions.scroll[axis];\n  var containerHeight = flipContainerDimensions[AXIS_SIZE[axis]];\n  var startEdgeOffset = containerOffsetWithBoundary[axis] + offset - padding - containerScroll;\n  var endEdgeOffset = containerOffsetWithBoundary[axis] + offset + padding - containerScroll + size;\n\n  if (startEdgeOffset < 0 && (placement === 'top' || placement === 'left')) {\n    return true;\n  } else if (endEdgeOffset > containerHeight && (placement === 'bottom' || placement === 'right')) {\n    return true;\n  } else {\n    return false;\n  }\n}\n\nfunction getMargins(node) {\n  var style = window.getComputedStyle(node);\n  return {\n    top: parseInt(style.marginTop, 10) || 0,\n    bottom: parseInt(style.marginBottom, 10) || 0,\n    left: parseInt(style.marginLeft, 10) || 0,\n    right: parseInt(style.marginRight, 10) || 0\n  };\n}\n\nfunction parsePlacement(input) {\n  if (PARSED_PLACEMENT_CACHE[input]) {\n    return PARSED_PLACEMENT_CACHE[input];\n  }\n\n  var _input$split = input.split(' '),\n      _input$split2 = _slicedToArray(_input$split, 2),\n      placement = _input$split2[0],\n      crossPlacement = _input$split2[1];\n\n  var axis = AXIS[placement] || 'right';\n  var crossAxis = CROSS_AXIS[axis];\n\n  if (!AXIS[crossPlacement]) {\n    crossPlacement = 'center';\n  }\n\n  var size = AXIS_SIZE[axis];\n  var crossSize = AXIS_SIZE[crossAxis];\n  PARSED_PLACEMENT_CACHE[input] = {\n    placement: placement,\n    crossPlacement: crossPlacement,\n    axis: axis,\n    crossAxis: crossAxis,\n    size: size,\n    crossSize: crossSize\n  };\n  return PARSED_PLACEMENT_CACHE[input];\n}\n\nfunction computePosition(childOffset, containerDimensions, overlaySize, placementInfo, offset, crossOffset) {\n  var placement = placementInfo.placement,\n      crossPlacement = placementInfo.crossPlacement,\n      axis = placementInfo.axis,\n      crossAxis = placementInfo.crossAxis,\n      size = placementInfo.size,\n      crossSize = placementInfo.crossSize;\n  var position = {};\n  position[crossAxis] = childOffset[crossAxis] + crossOffset;\n\n  if (crossPlacement === 'center') {\n    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;\n  } else if (crossPlacement !== crossAxis) {\n    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];\n  } // Ensure overlay sticks to target(ignore for overlays smaller than target)\n\n\n  if (childOffset[crossSize] < overlaySize[crossSize]) {\n    var positionForPositiveSideOverflow = Math.min(position[crossAxis], childOffset[crossAxis]);\n    position[crossAxis] = Math.max(positionForPositiveSideOverflow, childOffset[crossAxis] - overlaySize[crossSize] + childOffset[crossSize]);\n  }\n\n  if (placement === axis) {\n    position[axis] = childOffset[axis] - overlaySize[size] + offset;\n  } else {\n    position[axis] = childOffset[axis] + childOffset[size] + offset;\n  }\n\n  return position;\n}\n\nfunction calculatePositionInternal(placementInput, containerDimensions, childOffset, overlaySize, margins, padding, flip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset) {\n  var placementInfo = parsePlacement(placementInput);\n  var _placementInfo = placementInfo,\n      axis = _placementInfo.axis,\n      size = _placementInfo.size,\n      crossAxis = _placementInfo.crossAxis,\n      crossSize = _placementInfo.crossSize,\n      placement = _placementInfo.placement,\n      crossPlacement = _placementInfo.crossPlacement;\n  var position = computePosition(childOffset, containerDimensions, overlaySize, placementInfo, offset, crossOffset);\n  var normalizedOffset = offset; // First check if placement should be flipped\n\n  if (flip && shouldFlip(axis, position[axis], overlaySize[size], padding, placement, boundaryDimensions, containerOffsetWithBoundary)) {\n    var flippedPlacementInfo = parsePlacement(FLIPPED_DIRECTION[placement] + ' ' + crossPlacement);\n    var _axis = flippedPlacementInfo.axis,\n        _size = flippedPlacementInfo.size;\n    var flippedPosition = computePosition(childOffset, containerDimensions, overlaySize, flippedPlacementInfo, -1 * offset, crossOffset); // Check if flipped placement has enough space otherwise flip is not possible\n\n    if (!shouldFlip(_axis, flippedPosition[_axis], overlaySize[_size], padding, FLIPPED_DIRECTION[placement], boundaryDimensions, containerOffsetWithBoundary)) {\n      placementInfo = flippedPlacementInfo;\n      position = flippedPosition;\n      normalizedOffset = -1 * offset;\n    }\n  }\n\n  var delta = getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);\n  position[crossAxis] += delta;\n  var maxHeight = Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top - containerOffsetWithBoundary.top - position.top - margins.top - margins.bottom - padding);\n  overlaySize.height = Math.min(overlaySize.height, maxHeight);\n  position = computePosition(childOffset, containerDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset);\n  delta = delta = getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);\n  position[crossAxis] += delta;\n  var arrowPosition = {};\n  arrowPosition[crossAxis] = childOffset[crossSize] > overlaySize[crossSize] ? null : childOffset[crossAxis] - position[crossAxis] + childOffset[crossSize] / 2;\n  return {\n    positionLeft: position.left,\n    positionTop: position.top,\n    maxHeight: maxHeight,\n    arrowOffsetLeft: arrowPosition.left,\n    arrowOffsetTop: arrowPosition.top,\n    placement: placementInfo.placement\n  };\n}\n\nfunction calculatePosition(placementInput, overlayNode, target, container, padding, flip, boundariesElement, offset, crossOffset) {\n  var isBodyContainer = container.tagName === 'BODY';\n  var childOffset = isBodyContainer ? (0, _offset2.default)(target) : (0, _position2.default)(target, container);\n\n  if (!isBodyContainer) {\n    childOffset.top += parseInt((0, _style2.default)(target, 'marginTop'), 10) || 0;\n    childOffset.left += parseInt((0, _style2.default)(target, 'marginLeft'), 10) || 0;\n  }\n\n  var overlaySize = (0, _offset2.default)(overlayNode);\n  var margins = getMargins(overlayNode);\n  overlaySize.width += margins.left + margins.right;\n  overlaySize.height += margins.top + margins.bottom;\n  var containerDimensions = getContainerDimensions(container);\n  var boundaryContainer = boundariesElement === 'container' ? container : boundariesElement();\n  var boundaryDimensions = getContainerDimensions(boundaryContainer);\n  var containerOffsetWithBoundary = boundaryContainer.tagName === 'BODY' ? (0, _offset2.default)(container) : (0, _position2.default)(container, boundaryContainer);\n  return calculatePositionInternal(placementInput, containerDimensions, childOffset, overlaySize, margins, padding, flip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset);\n}","map":null,"metadata":{},"sourceType":"script"}