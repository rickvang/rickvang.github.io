{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar _DragTarget = require('./DragTarget');\n\nvar _DragTarget2 = _interopRequireDefault(_DragTarget);\n\nvar _IndexPath = require('./IndexPath');\n\nvar _IndexPath2 = _interopRequireDefault(_IndexPath);\n\nvar _Layout2 = require('./Layout');\n\nvar _Layout3 = _interopRequireDefault(_Layout2);\n\nvar _LayoutInfo = require('./LayoutInfo');\n\nvar _LayoutInfo2 = _interopRequireDefault(_LayoutInfo);\n\nvar _Rect = require('./Rect');\n\nvar _Rect2 = _interopRequireDefault(_Rect);\n\nvar _Size = require('./Size');\n\nvar _Size2 = _interopRequireDefault(_Size);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * This layout displays equal-sized items in a grid.\n * It works with data in a single section.\n */\n\n\nvar GridLayout = function (_Layout) {\n  _inherits(GridLayout, _Layout);\n\n  function GridLayout() {\n    _classCallCheck(this, GridLayout);\n\n    var _this = _possibleConstructorReturn(this, (GridLayout.__proto__ || Object.getPrototypeOf(GridLayout)).call(this));\n\n    _this.minItemSize = new _Size2.default(200, 200);\n    _this.maxItemSize = new _Size2.default(300, 300);\n    _this.minSpace = new _Size2.default(20, 20);\n    _this.maxColumns = Infinity;\n    _this.itemSize = null;\n    _this.numColumns = 0;\n    _this.numRows = 0;\n    return _this;\n  }\n\n  _createClass(GridLayout, [{\n    key: 'getLayoutInfo',\n    value: function getLayoutInfo(type, section, index) {\n      // Make a space for the dragged item\n      var dropTarget = this.collectionView._dropTarget;\n      var idx = index;\n\n      if (dropTarget && section === dropTarget.indexPath.section && index >= dropTarget.indexPath.index) {\n        idx++;\n      }\n\n      var row = Math.floor(idx / this.numColumns);\n      var column = idx % this.numColumns;\n      var x = this.horizontalSpacing + column * (this.itemSize.width + this.horizontalSpacing);\n      var y = this.minSpace.height + row * (this.itemSize.height + this.minSpace.height);\n      var layoutInfo = new _LayoutInfo2.default(type, section, index);\n      layoutInfo.rect = new _Rect2.default(x, y, this.itemSize.width, this.itemSize.height);\n      layoutInfo.estimatedSize = false;\n      return layoutInfo;\n    }\n  }, {\n    key: 'getIndexAtPoint',\n    value: function getIndexAtPoint(x, y) {\n      var itemHeight = this.itemSize.height + this.minSpace.height;\n      var itemWidth = this.itemSize.width + this.horizontalSpacing;\n      return Math.max(0, Math.min(this.collectionView.getSectionLength(0) - 1, Math.floor(y / itemHeight) * this.numColumns + Math.floor((x - this.horizontalSpacing) / itemWidth)));\n    }\n  }, {\n    key: 'getVisibleLayoutInfos',\n    value: function getVisibleLayoutInfos(rect) {\n      var numItems = this.collectionView.getSectionLength(0) - 1;\n\n      if (numItems < 0) {\n        return [];\n      }\n\n      var firstVisibleItem = this.getIndexAtPoint(rect.x, rect.y);\n      var lastVisibleItem = this.getIndexAtPoint(rect.maxX, rect.maxY);\n\n      if (this.collectionView._insertionIndex) {\n        lastVisibleItem++;\n      }\n\n      var res = [];\n\n      for (var index = firstVisibleItem; index <= lastVisibleItem; index++) {\n        var layoutInfo = this.getLayoutInfo('item', 0, index);\n\n        if (rect.intersects(layoutInfo.rect)) {\n          res.push(layoutInfo);\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: 'validate',\n    value: function validate() {\n      // Compute the number of rows and columns needed to display the content\n      var columns = Math.floor(this.collectionView.size.width / (this.minItemSize.width + this.minSpace.width));\n      this.numColumns = Math.max(1, Math.min(this.maxColumns, columns));\n      this.numRows = Math.ceil(this.collectionView.getSectionLength(0) / this.numColumns); // Compute the available width (minus the space between items)\n\n      var width = this.collectionView.size.width - this.minSpace.width * this.numColumns; // Compute the item width based on the space available\n\n      var itemWidth = Math.floor(width / this.numColumns);\n      itemWidth = Math.max(this.minItemSize.width, Math.min(this.maxItemSize.width, itemWidth)); // Compute the item height, which is proportional to the item width\n\n      var t = (itemWidth - this.minItemSize.width) / (this.maxItemSize.width - this.minItemSize.width);\n      var itemHeight = this.minItemSize.height + (this.maxItemSize.height - this.minItemSize.height) * t;\n      itemHeight = Math.max(this.minItemSize.height, Math.min(this.maxItemSize.height, itemHeight));\n      this.itemSize = new _Size2.default(itemWidth, itemHeight); // Compute the horizontal spacing and content height\n\n      this.horizontalSpacing = Math.floor((this.collectionView.size.width - this.numColumns * this.itemSize.width) / (this.numColumns + 1));\n      this.contentHeight = this.minSpace.height + this.numRows * (this.itemSize.height + this.minSpace.height);\n    }\n  }, {\n    key: 'getDropTarget',\n    value: function getDropTarget(point) {\n      var index = this.getIndexAtPoint(point.x, point.y);\n      return new _DragTarget2.default('item', new _IndexPath2.default(0, index));\n    }\n  }, {\n    key: 'getInitialLayoutInfo',\n    value: function getInitialLayoutInfo(type, section, index) {\n      var initial = _get(GridLayout.prototype.__proto__ || Object.getPrototypeOf(GridLayout.prototype), 'getInitialLayoutInfo', this).call(this, type, section, index);\n\n      initial.opacity = 0;\n      initial.transform = 'scale3d(0.8, 0.8, 0.8)';\n      return initial;\n    }\n  }, {\n    key: 'getFinalLayoutInfo',\n    value: function getFinalLayoutInfo(type, section, index) {\n      var final = _get(GridLayout.prototype.__proto__ || Object.getPrototypeOf(GridLayout.prototype), 'getFinalLayoutInfo', this).call(this, type, section, index);\n\n      final.opacity = 0;\n      final.transform = 'scale3d(0.8, 0.8, 0.8)';\n      return final;\n    }\n  }, {\n    key: 'getContentSize',\n    value: function getContentSize() {\n      return new _Size2.default(this.collectionView.size.width, this.contentHeight);\n    }\n  }, {\n    key: 'indexPathAbove',\n    value: function indexPathAbove(indexPath) {\n      return this.collectionView.incrementIndexPath(indexPath, -this.numColumns);\n    }\n  }, {\n    key: 'indexPathBelow',\n    value: function indexPathBelow(indexPath) {\n      return this.collectionView.incrementIndexPath(indexPath, this.numColumns);\n    }\n  }, {\n    key: 'indexPathLeftOf',\n    value: function indexPathLeftOf(indexPath) {\n      return this.collectionView.incrementIndexPath(indexPath, -1);\n    }\n  }, {\n    key: 'indexPathRightOf',\n    value: function indexPathRightOf(indexPath) {\n      return this.collectionView.incrementIndexPath(indexPath, 1);\n    }\n  }]);\n\n  return GridLayout;\n}(_Layout3.default);\n\nexports.default = GridLayout;","map":null,"metadata":{},"sourceType":"script"}