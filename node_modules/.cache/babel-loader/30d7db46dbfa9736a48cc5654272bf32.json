{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/rvang/Desktop/Spectrum/testapp/node_modules/@babel/runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _collectionView = require('@react/collection-view');\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var gen = fn.apply(this, arguments);\n    return new Promise(function (resolve, reject) {\n      function step(key, arg) {\n        try {\n          var info = gen[key](arg);\n          var value = info.value;\n        } catch (error) {\n          reject(error);\n          return;\n        }\n\n        if (info.done) {\n          resolve(value);\n        } else {\n          return Promise.resolve(value).then(function (value) {\n            step(\"next\", value);\n          }, function (err) {\n            step(\"throw\", err);\n          });\n        }\n      }\n\n      return step(\"next\");\n    });\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * ListDataSource is a common data source used by views that load a list of data.\n * It supports async loading, infinite scrolling, and sorting data.\n * Used by TableView and GridView.\n */\n\n\nvar ListDataSource = function (_ArrayDataSource) {\n  _inherits(ListDataSource, _ArrayDataSource);\n\n  function ListDataSource() {\n    _classCallCheck(this, ListDataSource);\n\n    return _possibleConstructorReturn(this, (ListDataSource.__proto__ || Object.getPrototypeOf(ListDataSource)).apply(this, arguments));\n  }\n\n  _createClass(ListDataSource, [{\n    key: 'load',\n\n    /**\n     * Called on initial load to get the initial items to display,\n     * which are inserted into a single section. Should be overridden to return an array of items.\n     * If you need to load multiple sections of data, override `performLoad` instead.\n     * @abstract\n     * @param {?object} sortDescriptor - When called by a TableView, contains the sort column and direction\n     * @return {Array}\n     */\n    value: function () {\n      var _ref = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(sortDescriptor) {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function load(_x) {\n        return _ref.apply(this, arguments);\n      }\n\n      return load;\n    }()\n    /**\n     * Called when scrolling near the bottom of a list. You can use this\n     * opportunity to load more data, e.g. for infinite scrolling. The array of\n     * items you return will be appended to the last section.\n     * If you need to load multiple sections of data, override `performLoadMore` instead.\n     * @abstract\n     * @return {Array}\n     */\n\n  }, {\n    key: 'loadMore',\n    value: function () {\n      var _ref2 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function loadMore() {\n        return _ref2.apply(this, arguments);\n      }\n\n      return loadMore;\n    }()\n    /**\n     * Triggers loading of data. You should call `insertSection` or `insertItems` \n     * as needed to add the loaded data into view. By default, calls `load` to get\n     * data for a single section.\n     * @param {?object} sortDescriptor - When called by a TableView, contains the sort column and direction\n     */\n\n  }, {\n    key: 'performLoad',\n    value: function () {\n      var _ref3 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(sortDescriptor) {\n        var items;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.clear(false);\n                _context3.next = 3;\n                return this.load(sortDescriptor);\n\n              case 3:\n                items = _context3.sent;\n\n                if (items) {\n                  this.insertSection(0, items.slice(), false);\n                }\n\n              case 5:\n              case 'end':\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function performLoad(_x2) {\n        return _ref3.apply(this, arguments);\n      }\n\n      return performLoad;\n    }()\n    /**\n     * Triggers a reload of the data in the attached view. Will cause the contents of the view\n     * to be cleared and `performLoad` to be called again. You should not call `performLoad` \n     * directly since that will not allow the view an opportunity to display its loading spinner.\n     */\n\n  }, {\n    key: 'reloadData',\n    value: function reloadData() {\n      this.emit('reloadData');\n    }\n    /**\n     * Triggers loading of more data when when scrolling near the bottom of a list.\n     * You should call `insertSection` or `insertItems` as needed to add the loaded data into view.\n     * Returns whether more data was successfully inserted. If you return false, the view will\n     * assume that all data has already been loaded and will stop calling `performLoadMore`.\n     * By default, calls `loadMore` to get data for a single section.\n     * @abstract\n     * @return {boolean} - Whether more data was inserted.\n     */\n\n  }, {\n    key: 'performLoadMore',\n    value: function () {\n      var _ref4 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4() {\n        var items;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return this.loadMore();\n\n              case 2:\n                items = _context4.sent;\n\n                if (!(items && items.length > 0)) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                this.insertItems(new _collectionView.IndexPath(0, this.sections[this.sections.length - 1].length), items.slice(), false);\n                return _context4.abrupt('return', true);\n\n              case 6:\n                return _context4.abrupt('return', false);\n\n              case 7:\n              case 'end':\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function performLoadMore() {\n        return _ref4.apply(this, arguments);\n      }\n\n      return performLoadMore;\n    }()\n    /**\n     * Performs sorting of the data. By default, calls `performLoad` to reload the data\n     * with the new sort descriptor.\n     * @param {object} sortDescriptor - Contains the sort column and direction\n     */\n\n  }, {\n    key: 'performSort',\n    value: function () {\n      var _ref5 = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(sortDescriptor) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.next = 2;\n                return this.performLoad(sortDescriptor);\n\n              case 2:\n              case 'end':\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function performSort(_x3) {\n        return _ref5.apply(this, arguments);\n      }\n\n      return performSort;\n    }()\n  }]);\n\n  return ListDataSource;\n}(_collectionView.ArrayDataSource);\n\nexports.default = ListDataSource;","map":null,"metadata":{},"sourceType":"script"}