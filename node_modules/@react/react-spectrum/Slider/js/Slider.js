'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _number = require('../../utils/number');

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _createId = require('../../utils/createId');

var _createId2 = _interopRequireDefault(_createId);

var _intl = require('../../utils/intl');

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var intlMessages = {
  'cs-CZ': _interopRequireDefault(require('./../intl/cs-CZ.json')).default,
  'da-DK': _interopRequireDefault(require('./../intl/da-DK.json')).default,
  'de-DE': _interopRequireDefault(require('./../intl/de-DE.json')).default,
  'en-US': _interopRequireDefault(require('./../intl/en-US.json')).default,
  'es-ES': _interopRequireDefault(require('./../intl/es-ES.json')).default,
  'fi-FI': _interopRequireDefault(require('./../intl/fi-FI.json')).default,
  'fr-FR': _interopRequireDefault(require('./../intl/fr-FR.json')).default,
  'it-IT': _interopRequireDefault(require('./../intl/it-IT.json')).default,
  'ja-JP': _interopRequireDefault(require('./../intl/ja-JP.json')).default,
  'ko-KR': _interopRequireDefault(require('./../intl/ko-KR.json')).default,
  'nb-NO': _interopRequireDefault(require('./../intl/nb-NO.json')).default,
  'nl-NL': _interopRequireDefault(require('./../intl/nl-NL.json')).default,
  'pl-PL': _interopRequireDefault(require('./../intl/pl-PL.json')).default,
  'pt-BR': _interopRequireDefault(require('./../intl/pt-BR.json')).default,
  'ru-RU': _interopRequireDefault(require('./../intl/ru-RU.json')).default,
  'sv-SE': _interopRequireDefault(require('./../intl/sv-SE.json')).default,
  'tr-TR': _interopRequireDefault(require('./../intl/tr-TR.json')).default,
  'zh-CN': _interopRequireDefault(require('./../intl/zh-CN.json')).default,
  'zh-TW': _interopRequireDefault(require('./../intl/zh-TW.json')).default
};

if (process.env.SCALE_MEDIUM && process.env.SCALE_LARGE) {
  require('../../spectrum-css/slider/index.css');

  require('../../spectrum-css/slider/index-diff.css');
} else if (process.env.SCALE_LARGE) {
  require('../../spectrum-css/slider/index-lg.css');
} else {
  require('../../spectrum-css/slider/index.css');
}

if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_LIGHT) require('../../spectrum-css/slider/multiStops/light.css');
if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_DARK) require('../../spectrum-css/slider/multiStops/dark.css');
if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_LIGHTEST) require('../../spectrum-css/slider/multiStops/lightest.css');
if (!process.env.THEME_LIGHT && !process.env.THEME_DARK && !process.env.THEME_LIGHTEST && !process.env.THEME_DARKEST || process.env.THEME_DARKEST) require('../../spectrum-css/slider/multiStops/darkest.css');


var formatMessage = (0, _intl.messageFormatter)(intlMessages);

var INPUT_POSTFIX = 'Input';
var LABEL_POSTFIX = '-label';
var STYLE_KEY = {
  FILL: {
    horizontal: 'width',
    vertical: 'height'
  },
  OFFSET: {
    horizontal: 'left',
    vertical: 'bottom'
  },
  OPPOSITE_OFFSET: {
    horizontal: 'right',
    vertical: 'top'
  }
};

var Slider = function (_React$Component) {
  _inherits(Slider, _React$Component);

  function Slider(props) {
    _classCallCheck(this, Slider);

    var _this = _possibleConstructorReturn(this, (Slider.__proto__ || Object.getPrototypeOf(Slider)).call(this, props));

    _this.state = {
      startValue: null,
      endValue: null,
      draggingHandle: null,
      focusedHandle: null
    };

    _this.findNearestHandle = function (pageX, pageY) {
      var closestDistance = Infinity; // Incredible large start value
      var closestHandle = 'startHandle';
      var handles = ['startHandle', 'endHandle'];

      // if variant is not range always return focused handle
      if (_this.props.variant !== 'range') {
        return closestHandle;
      }

      // Find the nearest handle
      handles.forEach(function (handle) {
        var rect = _this[handle + INPUT_POSTFIX].getBoundingClientRect();
        var top = rect.top + window.pageYOffset;
        var left = rect.left + window.pageXOffset;
        var distance = Math.floor(Math.sqrt(Math.pow(pageX - (left + rect.width / 2), 2) + Math.pow(pageY - (top + rect.height / 2), 2)));

        if (distance < closestDistance) {
          closestDistance = distance;
          closestHandle = handle;
        }
      });

      return closestHandle;
    };

    _this.onMouseDown = function (e, sliderHandle) {
      if (!sliderHandle) {
        sliderHandle = _this.findNearestHandle(e.pageX, e.pageY);
      } else {
        // stop propagation of event up to .spectrum-Slider-controls
        e.stopPropagation();
      }

      var input = _this[sliderHandle + INPUT_POSTFIX];

      if (input) {
        input.focus();
      }

      // persist event for use after state change
      e.persist();

      _this.setState({
        sliderHandle: null,
        isMouseUp: false,
        draggingHandle: sliderHandle
      }, function () {
        return _this.onMouseMove(e);
      });

      window.addEventListener('mouseup', _this.onMouseUp);
      window.addEventListener('mousemove', _this.onMouseMove);

      document.body.classList.add(_this.isDraggedBodyClassName);
    };

    _this.onMouseUp = function (e) {
      var draggingHandle = _this.state.draggingHandle;

      var input = draggingHandle && _this[draggingHandle + INPUT_POSTFIX];

      // Blur the input so that focused styling is removed with mouse/touch interaction.
      if (input) {
        input.blur();
      }

      _this.setState({
        isMouseUp: true,
        draggingHandle: null
      }, function () {
        // Restore focus to the input so that keyboard interaction will continue to work.
        if (input) {
          input.focus();
        }
      });

      if (_this.props.onChangeEnd) {
        if (_this.props.variant === 'range') {
          _this.props.onChangeEnd(_this.state.startValue, _this.state.endValue);
        } else {
          _this.props.onChangeEnd(_this.state.startValue);
        }
      }

      window.removeEventListener('mouseup', _this.onMouseUp);
      window.removeEventListener('mousemove', _this.onMouseMove);

      document.body.classList.remove(_this.isDraggedBodyClassName);
    };

    _this.calculateHandlePosition = function (e) {
      var _this$props = _this.props,
          min = _this$props.min,
          max = _this$props.max,
          orientation = _this$props.orientation,
          step = _this$props.step;

      var vertical = orientation === 'vertical';

      var rect = _this.dom.getBoundingClientRect();
      var minOffset = vertical ? rect.top : rect.left;
      var offset = vertical ? e.clientY : e.clientX;
      var size = vertical ? rect.height : rect.width;

      // Compute percentage
      var percent = (offset - minOffset) / size;
      percent = (0, _number.clamp)(percent, 0, 1);
      if (vertical) {
        percent = 1 - percent;
      }

      // Compute real value based in min and max, and snap to nearest step.
      var value = min + (max - min) * percent;
      if (step) {
        value = Math.round(value / step) * step;
      }

      return value;
    };

    _this.getHandleValues = function (value, step) {
      var _this$state = _this.state,
          draggingHandle = _this$state.draggingHandle,
          startValue = _this$state.startValue,
          endValue = _this$state.endValue;


      if (draggingHandle === 'startHandle') {
        startValue = value;
      }

      if (draggingHandle === 'endHandle') {
        endValue = value;
      }

      step = !step ? 1 : step;
      if (+startValue + step > endValue) {
        return [_this.state.startValue, _this.state.endValue];
      } else {
        return [startValue, endValue];
      }
    };

    _this.onMouseMove = function (e) {
      e.preventDefault();

      var value = _this.calculateHandlePosition(e);
      if (_this.props.variant === 'range') {
        var _this$getHandleValues = _this.getHandleValues(value, _this.props.step),
            _this$getHandleValues2 = _slicedToArray(_this$getHandleValues, 2),
            startValue = _this$getHandleValues2[0],
            endValue = _this$getHandleValues2[1];

        _this.updateValues(startValue, endValue, _this.state.draggingHandle);
      } else {
        _this.updateValues(value, null, 'startHandle');
      }
    };

    _this.updateValues = function (startValue) {
      var endValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var sliderHandle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var _this$props2 = _this.props,
          min = _this$props2.min,
          max = _this$props2.max,
          step = _this$props2.step,
          variant = _this$props2.variant,
          onChange = _this$props2.onChange;


      startValue = (0, _number.snapValueToStep)(startValue, min, max, step);

      if (variant === 'range') {
        endValue = (0, _number.snapValueToStep)(endValue, min, max, step);

        if (onChange && (startValue !== _this.state.startValue || endValue !== _this.state.endValue)) {
          onChange(startValue, endValue);
        }

        if (_this.props.startValue == null && _this.props.endValue == null) {
          _this.setState({ startValue: startValue, endValue: endValue, focusedHandle: !_this.state.isMouseUp ? sliderHandle : null });
        }
      } else {
        if (onChange && startValue !== _this.state.startValue) {
          onChange(startValue);
        }

        // If value is not set in props (uncontrolled component), set state
        if (_this.props.value == null) {
          _this.setState({ startValue: startValue, focusedHandle: !_this.state.isMouseUp ? sliderHandle : null });
        }
      }
    };

    _this.onChange = function (e, sliderHandle) {
      var _this$props3 = _this.props,
          step = _this$props3.step,
          variant = _this$props3.variant;
      var _this$state2 = _this.state,
          startValue = _this$state2.startValue,
          endValue = _this$state2.endValue;

      var isStartHandle = sliderHandle === 'startHandle';
      var value = isStartHandle ? startValue : endValue;
      var inputValue = +e.target.value;
      if (inputValue !== value) {
        if (variant === 'range') {
          _this.setState({
            draggingHandle: sliderHandle
          }, function () {
            var _this$getHandleValues3 = _this.getHandleValues(inputValue, step),
                _this$getHandleValues4 = _slicedToArray(_this$getHandleValues3, 2),
                startValue = _this$getHandleValues4[0],
                endValue = _this$getHandleValues4[1];

            _this.updateValues(startValue, endValue, sliderHandle);
            _this.setState({ draggingHandle: null });
          });
        } else {
          _this.updateValues(inputValue, null, sliderHandle);
        }
      }
    };

    _this.onFocus = function (e, sliderHandle) {
      _this.setState({
        focusedHandle: !_this.state.isMouseUp ? sliderHandle : null,
        topHandle: sliderHandle,
        isMouseUp: false
      });
    };

    _this.onBlur = function (e, sliderHandle) {
      _this.setState({
        focusedHandle: null
      });
    };

    _this.onClickSliderValue = function (e) {
      var selection = window.getSelection();
      var sliderHandle = 'startHandle';

      /* Clicking the portion of the slider value text label after the en-dash character should move focus to the endHandle. */
      if (_this.props.variant === 'range' && selection.focusOffset > e.target.textContent.indexOf('–')) {
        sliderHandle = 'endHandle';
      }

      _this[sliderHandle + INPUT_POSTFIX].focus();
    };

    _this.getAriaLabelledby = function () {
      var sliderHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      var label = _this.props.label;
      var ariaLabelledby = _this.props['aria-labelledby'];
      var ariaLabel = _this.props['aria-label'];
      var ids = [];

      if (ariaLabelledby) {
        ids.push(ariaLabelledby);
      }

      if (label || ariaLabel) {
        ids.push(_this.getLabelId());
      }

      if (sliderHandle) {
        ids.push(_this.getSliderHandleInputId(sliderHandle));
      }

      return ids.join(' ');
    };

    _this.renderSliderHandle = function (sliderHandle) {
      var _this$props4 = _this.props,
          disabled = _this$props4.disabled,
          max = _this$props4.max,
          min = _this$props4.min,
          orientation = _this$props4.orientation,
          step = _this$props4.step,
          variant = _this$props4.variant,
          otherProps = _objectWithoutProperties(_this$props4, ['disabled', 'max', 'min', 'orientation', 'step', 'variant']);

      var _this$state3 = _this.state,
          draggingHandle = _this$state3.draggingHandle,
          focusedHandle = _this$state3.focusedHandle,
          topHandle = _this$state3.topHandle,
          startValue = _this$state3.startValue,
          endValue = _this$state3.endValue;

      var isStartHandle = sliderHandle === 'startHandle';
      var value = isStartHandle ? startValue : endValue;
      var percent = (value - min) / (max - min);
      var isRange = variant === 'range';
      var isVertical = orientation === 'vertical';
      var isDragged = draggingHandle === sliderHandle;
      var isFocused = focusedHandle === sliderHandle;
      var isTopHandle = topHandle === sliderHandle;
      var styleKey = STYLE_KEY.OFFSET[orientation];
      var labelString = isStartHandle ? formatMessage('minimum') : formatMessage('maximum');
      var ariaLabel = otherProps['aria-label'];
      var ariaValueMin = null;
      var ariaValueMax = null;

      if (isRange) {
        ariaLabel = labelString;
        ariaValueMin = isStartHandle ? min : startValue;
        ariaValueMax = isStartHandle ? endValue : max;
      }

      return _react2.default.createElement(
        'div',
        {
          className: (0, _classnames2.default)('spectrum-Slider-handle', {
            'is-dragged': isDragged,
            'is-focused': isFocused,
            'is-tophandle': isTopHandle
          }),
          onMouseDown: !disabled && isRange ? function (e) {
            return _this.onMouseDown(e, sliderHandle);
          } : null,
          style: _defineProperty({}, styleKey, percent * 100 + '%'),
          role: 'presentation' },
        _react2.default.createElement('input', {
          id: _this.getSliderHandleInputId(sliderHandle),
          ref: function ref(i) {
            return _this[sliderHandle + INPUT_POSTFIX] = i;
          },
          type: 'range',
          className: 'spectrum-Slider-input',
          step: step,
          max: max,
          min: min,
          disabled: disabled,
          'aria-orientation': isVertical ? orientation : null,
          'aria-label': ariaLabel || null,
          'aria-labelledby': _this.getAriaLabelledby(isRange ? sliderHandle : null),
          'aria-describedby': otherProps['aria-describedby'] || null,
          'aria-valuemin': ariaValueMin,
          'aria-valuemax': ariaValueMax,
          'aria-valuetext': value,
          defaultValue: undefined,
          value: value,
          onChange: !disabled ? function (e) {
            return _this.onChange(e, sliderHandle);
          } : null,
          onFocus: !disabled ? function (e) {
            return _this.onFocus(e, sliderHandle);
          } : null,
          onBlur: !disabled ? function (e) {
            return _this.onBlur(e, sliderHandle);
          } : null })
      );
    };

    _this.setDOMReference = function (d) {
      return _this.dom = d;
    };

    _this.sliderId = (0, _createId2.default)();
    return _this;
  }

  _createClass(Slider, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.componentWillReceiveProps(this.props);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      // For range slider
      if (props.variant === 'range') {
        var startValue = props.startValue == null ? props.defaultStartValue : props.startValue;
        var endValue = props.endValue == null ? props.defaultEndValue : props.endValue;
        if (startValue == null && (this.state.startValue == null || this.props.min !== props.min)) {
          startValue = props.min;
        }
        if (endValue == null && (this.state.endValue == null || this.props.max !== props.max)) {
          endValue = props.max;
        }
        if (startValue != null && endValue != null) {
          this.setState({ startValue: startValue, endValue: endValue });
        }
      } else {
        // For single slider
        var _startValue = props.value == null ? props.defaultValue : props.value;
        if (_startValue == null && (this.state.startValue == null || this.props.max !== props.max || this.props.min !== props.min)) {
          _startValue = props.min + (props.max - props.min) / 2;
        }
        if (_startValue != null) {
          this.setState({ startValue: _startValue });
        }
      }
      this.isDraggedBodyClassName = 'u-isGrabbing';
    }

    /**
     * Finds the nearest handle based on X/Y coordinates
     *  @private
     */

  }, {
    key: 'getLabelId',
    value: function getLabelId() {
      return this.sliderId + LABEL_POSTFIX;
    }
  }, {
    key: 'getSliderHandleInputId',
    value: function getSliderHandleInputId(sliderHandle) {
      var _props$id = this.props.id,
          id = _props$id === undefined ? this.sliderId : _props$id;

      return sliderHandle === 'startHandle' ? id : id + '-' + sliderHandle + INPUT_POSTFIX;
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this,
          _ref3;

      var _props = this.props,
          children = _props.children,
          disabled = _props.disabled,
          filled = _props.filled,
          _props$id2 = _props.id,
          id = _props$id2 === undefined ? this.sliderId : _props$id2,
          label = _props.label,
          max = _props.max,
          min = _props.min,
          orientation = _props.orientation,
          renderLabel = _props.renderLabel,
          variant = _props.variant,
          otherProps = _objectWithoutProperties(_props, ['children', 'disabled', 'filled', 'id', 'label', 'max', 'min', 'orientation', 'renderLabel', 'variant']);

      var _state = this.state,
          startValue = _state.startValue,
          endValue = _state.endValue;

      var isRamp = variant === 'ramp';
      var isRange = variant === 'range';
      var isVertical = orientation === 'vertical';
      var sliderClasses = (0, _classnames2.default)('spectrum-Slider', this.props.className, {
        'spectrum-Slider--vertical': isVertical,
        'spectrum-Slider--ramp': isRamp,
        'spectrum-Slider--range': isRange,
        'spectrum-Slider--filled': filled,
        'is-disabled': disabled
      });
      var shouldRenderLabel = renderLabel && label;
      var ariaLabel = otherProps['aria-label'];
      var ariaLabelledby = this.getAriaLabelledby();
      var labelValue = isRange ? [startValue, endValue].join('–') : startValue;
      var delta = isRange ? endValue - startValue : startValue - min;
      var valueRange = max - min;
      var percent = delta / valueRange;
      var styleKeyFill = STYLE_KEY.FILL[orientation];
      var styleKeyOffset = STYLE_KEY.OFFSET[orientation];
      var styleKeyOppositeOffset = STYLE_KEY.OPPOSITE_OFFSET[orientation];

      var startPercent = (startValue - min) / (max - min);
      var endPercent = (endValue - min) / (max - min);

      if (isRamp) {
        children = null;
      }

      // Range slider should always be filled
      if (isRange && !filled) {
        filled = true;
      }

      return _react2.default.createElement(
        'div',
        {
          className: sliderClasses,
          ref: this.setDOMReference,
          role: isRange ? 'group' : 'presentation',
          'aria-labelledby': isRange ? ariaLabelledby : null },
        (shouldRenderLabel || label && ariaLabelledby || ariaLabel) && _react2.default.createElement(
          'div',
          { className: 'spectrum-Slider-labelContainer' },
          _react2.default.createElement(
            'label',
            {
              id: this.getLabelId(),
              className: 'spectrum-Slider-label',
              htmlFor: id,
              hidden: !shouldRenderLabel || null,
              'aria-label': !otherProps['aria-labelledby'] ? ariaLabel : null },
            label
          ),
          shouldRenderLabel && _react2.default.createElement(
            'div',
            { className: 'spectrum-Slider-value', role: 'textbox', 'aria-readonly': 'true', 'aria-labelledby': ariaLabelledby, onClick: !disabled ? function (e) {
                return _this2.onClickSliderValue(e);
              } : null },
            labelValue
          )
        ),
        _react2.default.createElement(
          'div',
          {
            className: 'spectrum-Slider-controls',
            role: 'presentation',
            onMouseDown: !disabled ? function (e) {
              return _this2.onMouseDown(e);
            } : null },
          !isRamp && _react2.default.createElement('div', {
            className: 'spectrum-Slider-track',
            role: 'presentation',
            style: _defineProperty({}, styleKeyFill, (isRange ? startPercent : percent) * 100 + '%') }),
          isRamp && _react2.default.createElement(
            'div',
            { className: 'spectrum-Slider-ramp' },
            _react2.default.createElement(
              'svg',
              { width: '100%', viewBox: '0 0 240 16', preserveAspectRatio: 'none', 'aria-hidden': 'true', focusable: 'false' },
              _react2.default.createElement('path', { d: 'M240,4v8c0,2.3-1.9,4.1-4.2,4L1,9C0.4,9,0,8.5,0,8c0-0.5,0.4-1,1-1l234.8-7C238.1-0.1,240,1.7,240,4z' })
            )
          ),
          children,
          this.renderSliderHandle('startHandle'),
          isRange && _react2.default.createElement('div', {
            className: 'spectrum-Slider-track',
            role: 'presentation',
            style: (_ref3 = {}, _defineProperty(_ref3, styleKeyOffset, startPercent * 100 + '%'), _defineProperty(_ref3, styleKeyOppositeOffset, (1 - endPercent) * 100 + '%'), _ref3) }),
          isRange ? this.renderSliderHandle('endHandle') : null,
          !isRamp && _react2.default.createElement('div', {
            className: 'spectrum-Slider-track',
            role: 'presentation',
            style: _defineProperty({}, styleKeyFill, (1 - (isRange ? endPercent : percent)) * 100 + '%') })
        )
      );
    }
  }]);

  return Slider;
}(_react2.default.Component);

Slider.propTypes = {

  /**
   * ID of the slider.
   */
  id: _propTypes2.default.string,

  /**
   * The minimal number of the range.
   */
  min: _propTypes2.default.number,

  /**
   * The maximum number of the range.
   */
  max: _propTypes2.default.number,

  /**
   * The size of the incremental or decremental step.
   */
  step: _propTypes2.default.number,

  /**
   * Disable the slider if value is set to true.
   */
  disabled: _propTypes2.default.bool,

  /**
   * The orientation of the slider.
   */
  orientation: _propTypes2.default.oneOf(['horizontal', 'vertical']),

  /**
   * Set to true to render label.
   */
  renderLabel: _propTypes2.default.bool,

  /**
   * The label of the slider.
   */
  label: _propTypes2.default.node,

  /**
   * Whether the line of the slider should be filled.
   */
  filled: _propTypes2.default.bool,

  /**
   * The variant
   */
  variant: _propTypes2.default.oneOf([null, 'ramp', 'range']),

  /**
   * The size of the slider. Small (S) or large (L) are available.
   */
  size: _propTypes2.default.oneOf([null, 'S', 'L']),

  /**
   * Callback function when the slider is changed.  If the variant is range, starting value
   * and ending value are passed to the callback function.  Otherwise, only the starting value
   * is passed into the callback function.
   */
  onChange: _propTypes2.default.func
};
Slider.defaultProps = {
  min: 0,
  max: 100,
  step: 0,
  disabled: false,
  orientation: 'horizontal',
  renderLabel: false,
  label: null,
  filled: false,
  variant: null,
  size: null,
  onChange: function onChange() {}
};
exports.default = Slider;