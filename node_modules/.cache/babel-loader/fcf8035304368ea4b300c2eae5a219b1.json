{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar _CollectionData = require('./CollectionData');\n\nvar _CollectionData2 = _interopRequireDefault(_CollectionData);\n\nvar _utils = require('./utils');\n\nvar _DataSource = require('./DataSource');\n\nvar _DataSource2 = _interopRequireDefault(_DataSource);\n\nvar _IndexPath = require('./IndexPath');\n\nvar _IndexPath2 = _interopRequireDefault(_IndexPath);\n\nvar _IndexPathSet = require('./IndexPathSet');\n\nvar _IndexPathSet2 = _interopRequireDefault(_IndexPathSet);\n\nvar _Point = require('./Point');\n\nvar _Point2 = _interopRequireDefault(_Point);\n\nvar _Rect = require('./Rect');\n\nvar _Rect2 = _interopRequireDefault(_Rect);\n\nvar _raf = require('raf');\n\nvar _raf2 = _interopRequireDefault(_raf);\n\nvar _ScrollView2 = require('./ScrollView.js');\n\nvar _ScrollView3 = _interopRequireDefault(_ScrollView2);\n\nvar _Transaction = require('./Transaction');\n\nvar _Transaction2 = _interopRequireDefault(_Transaction);\n\nvar _tween = require('./tween');\n\nvar _tween2 = _interopRequireDefault(_tween);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * The CollectionView class renders a scrollable collection of data using customizable layouts,\n * and manages animated updates to the data over time. It supports very large collections by\n * only rendering visible views to the DOM, reusing them as you scroll. Collection views can\n * present any type of view, including non-item views such as section headers and footers.\n * Optionally, the {@link EditableCollectionView} subclass can be used to enable user interaction\n * with the collection, including drag and drop, multiple selection, and keyboard interacton.\n *\n * Collection views get their data from a {@link DataSource} object that you provide. Items are\n * grouped into sections by the data source, and the collection view calls its methods to retrieve\n * the data. When data changes, the data source emits change events, and the collection view\n * updates as appropriate, optionally with an animated transition. There is one built-in data source\n * implementation, {@link ArrayDataSource}, which renders content from a 2d array.\n *\n * Collection views use {@link Layout} objects to compute what views should be visible, and how\n * to position and style them. This means that collection views can have their items arranged in\n * a stack, a grid, a circle, or any other layout you can think of. The layout can be changed\n * dynamically at runtime as well, optionally with an animated transition between the layouts.\n *\n * Layouts produce information on what views should appear in the collection view, but do not create\n * the views themselves directly. It is the responsibility of the {@link CollectionViewDelegate} object\n * to create instances of {@link ReusableView} subclasses which render the items into DOM nodes.\n * The delegate determines what type of view to display for each item, and creates instances of\n * views as needed by the collection view. Those views are then reused by the collection view as\n * the user scrolls through the content.\n */\n\n\nvar CollectionView = function (_ScrollView) {\n  _inherits(CollectionView, _ScrollView);\n\n  function CollectionView() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, CollectionView);\n    /**\n     * The collection view delegate. The delegate is used by the collection view\n     * to create and configure views.\n     * @type {CollectionViewDelegate}\n     */\n\n\n    var _this = _possibleConstructorReturn(this, (CollectionView.__proto__ || Object.getPrototypeOf(CollectionView)).call(this, options));\n\n    _this.delegate = null;\n    _this._content = null;\n    _this._layout = null;\n    _this._dataSource = null;\n    _this._reusableViews = {};\n    _this._visibleViews = new Map();\n    _this._invalidationContext = null;\n    _this._scrollAnimation = null;\n    _this._sizeUpdateQueue = new _IndexPathSet2.default();\n    _this._animatedContentOffset = new _Point2.default(0, 0);\n    _this._transaction = null;\n    _this._nextTransaction = null;\n    _this._transactionQueue = [];\n    _this._startTransaction = _this._startTransaction.bind(_this);\n    _this._endTransaction = _this._endTransaction.bind(_this);\n    _this._insertItem = _this._insertItem.bind(_this);\n    _this._insertSection = _this._insertSection.bind(_this);\n    _this._removeItem = _this._removeItem.bind(_this);\n    _this._removeSection = _this._removeSection.bind(_this);\n    _this._moveItem = _this._moveItem.bind(_this);\n    _this._moveSection = _this._moveSection.bind(_this);\n    _this._reloadItem = _this._reloadItem.bind(_this);\n    _this._reloadSection = _this._reloadSection.bind(_this); // Set options from passed object if given\n\n    var _arr = ['delegate', 'size', 'layout', 'dataSource'];\n\n    for (var _i = 0; _i < _arr.length; _i++) {\n      var key = _arr[_i];\n\n      if (options[key]) {\n        _this[key] = options[key];\n      }\n    }\n    /**\n     * The duration of animated layout changes, in milliseconds. Default is 500ms.\n     * @type {number}\n     */\n\n\n    _this.transitionDuration = options.transitionDuration || 500;\n    /**\n     * Whether to enable scroll anchoring. This will attempt to restore the scroll position\n     * after layout changes outside the viewport. Default is off.\n     * @type {boolean}\n     */\n\n    _this.anchorScrollPosition = options.anchorScrollPosition || false;\n    /**\n     * Whether to anchor the scroll position when at the top of the content. Default is off.\n     * @type {boolean}\n     */\n\n    _this.anchorScrollPositionAtTop = options.anchorScrollPositionAtTop || false;\n    return _this;\n  }\n\n  _createClass(CollectionView, [{\n    key: 'setSize',\n    value: function setSize(size) {\n      // Ignore if the sizes are equal\n      if (size.equals(this.size)) {\n        return;\n      }\n\n      var visibleRect = this.getVisibleRect(this.contentOffset, size);\n      var shouldInvalidate = this.layout && this.layout.shouldInvalidate(visibleRect);\n\n      _get(CollectionView.prototype.__proto__ || Object.getPrototypeOf(CollectionView.prototype), 'setSize', this).call(this, size);\n\n      if (shouldInvalidate) {\n        this.relayout({\n          sizeChanged: true\n        });\n      }\n    }\n    /**\n     * Get the collection view's data source\n     * @type {DataSource}\n     */\n\n  }, {\n    key: '_setDataSource',\n    value: function _setDataSource(dataSource) {\n      if (dataSource && !(dataSource instanceof _DataSource2.default)) {\n        throw new Error('Data source must be a subclass of DataSource');\n      }\n\n      if (this._dataSource) {\n        this._teardownDataSource();\n      }\n\n      this._dataSource = dataSource;\n\n      if (dataSource) {\n        this._setupDataSource();\n      }\n\n      this.reloadData();\n    }\n    /**\n     * Reloads the data from the data source and relayouts the collection view.\n     * Does not animate any changes. Equivalent to re-assigning the same data source\n     * to the collection view.\n     */\n\n  }, {\n    key: 'reloadData',\n    value: function reloadData() {\n      this._content = new _CollectionData2.default(this.dataSource);\n      this.relayout({\n        contentChanged: true\n      });\n    }\n  }, {\n    key: '_setupDataSource',\n    value: function _setupDataSource() {\n      this._dataSource.on('startTransaction', this._startTransaction);\n\n      this._dataSource.on('endTransaction', this._endTransaction);\n\n      this._dataSource.on('insertItem', this._insertItem);\n\n      this._dataSource.on('insertSection', this._insertSection);\n\n      this._dataSource.on('removeItem', this._removeItem);\n\n      this._dataSource.on('removeSection', this._removeSection);\n\n      this._dataSource.on('moveItem', this._moveItem);\n\n      this._dataSource.on('moveSection', this._moveSection);\n\n      this._dataSource.on('reloadSection', this._reloadSection);\n\n      this._dataSource.on('reloadItem', this._reloadItem);\n    }\n  }, {\n    key: '_teardownDataSource',\n    value: function _teardownDataSource() {\n      this._dataSource.removeListener('startTransaction', this._startTransaction);\n\n      this._dataSource.removeListener('endTransaction', this._endTransaction);\n\n      this._dataSource.removeListener('insertItem', this._insertItem);\n\n      this._dataSource.removeListener('insertSection', this._insertSection);\n\n      this._dataSource.removeListener('removeItem', this._removeItem);\n\n      this._dataSource.removeListener('removeSection', this._removeSection);\n\n      this._dataSource.removeListener('moveItem', this._moveItem);\n\n      this._dataSource.removeListener('moveSection', this._moveSection);\n\n      this._dataSource.removeListener('reloadSection', this._reloadSection);\n\n      this._dataSource.removeListener('reloadItem', this._reloadItem);\n    }\n    /**\n     * Returns the number of sections in the collection view\n     * @return {number}\n     */\n\n  }, {\n    key: 'getNumberOfSections',\n    value: function getNumberOfSections() {\n      return this._content ? this._content.getNumberOfSections() : 0;\n    }\n    /**\n     * Returns the number of items in the given section\n     * @param {number} section\n     * @return {number}\n     */\n\n  }, {\n    key: 'getSectionLength',\n    value: function getSectionLength(section) {\n      return this._content ? this._content.getSectionLength(section) : 0;\n    }\n    /**\n     * Returns the item at the given section and index. You can also pass\n     * an {@link IndexPath} as the only argument instead.\n     * @param {number|IndexPath} section\n     * @param {number} index\n     */\n\n  }, {\n    key: 'getItem',\n    value: function getItem(section, index) {\n      if (section instanceof _IndexPath2.default) {\n        index = section.index;\n        section = section.section;\n      }\n\n      return this._content ? this._content.getItem(section, index) : null;\n    }\n    /**\n     * Returns an IndexPath by adding the given number of items to the provided IndexPath.\n     * Works across sections such that if you add one to the last item in a section, you\n     * will get the first item in the next section.\n     *\n     * @param {IndexPath} indexPath - The IndexPath to add to\n     * @param {number} amount - The amount to add\n     * @return {IndexPath}\n     */\n\n  }, {\n    key: 'incrementIndexPath',\n    value: function incrementIndexPath(indexPath, amount) {\n      return this._content ? this._content.incrementIndexPath(indexPath, amount) : null;\n    }\n    /**\n     * Get the collection view's layout\n     * @type {Layout}\n     */\n\n  }, {\n    key: 'setLayout',\n\n    /**\n     * Sets the collection view's layout, optionally with an animated transition\n     * from the current layout to the new layout.\n     * @param {Layout} layout - The layout to switch to\n     * @param {boolean} [animated=false] - Whether to animate the layout change\n     */\n    value: function setLayout(layout) {\n      var _this2 = this;\n\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var applyLayout = function applyLayout() {\n        if (_this2._layout) {\n          _this2._layout.collectionView = null;\n        }\n\n        layout.collectionView = _this2;\n        _this2._layout = layout;\n      };\n\n      if (animated) {\n        // Animated layout transitions are really simple, thanks to our transaction support.\n        // We just set the layout inside a transaction action, which runs after the initial\n        // layout infos for the animation are retrieved from the previous layout. Then, the\n        // final layout infos are retrieved from the new layout, and animations occur.\n        this._runTransaction(applyLayout);\n      } else {\n        applyLayout();\n        this.relayout();\n      }\n    }\n  }, {\n    key: 'createView',\n    value: function createView(type, section, index) {\n      return this.delegate.createView(type, section, index);\n    }\n  }, {\n    key: '_getReuseType',\n    value: function _getReuseType(layoutInfo, content) {\n      if (layoutInfo.type === 'item') {\n        var type = this.delegate.getType ? this.delegate.getType(content) : 'item';\n        var reuseType = type === 'item' ? 'item' : layoutInfo.type + '_' + type;\n        return {\n          type: type,\n          reuseType: reuseType\n        };\n      }\n\n      return {\n        type: layoutInfo.type,\n        reuseType: layoutInfo.type\n      };\n    }\n  }, {\n    key: 'getReusableView',\n    value: function getReusableView(layoutInfo) {\n      var content = this._getViewContent(layoutInfo.type, layoutInfo.section, layoutInfo.index);\n\n      var _getReuseType2 = this._getReuseType(layoutInfo, content),\n          type = _getReuseType2.type,\n          reuseType = _getReuseType2.reuseType;\n\n      if (!this._reusableViews[reuseType]) {\n        this._reusableViews[reuseType] = [];\n      }\n\n      var reusable = this._reusableViews[reuseType];\n      var view = reusable.length > 0 ? reusable.pop() : this.createView(type, layoutInfo.section, layoutInfo.index);\n      view.collectionView = this;\n      view.viewType = reuseType;\n\n      this._applyLayoutInfo(view, layoutInfo);\n\n      view.setContent(content);\n      return view;\n    }\n  }, {\n    key: '_getViewContent',\n    value: function _getViewContent(type, section, index) {\n      if (type === 'item') {\n        return this.getItem(section, index);\n      }\n\n      if (this.delegate.getContentForExtraView) {\n        return this.delegate.getContentForExtraView(type, section, index);\n      }\n\n      return null;\n    }\n    /**\n     * Returns an array of all currently visible views, including both\n     * item views and supplementary views.\n     * @type {ReusableView[]}\n     */\n\n  }, {\n    key: 'getItemView',\n\n    /**\n     * Gets the visible item view for the given section and index. You can also pass\n     * an {@link IndexPath} as the only argument instead. Returns null if\n     * the view is not currently visible.\n     *\n     * @param {number|IndexPath} section\n     * @param {number} index\n     * @return {ReusableView}\n     */\n    value: function getItemView(section, index) {\n      return this.getView('item', section, index);\n    }\n    /**\n     * Gets the visible view for the given parameters. You can also pass\n     * an {@link IndexPath} as the second argument instead. Returns null if\n     * the view is not currently visible.\n     *\n     * @param {string} type - The view type. `'item'` for an item view.\n     * @param {number|IndexPath} section\n     * @param {number} index\n     * @return {ReusableView}\n     */\n\n  }, {\n    key: 'getView',\n    value: function getView(type, section, index) {\n      if (section instanceof _IndexPath2.default) {\n        index = section.index;\n        section = section.section;\n      }\n\n      try {\n        var key = this._content.getKey(type, section, index);\n\n        return this._visibleViews.get(key);\n      } catch (err) {\n        return null;\n      }\n    }\n    /**\n     * Returns an array of visible views matching the given type.\n     * @param {string} type - The view type to find. `'item'` for item views.\n     * @return {ReusableView[]}\n     */\n\n  }, {\n    key: 'getViewsOfType',\n    value: function getViewsOfType(type) {\n      return this.visibleViews.filter(function (v) {\n        return v.layoutInfo.type === type;\n      });\n    }\n    /**\n     * Reloads the content of the supplementary view matching the given parameters.\n     * You can also pass an {@link IndexPath} as the second argument instead.\n     * This method does not work with item views. You should emit a \"reloadItem\" or\n     * \"reloadSection\" event from your data source instead.\n     *\n     * @param {string} type - The view type. `'item'` for an item view.\n     * @param {number|IndexPath} section\n     * @param {number} index\n     */\n\n  }, {\n    key: 'reloadSupplementaryView',\n    value: function reloadSupplementaryView(type, section, index) {\n      var _this3 = this;\n\n      if (type === 'item') {\n        throw new Error('Do not reload item views with this method. ' + 'Emit a \"reloadItem\" or \"reloadSection\" event from your data source instead.');\n      }\n\n      if (section instanceof _IndexPath2.default) {\n        index = section.index;\n        section = section.section;\n      }\n\n      var content = this._getViewContent(type, section, index);\n\n      this._runTransaction(function () {\n        var view = _this3.getView(type, section, index);\n\n        if (!view) {\n          return;\n        }\n\n        view.setContent(content);\n      }, false);\n    }\n    /**\n     * Reloads the content of all visible supplementary views of the given type.\n     * @param {string} type - The view type to reload. `'item'` for an item view.\n     */\n\n  }, {\n    key: 'reloadSupplementaryViewsOfType',\n    value: function reloadSupplementaryViewsOfType(type) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.getViewsOfType(type)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var view = _step.value;\n\n          if (view.layoutInfo) {\n            this.reloadSupplementaryView(type, view.layoutInfo.section, view.layoutInfo.index);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\n     * Returns the IndexPath that the given view represents. Returns null\n     * if the view is not currently visible.\n     *\n     * @param {ReusableView} view\n     * @return {IndexPath}\n     */\n\n  }, {\n    key: 'indexPathForView',\n    value: function indexPathForView(view) {\n      if (view && view.layoutInfo && view.layoutInfo.type === 'item') {\n        return new _IndexPath2.default(view.layoutInfo.section, view.layoutInfo.index);\n      }\n\n      return null;\n    }\n    /**\n     * Returns the IndexPath for the item view currently at the given point.\n     * @param {Point} point\n     * @return {indexPath}\n     */\n\n  }, {\n    key: 'indexPathAtPoint',\n    value: function indexPathAtPoint(point) {\n      var rect = new _Rect2.default(point.x, point.y, 1, 1);\n      var layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n      var layoutInfo = layoutInfos.filter(function (l) {\n        return l.type === 'item';\n      })[0];\n\n      if (!layoutInfo) {\n        return null;\n      }\n\n      return new _IndexPath2.default(layoutInfo.section, layoutInfo.index);\n    }\n    /**\n     * Returns the IndexPath for the item view containing a given DOM node\n     * @param {HTMLElement} a DOM node\n     * @return {indexPath}\n     */\n\n  }, {\n    key: 'indexPathAtDOMNode',\n    value: function indexPathAtDOMNode(node) {\n      var view = Array.from(this._visibleViews.values()).find(function (v) {\n        var domNode = v.getDOMNode();\n        return v.layoutInfo.type === 'item' && domNode && (domNode === node || domNode.contains(node));\n      });\n\n      if (!view) {\n        return null;\n      }\n\n      return new _IndexPath2.default(view.layoutInfo.section, view.layoutInfo.index);\n    }\n    /**\n     * Triggers a layout invalidation, and updates the visible subviews.\n     * @param {Object} context - An invalidation context.\n     */\n\n  }, {\n    key: 'relayout',\n    value: function relayout() {\n      var _this4 = this;\n\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // Ignore relayouts while animating the scroll position\n\n      if (this._scrollAnimation) {\n        return;\n      } // If we already scheduled a relayout, extend the invalidation\n      // context so we coalesce multiple relayouts in the same frame.\n\n\n      if (this._invalidationContext) {\n        Object.assign(this._invalidationContext, context);\n        return;\n      }\n\n      this._invalidationContext = context;\n      this._relayoutRaf = (0, _raf2.default)(function () {\n        _this4._relayoutRaf = null;\n\n        _this4.relayoutNow();\n      });\n    }\n    /**\n     * Performs a relayout immediately. Prefer {@link relayout} over this method\n     * where possible, since it coalesces multiple layout passes in the same tick.\n     * @param {Object} [context] - An invalidation context\n     */\n\n  }, {\n    key: 'relayoutNow',\n    value: function relayoutNow() {\n      var _this5 = this;\n\n      var context = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this._invalidationContext || {}; // Cancel the scheduled relayout, since we're doing it now.\n\n      if (this._relayoutRaf) {\n        _raf2.default.cancel(this._relayoutRaf);\n\n        this._relayoutRaf = null;\n      } // Reset the invalidation context\n\n\n      this._invalidationContext = null; // Do nothing if we don't have a layout or content, or we are\n      // in the middle of an animated scroll transition.\n\n      if (!this.layout || !this._content || this._scrollAnimation) {\n        return;\n      }\n\n      var scrollAnchor = this._getScrollAnchor(); // Enable transitions if this is an animated relayout\n\n\n      if (context.animated) {\n        this._enableTransitions();\n      } // Trigger the beforeLayout hook, if provided\n\n\n      if (typeof context.beforeLayout === 'function') {\n        context.beforeLayout();\n      } // Validate the layout\n\n\n      this.layout.validate(context);\n      this.setContentSize(this.layout.getContentSize()); // Trigger the afterLayout hook, if provided\n\n      if (typeof context.afterLayout === 'function') {\n        context.afterLayout();\n      } // Adjust scroll position based on scroll anchor, and constrain.\n      // If the content changed, scroll to the top.\n\n\n      var visibleRect = this.getVisibleRect();\n\n      var restoredScrollAnchor = this._restoreScrollAnchor(scrollAnchor, context);\n\n      var contentOffsetX = context.contentChanged ? 0 : restoredScrollAnchor.x;\n      var contentOffsetY = context.contentChanged ? 0 : restoredScrollAnchor.y;\n      contentOffsetX = Math.max(0, Math.min(this.contentSize.width - visibleRect.width, contentOffsetX));\n      contentOffsetY = Math.max(0, Math.min(this.contentSize.height - visibleRect.height, contentOffsetY));\n\n      if (contentOffsetX !== visibleRect.x || contentOffsetY !== visibleRect.y) {\n        // If this is an animated relayout, we do not immediately scroll because it would be jittery.\n        // Save the difference between the current and new content offsets, and apply it to the\n        // individual content items instead. At the end of the animation, we'll reset and set the\n        // scroll offset for real. This ensures jitter-free animation since we don't need to sync\n        // the scroll animation and the content animation.\n        if (context.animated || !this._animatedContentOffset.isOrigin()) {\n          this._animatedContentOffset.x += visibleRect.x - contentOffsetX;\n          this._animatedContentOffset.y += visibleRect.y - contentOffsetY;\n          this.updateSubviews(context.contentChanged);\n        } else {\n          this.setContentOffset(new _Point2.default(contentOffsetX, contentOffsetY), context.contentChanged);\n        }\n      } else {\n        this.updateSubviews(context.contentChanged);\n      } // Apply layout infos, unless this is coming from an animated transaction\n\n\n      if (!(context.transaction && context.animated)) {\n        this._applyLayoutInfos();\n      } // Wait for animations, and apply the afterAnimation hook, if provided\n\n\n      if (context.animated) {\n        var done = function done() {\n          _this5._disableTransitions(); // Reset scroll position after animations (see above comment).\n\n\n          if (!_this5._animatedContentOffset.isOrigin()) {\n            // Get the content offset to scroll to, taking _animatedContentOffset into account.\n            var _getVisibleRect = _this5.getVisibleRect(),\n                x = _getVisibleRect.x,\n                y = _getVisibleRect.y;\n\n            _this5._resetAnimatedContentOffset();\n\n            _this5.setContentOffset(new _Point2.default(x, y));\n          } else {\n            // Make sure items are rendered in correct DOM order for accessibility\n            _this5.correctItemOrder();\n          }\n\n          if (typeof context.afterAnimation === 'function') {\n            context.afterAnimation();\n          }\n        };\n\n        setTimeout(done, this.transitionDuration);\n        return;\n      } else if (typeof context.afterAnimation === 'function') {\n        context.afterAnimation();\n      } // Make sure items are rendered in correct DOM order for accessibility\n\n\n      this.correctItemOrder();\n    }\n    /**\n     * Corrects DOM order of visible views to match item order of collection\n     */\n\n  }, {\n    key: 'correctItemOrder',\n    value: function correctItemOrder() {\n      if (this._scrolling) {\n        return;\n      }\n\n      var current = Array.from(this.inner.children);\n      var sortedVisibleViews = current.slice().sort(_utils.compareView); // no need to reparent if visibleViews order matches sortedVisibleViews order\n\n      if (sortedVisibleViews.every(function (view, index) {\n        return view === current[index];\n      })) {\n        return;\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = sortedVisibleViews[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var view = _step2.value;\n          this.inner.removeChild(view);\n          this.inner.addChild(view);\n        } // Flush updates if not in a transaction, otherwise that will happen at the end.\n\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      if (!this._transaction) {\n        this.inner.flushUpdates();\n      }\n    }\n  }, {\n    key: '_enableTransitions',\n    value: function _enableTransitions() {\n      var transition = 'none ' + this.transitionDuration + 'ms';\n      this.inner.css({\n        WebkitTransition: transition,\n        transition: transition\n      });\n    }\n  }, {\n    key: '_disableTransitions',\n    value: function _disableTransitions() {\n      this.inner.css({\n        WebkitTransition: '',\n        transition: ''\n      });\n    }\n  }, {\n    key: '_getScrollAnchor',\n    value: function _getScrollAnchor() {\n      if (!this.anchorScrollPosition) {\n        return null;\n      }\n\n      var visibleRect = this.getVisibleRect(); // Ask the delegate to provide a scroll anchor, if possible\n\n      if (this.delegate.getScrollAnchor) {\n        var indexPath = this.delegate.getScrollAnchor(visibleRect);\n\n        if (indexPath) {\n          var layoutInfo = this.layout.getLayoutInfo('item', indexPath.section, indexPath.index);\n          var corner = layoutInfo.rect.getCornerInRect(visibleRect);\n\n          if (corner) {\n            var key = this._content.getKey(layoutInfo.type, layoutInfo.section, layoutInfo.index);\n\n            var offset = layoutInfo.rect[corner].y - visibleRect.y;\n            return {\n              key: key,\n              layoutInfo: layoutInfo,\n              corner: corner,\n              offset: offset\n            };\n          }\n        }\n      } // No need to anchor the scroll position if it is at the top\n\n\n      if (visibleRect.y === 0 && !this.anchorScrollPositionAtTop) {\n        return null;\n      } // Find a view with a visible corner that has the smallest distance to the top of the collection view\n\n\n      var cornerAnchor = null;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this._visibleViews[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _step3$value = _slicedToArray(_step3.value, 2),\n              _key = _step3$value[0],\n              view = _step3$value[1];\n\n          var _layoutInfo = view.layoutInfo;\n\n          if (_layoutInfo && _layoutInfo.rect.area > 0) {\n            var _corner = _layoutInfo.rect.getCornerInRect(visibleRect);\n\n            if (_corner) {\n              var _offset = _layoutInfo.rect[_corner].y - visibleRect.y;\n\n              if (!cornerAnchor || _offset < cornerAnchor.offset) {\n                cornerAnchor = {\n                  key: _key,\n                  layoutInfo: _layoutInfo,\n                  corner: _corner,\n                  offset: _offset\n                };\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return cornerAnchor;\n    }\n  }, {\n    key: '_restoreScrollAnchor',\n    value: function _restoreScrollAnchor(scrollAnchor, context) {\n      var contentOffset = this.getVisibleRect();\n\n      if (scrollAnchor) {\n        var finalAnchor = context.transaction ? context.transaction.finalMap.get(scrollAnchor.key) : this.layout.getLayoutInfo(scrollAnchor.layoutInfo.type, scrollAnchor.layoutInfo.section, scrollAnchor.layoutInfo.index);\n\n        if (finalAnchor) {\n          var adjustment = finalAnchor.rect[scrollAnchor.corner].y - contentOffset.y - scrollAnchor.offset;\n          contentOffset.y += adjustment;\n        }\n      }\n\n      return contentOffset;\n    }\n  }, {\n    key: 'getVisibleRect',\n    value: function getVisibleRect() {\n      var contentOffset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.contentOffset;\n      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.size;\n      var x = contentOffset.x - this._animatedContentOffset.x;\n      var y = contentOffset.y - this._animatedContentOffset.y;\n      return new _Rect2.default(x, y, size.width, size.height);\n    }\n  }, {\n    key: 'getVisibleLayoutInfos',\n    value: function getVisibleLayoutInfos() {\n      return this._getLayoutInfoMap(this.getVisibleRect());\n    }\n  }, {\n    key: '_getLayoutInfoMap',\n    value: function _getLayoutInfoMap(rect) {\n      var copy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var layoutInfos = this.layout.getVisibleLayoutInfos(rect);\n      var map = new Map();\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = layoutInfos[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var layoutInfo = _step4.value;\n\n          if (copy) {\n            layoutInfo = layoutInfo.copy();\n          }\n\n          var key = this._content.getKey(layoutInfo.type, layoutInfo.section, layoutInfo.index);\n\n          map.set(key, layoutInfo);\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return map;\n    }\n  }, {\n    key: 'updateSubviews',\n    value: function updateSubviews() {\n      var _this6 = this;\n\n      var forceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n      if (!this._content) {\n        return;\n      }\n\n      var visibleLayoutInfos = this.getVisibleLayoutInfos();\n      var currentlyVisible = this._visibleViews;\n      var toAdd = void 0,\n          toRemove = void 0; // If this is a force update, remove and re-add all views.\n      // Otherwise, find and update the diff.\n\n      if (forceUpdate) {\n        toAdd = visibleLayoutInfos;\n        toRemove = currentlyVisible;\n      } else {\n        // We are done if the sets are equal\n        var _difference = (0, _utils.difference)(currentlyVisible, visibleLayoutInfos);\n\n        toAdd = _difference.toAdd;\n        toRemove = _difference.toRemove;\n\n        if (toAdd.size === 0 && toRemove.size === 0) {\n          if (this._transaction) {\n            this._applyLayoutInfos(visibleLayoutInfos);\n          }\n\n          return;\n        }\n      } // Track views that should be removed. They are not removed from\n      // the DOM immediately, since we may reuse and need to re-insert\n      // them back into the DOM anyway.\n\n\n      var removed = new Set();\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = toRemove.keys()[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var key = _step5.value;\n\n          var view = this._visibleViews.get(key);\n\n          if (view) {\n            removed.add(view);\n\n            this._visibleViews.delete(key); // If we are in the middle of a transaction, wait until the end\n            // of the animations to remove the views from the DOM. Also means\n            // we can't reuse those views immediately.\n\n\n            if (this._transaction) {\n              this._transaction.toRemove.set(key, view);\n            } else {\n              this.reuseView(view);\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      var needsSizeUpdate = false;\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = toAdd.keys()[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var _key2 = _step6.value;\n          var layoutInfo = visibleLayoutInfos.get(_key2);\n          var _view = null; // We need to recompute view sizes if we only\n          // have an estimated size for this row.\n\n          if (layoutInfo.estimatedSize) {\n            needsSizeUpdate = true;\n          } // If we're in a transaction, and a layout change happens\n          // during the animations such that a view that was going\n          // to be removed is now not, we don't create a new view\n          // since the old one is still in the DOM, marked as toRemove.\n\n\n          if (this._transaction) {\n            // if transaction, get initial layout attributes for the animation\n            if (this._transaction.initialLayoutInfo.has(_key2)) {\n              layoutInfo = this._transaction.initialLayoutInfo.get(_key2);\n            }\n\n            if (this._transaction.toRemove.has(_key2)) {\n              _view = this._transaction.toRemove.get(_key2);\n\n              this._transaction.toRemove.delete(_key2);\n\n              this._applyLayoutInfo(_view, layoutInfo);\n            }\n          }\n\n          if (!_view) {\n            // Create or reuse a view for this row\n            _view = this.getReusableView(layoutInfo); // Add the view to the DOM if needed\n\n            if (!removed.has(_view)) {\n              this.inner.addChild(_view);\n            }\n          }\n\n          this._visibleViews.set(_key2, _view);\n\n          removed.delete(_view);\n        } // Remove the remaining rows to delete from the DOM\n\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      if (!this._transaction) {\n        this.removeViews(removed);\n      }\n\n      this.inner.flushUpdates(function () {\n        // If we're in a transaction, apply animations to visible views\n        // and \"to be removed\" views, which animate off screen.\n        if (_this6._transaction) {\n          _this6._applyLayoutInfos();\n        } // If we need a height update, wait until the next frame\n        // so that the browser has time to do layout.\n\n\n        if (needsSizeUpdate) {\n          _this6.relayout();\n        }\n      });\n    }\n  }, {\n    key: '_applyLayoutInfo',\n    value: function _applyLayoutInfo(view, layoutInfo) {\n      if (!this._animatedContentOffset.isOrigin()) {\n        layoutInfo = layoutInfo.copy();\n        layoutInfo.rect.x += this._animatedContentOffset.x;\n        layoutInfo.rect.y += this._animatedContentOffset.y;\n      }\n\n      view.applyLayoutInfo(layoutInfo);\n    }\n  }, {\n    key: '_applyLayoutInfos',\n    value: function _applyLayoutInfos() {\n      // Apply layout infos to visible views\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = this._visibleViews[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var _step7$value = _slicedToArray(_step7.value, 2),\n              key = _step7$value[0],\n              _view3 = _step7$value[1];\n\n          if (this._transaction && this._transaction.initialLayoutInfo.has(key)) {\n            _view3.forceStyleUpdate();\n          }\n\n          var _cur2 = _view3.layoutInfo;\n\n          var _layoutInfo3 = this.layout.getLayoutInfo(_cur2.type, _cur2.section, _cur2.index);\n\n          this._applyLayoutInfo(_view3, _layoutInfo3);\n        } // Apply final layout infos for views that will be removed\n\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      if (this._transaction) {\n        var _iteratorNormalCompletion8 = true;\n        var _didIteratorError8 = false;\n        var _iteratorError8 = undefined;\n\n        try {\n          for (var _iterator8 = this._transaction.toRemove.values()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n            var view = _step8.value;\n            var cur = view.layoutInfo;\n            var layoutInfo = this.layout.getLayoutInfo(cur.type, cur.section, cur.index);\n\n            this._applyLayoutInfo(view, layoutInfo);\n          }\n        } catch (err) {\n          _didIteratorError8 = true;\n          _iteratorError8 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion8 && _iterator8.return) {\n              _iterator8.return();\n            }\n          } finally {\n            if (_didIteratorError8) {\n              throw _iteratorError8;\n            }\n          }\n        }\n\n        var _iteratorNormalCompletion9 = true;\n        var _didIteratorError9 = false;\n        var _iteratorError9 = undefined;\n\n        try {\n          for (var _iterator9 = this._transaction.removed.values()[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n            var _view2 = _step9.value;\n            var _cur = _view2.layoutInfo;\n\n            var _layoutInfo2 = this.layout.getFinalLayoutInfo(_cur.type, _cur.section, _cur.index);\n\n            this._applyLayoutInfo(_view2, _layoutInfo2);\n          }\n        } catch (err) {\n          _didIteratorError9 = true;\n          _iteratorError9 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion9 && _iterator9.return) {\n              _iterator9.return();\n            }\n          } finally {\n            if (_didIteratorError9) {\n              throw _iteratorError9;\n            }\n          }\n        }\n      }\n    }\n  }, {\n    key: 'reuseView',\n    value: function reuseView(view) {\n      view.prepareForReuse();\n\n      this._reusableViews[view.viewType].push(view);\n    }\n  }, {\n    key: 'removeViews',\n    value: function removeViews(toRemove) {\n      var _iteratorNormalCompletion10 = true;\n      var _didIteratorError10 = false;\n      var _iteratorError10 = undefined;\n\n      try {\n        for (var _iterator10 = toRemove[Symbol.iterator](), _step10; !(_iteratorNormalCompletion10 = (_step10 = _iterator10.next()).done); _iteratorNormalCompletion10 = true) {\n          var view = _step10.value;\n          this.inner.removeChild(view);\n        }\n      } catch (err) {\n        _didIteratorError10 = true;\n        _iteratorError10 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion10 && _iterator10.return) {\n            _iterator10.return();\n          }\n        } finally {\n          if (_didIteratorError10) {\n            throw _iteratorError10;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'updateItemSize',\n    value: function updateItemSize(indexPath) {\n      // TODO: we should be able to invalidate a single index path\n      if (!this.layout.updateItemSize) {\n        return;\n      } // If the scroll position is currently animating, add the update\n      // to a queue to be processed after the animation is complete.\n\n\n      if (this._scrollAnimation) {\n        this._sizeUpdateQueue.addIndexPath(indexPath);\n\n        return;\n      }\n\n      var changed = this.layout.updateItemSize(indexPath);\n\n      if (changed) {\n        this.relayout();\n      }\n    }\n  }, {\n    key: 'setContentOffset',\n    value: function setContentOffset(contentOffset) {\n      var forceUpdate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var visibleRect = this.getVisibleRect(contentOffset);\n      var shouldInvalidate = this.layout && this.layout.shouldInvalidate(visibleRect);\n\n      this._resetAnimatedContentOffset();\n\n      var ret = _get(CollectionView.prototype.__proto__ || Object.getPrototypeOf(CollectionView.prototype), 'setContentOffset', this).call(this, contentOffset);\n\n      if (shouldInvalidate) {\n        this.relayout({\n          offsetChanged: true\n        });\n      } else {\n        this.updateSubviews(forceUpdate);\n        this.correctItemOrder();\n      }\n\n      return ret;\n    }\n  }, {\n    key: 'scrollEnded',\n    value: function scrollEnded() {\n      _get(CollectionView.prototype.__proto__ || Object.getPrototypeOf(CollectionView.prototype), 'scrollEnded', this).call(this);\n\n      this.correctItemOrder();\n    }\n  }, {\n    key: '_resetAnimatedContentOffset',\n    value: function _resetAnimatedContentOffset() {\n      // Reset the animated content offset of subviews. See comment in relayoutNow for details.\n      if (!this._animatedContentOffset.isOrigin()) {\n        this._animatedContentOffset = new _Point2.default(0, 0);\n\n        this._applyLayoutInfos();\n      }\n    }\n    /**\n     * Scrolls the item at the given IndexPath into view, optionally with an animation.\n     * @param {IndexPath} indexPath - The IndexPath to scroll into view\n     * @param {number} [duration=300ms] - The duration of the scroll animation\n     */\n\n  }, {\n    key: 'scrollToItem',\n    value: function scrollToItem(indexPath) {\n      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300;\n\n      if (!indexPath) {\n        return;\n      }\n\n      var layoutInfo = this.layout.getLayoutInfo('item', indexPath.section, indexPath.index);\n\n      if (!layoutInfo) {\n        return;\n      }\n\n      var offsetX = layoutInfo.rect.x;\n      var offsetY = layoutInfo.rect.y;\n      var x = this._contentOffset.x;\n      var y = this._contentOffset.y;\n      var maxX = x + this.size.width;\n      var maxY = y + this.size.height;\n\n      if (offsetX <= x) {\n        x = offsetX;\n      } else if (offsetX + layoutInfo.rect.width > maxX) {\n        x += offsetX + layoutInfo.rect.width - maxX;\n      }\n\n      if (offsetY <= y) {\n        y = offsetY;\n      } else if (offsetY + layoutInfo.rect.height > maxY) {\n        y += offsetY + layoutInfo.rect.height - maxY;\n      }\n\n      return this.scrollTo(new _Point2.default(x, y), duration);\n    }\n    /**\n     * Performs an animated scroll to the given offset.\n     * @param {Point} offset - The offset to scroll to\n     * @param {number} [duration=300ms] - The duration of the animation\n     * @return {Promise} a promise that resolves when the animation is complete\n     */\n\n  }, {\n    key: 'scrollTo',\n    value: function scrollTo(offset) {\n      var _this7 = this;\n\n      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 300; // Cancel the current scroll animation\n\n      if (this._scrollAnimation) {\n        this._scrollAnimation.cancel();\n\n        this._scrollAnimation = null;\n      } // Set the content offset synchronously if the duration is zero\n\n\n      if (duration <= 0 || this.contentOffset.equals(offset)) {\n        this.setContentOffset(offset);\n        return Promise.resolve();\n      }\n\n      this._scrollAnimation = (0, _tween2.default)(this._contentOffset, offset, duration, _tween2.default.easeOut, function (offset) {\n        _this7.setContentOffset(offset);\n      });\n\n      this._scrollAnimation.then(function () {\n        _this7._scrollAnimation = null; // Process view size updates that occurred during the animation.\n        // Only views that are still visible will be actually updated.\n\n        var _iteratorNormalCompletion11 = true;\n        var _didIteratorError11 = false;\n        var _iteratorError11 = undefined;\n\n        try {\n          for (var _iterator11 = _this7._sizeUpdateQueue[Symbol.iterator](), _step11; !(_iteratorNormalCompletion11 = (_step11 = _iterator11.next()).done); _iteratorNormalCompletion11 = true) {\n            var indexPath = _step11.value;\n\n            _this7.updateItemSize(indexPath);\n          }\n        } catch (err) {\n          _didIteratorError11 = true;\n          _iteratorError11 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion11 && _iterator11.return) {\n              _iterator11.return();\n            }\n          } finally {\n            if (_didIteratorError11) {\n              throw _iteratorError11;\n            }\n          }\n        }\n\n        _this7._sizeUpdateQueue.clear();\n\n        _this7.relayout();\n\n        _this7._processTransactionQueue();\n      });\n\n      return this._scrollAnimation;\n    }\n  }, {\n    key: 'convertPoint',\n    value: function convertPoint(point) {\n      var rect = this.getRect();\n      return new _Point2.default(this.contentOffset.x + point.x - rect.x, this.contentOffset.y + point.y - rect.y);\n    }\n  }, {\n    key: '_insertItem',\n    value: function _insertItem(indexPath, animated) {\n      var item = this.dataSource.getItem(indexPath.section, indexPath.index);\n\n      this._runTransaction(this._performInsertItem.bind(this, item, indexPath.copy()), animated);\n    }\n  }, {\n    key: '_performInsertItem',\n    value: function _performInsertItem(item, indexPath) {\n      this._content.insertItem(item, indexPath);\n\n      this.layout.itemInserted(indexPath);\n    }\n  }, {\n    key: '_removeItem',\n    value: function _removeItem(indexPath, animated) {\n      this._runTransaction(this._performRemoveItem.bind(this, indexPath.copy()), animated);\n    }\n  }, {\n    key: '_performRemoveItem',\n    value: function _performRemoveItem(indexPath) {\n      this._content.removeItem(indexPath);\n\n      this.layout.itemRemoved(indexPath);\n    }\n  }, {\n    key: '_moveItem',\n    value: function _moveItem(from, to, animated) {\n      this._runTransaction(this._performMoveItem.bind(this, from.copy(), to.copy()), animated);\n    }\n  }, {\n    key: '_performMoveItem',\n    value: function _performMoveItem(from, to) {\n      this._content.moveItem(from, to);\n\n      this.layout.itemMoved(from, to);\n    }\n  }, {\n    key: '_reloadItem',\n    value: function _reloadItem(indexPath) {\n      var animated = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var item = this.dataSource.getItem(indexPath.section, indexPath.index);\n\n      this._runTransaction(this._performReloadItem.bind(this, indexPath.copy(), item, animated), animated);\n    }\n  }, {\n    key: '_performReloadItem',\n    value: function _performReloadItem(indexPath, item, animated) {\n      // We can reuse the same view (and just reload it's content) if\n      // the reload is not animated, and the view type remains the same.\n      var retainID = !animated;\n\n      if (retainID) {\n        retainID = this._reloadItemViewContent(indexPath, item);\n      }\n\n      this._content.replaceItem(indexPath, item, retainID);\n\n      this.layout.itemReplaced(indexPath);\n    }\n  }, {\n    key: '_reloadItemViewContent',\n    value: function _reloadItemViewContent(indexPath, item) {\n      var view = this.getItemView(indexPath);\n\n      if (!view) {\n        return false;\n      } // Check that the view type remains the same after the content update.\n\n\n      var _getReuseType3 = this._getReuseType(view.layoutInfo, item),\n          reuseType = _getReuseType3.reuseType;\n\n      if (view.viewType !== reuseType) {\n        return false;\n      }\n\n      view.setContent(item);\n      return true;\n    }\n  }, {\n    key: '_insertSection',\n    value: function _insertSection(section, animated) {\n      var items = [];\n      var count = this.dataSource.getSectionLength(section);\n\n      for (var i = 0; i < count; i++) {\n        items.push(this.dataSource.getItem(section, i));\n      }\n\n      this._runTransaction(this._performInsertSection.bind(this, section, items), animated);\n    }\n  }, {\n    key: '_performInsertSection',\n    value: function _performInsertSection(section, items) {\n      this._content.insertSection(section, items);\n\n      this.layout.sectionInserted(section);\n    }\n  }, {\n    key: '_removeSection',\n    value: function _removeSection(section, animated) {\n      this._runTransaction(this._performRemoveSection.bind(this, section), animated);\n    }\n  }, {\n    key: '_performRemoveSection',\n    value: function _performRemoveSection(section) {\n      this._content.removeSection(section);\n\n      this.layout.sectionRemoved(section);\n    }\n  }, {\n    key: '_moveSection',\n    value: function _moveSection(fromSection, toSection, animated) {\n      if (fromSection !== toSection) {\n        this._runTransaction(this._performMoveSection.bind(this, fromSection, toSection), animated);\n      }\n    }\n  }, {\n    key: '_performMoveSection',\n    value: function _performMoveSection(fromSection, toSection) {\n      this._content.moveSection(fromSection, toSection);\n\n      this.layout.sectionMoved(fromSection, toSection);\n    }\n  }, {\n    key: '_reloadSection',\n    value: function _reloadSection(section, animated) {\n      var items = [];\n      var count = this.dataSource.getSectionLength(section);\n\n      for (var i = 0; i < count; i++) {\n        items.push(this.dataSource.getItem(section, i));\n      }\n\n      this._runTransaction(this._performReloadSection.bind(this, section, items), animated);\n    }\n  }, {\n    key: '_performReloadSection',\n    value: function _performReloadSection(section, items) {\n      this._content.replaceSection(section, items);\n\n      this.layout.sectionReplaced(section);\n    }\n  }, {\n    key: '_runTransaction',\n    value: function _runTransaction(action, animated) {\n      this._startTransaction();\n\n      this._nextTransaction.actions.push(action);\n\n      this._endTransaction(animated);\n    }\n  }, {\n    key: '_startTransaction',\n    value: function _startTransaction() {\n      if (!this._nextTransaction) {\n        this._nextTransaction = new _Transaction2.default();\n      }\n\n      this._nextTransaction.level++;\n    }\n  }, {\n    key: '_endTransaction',\n    value: function _endTransaction(animated) {\n      if (!this._nextTransaction) {\n        return false;\n      } // Save whether the transaction should be animated.\n\n\n      if (animated != null) {\n        this._nextTransaction.animated = animated;\n      } // If we haven't reached level 0, we are still in a\n      // nested transaction. Wait for the parent to end.\n\n\n      if (--this._nextTransaction.level > 0) {\n        return false;\n      } // Do nothing for empty transactions\n\n\n      if (this._nextTransaction.actions.length === 0) {\n        this._nextTransaction = null;\n        return false;\n      } // Default animations to true\n\n\n      if (this._nextTransaction.animated == null) {\n        this._nextTransaction.animated = true;\n      } // Enqueue the transaction\n\n\n      this._transactionQueue.push(this._nextTransaction);\n\n      this._nextTransaction = null;\n\n      this._processTransactionQueue();\n\n      return true;\n    }\n  }, {\n    key: '_processTransactionQueue',\n    value: function _processTransactionQueue() {\n      // If the current transaction is animating, wait until the end\n      // to process the next transaction.\n      if (this._transaction || this._scrollAnimation) {\n        return;\n      }\n\n      var next = this._transactionQueue.shift();\n\n      if (next) {\n        this._performTransaction(next);\n      }\n    }\n  }, {\n    key: '_getContentRect',\n    value: function _getContentRect() {\n      return new _Rect2.default(0, 0, this.contentSize.width, this.contentSize.height);\n    }\n  }, {\n    key: '_performTransaction',\n    value: function _performTransaction(transaction) {\n      var _this8 = this;\n\n      this._transaction = transaction;\n      this.relayoutNow({\n        transaction: transaction,\n        animated: transaction.animated,\n        beforeLayout: function beforeLayout() {\n          // Get the initial layout infos for all views before the updates\n          // so we can figure out which views to add and remove.\n          transaction.initialMap = _this8._getLayoutInfoMap(_this8._getContentRect(), true); // Apply the actions that occurred during this transaction\n\n          var _iteratorNormalCompletion12 = true;\n          var _didIteratorError12 = false;\n          var _iteratorError12 = undefined;\n\n          try {\n            for (var _iterator12 = transaction.actions[Symbol.iterator](), _step12; !(_iteratorNormalCompletion12 = (_step12 = _iterator12.next()).done); _iteratorNormalCompletion12 = true) {\n              var action = _step12.value;\n              action();\n            }\n          } catch (err) {\n            _didIteratorError12 = true;\n            _iteratorError12 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion12 && _iterator12.return) {\n                _iterator12.return();\n              }\n            } finally {\n              if (_didIteratorError12) {\n                throw _iteratorError12;\n              }\n            }\n          }\n        },\n        afterLayout: function afterLayout() {\n          // Get the final layout infos after the updates\n          transaction.finalMap = _this8._getLayoutInfoMap(_this8._getContentRect());\n\n          _this8._setupTransactionAnimations(transaction);\n\n          if (!transaction.animated) {\n            _this8._transaction = null;\n          }\n        },\n        afterAnimation: function afterAnimation() {\n          // Remove and reuse views when animations are done\n          if (transaction.toRemove.size > 0 || transaction.removed.size > 0) {\n            var _iteratorNormalCompletion13 = true;\n            var _didIteratorError13 = false;\n            var _iteratorError13 = undefined;\n\n            try {\n              for (var _iterator13 = (0, _utils.concatIterators)(transaction.toRemove.values(), transaction.removed.values())[Symbol.iterator](), _step13; !(_iteratorNormalCompletion13 = (_step13 = _iterator13.next()).done); _iteratorNormalCompletion13 = true) {\n                var view = _step13.value;\n\n                _this8.inner.removeChild(view);\n\n                _this8.reuseView(view);\n              }\n            } catch (err) {\n              _didIteratorError13 = true;\n              _iteratorError13 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion13 && _iterator13.return) {\n                  _iterator13.return();\n                }\n              } finally {\n                if (_didIteratorError13) {\n                  throw _iteratorError13;\n                }\n              }\n            }\n\n            _this8.inner.flushUpdates();\n          }\n\n          _this8._transaction = null;\n\n          _this8._processTransactionQueue();\n        }\n      });\n    }\n  }, {\n    key: '_setupTransactionAnimations',\n    value: function _setupTransactionAnimations(transaction) {\n      var initialMap = transaction.initialMap,\n          finalMap = transaction.finalMap; // Store initial and final layout infos for animations\n\n      var _iteratorNormalCompletion14 = true;\n      var _didIteratorError14 = false;\n      var _iteratorError14 = undefined;\n\n      try {\n        for (var _iterator14 = initialMap[Symbol.iterator](), _step14; !(_iteratorNormalCompletion14 = (_step14 = _iterator14.next()).done); _iteratorNormalCompletion14 = true) {\n          var _step14$value = _slicedToArray(_step14.value, 2),\n              key = _step14$value[0],\n              layoutInfo = _step14$value[1];\n\n          if (finalMap.has(key)) {\n            // Remap section and index to final position\n            var finalLayoutInfo = finalMap.get(key);\n            layoutInfo.section = finalLayoutInfo.section;\n            layoutInfo.index = finalLayoutInfo.index; // Store the initial layout info for use during animations.\n\n            transaction.initialLayoutInfo.set(key, layoutInfo);\n          } else {\n            // This view was removed. Store the layout info for use\n            // in Layout#getFinalLayoutInfo during animations.\n            var k = [layoutInfo.type, layoutInfo.section, layoutInfo.index].join(':');\n            transaction.finalLayoutInfo.set(k, layoutInfo);\n          }\n        } // Get initial layout infos for views that were added\n\n      } catch (err) {\n        _didIteratorError14 = true;\n        _iteratorError14 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion14 && _iterator14.return) {\n            _iterator14.return();\n          }\n        } finally {\n          if (_didIteratorError14) {\n            throw _iteratorError14;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion15 = true;\n      var _didIteratorError15 = false;\n      var _iteratorError15 = undefined;\n\n      try {\n        for (var _iterator15 = finalMap[Symbol.iterator](), _step15; !(_iteratorNormalCompletion15 = (_step15 = _iterator15.next()).done); _iteratorNormalCompletion15 = true) {\n          var _step15$value = _slicedToArray(_step15.value, 2),\n              key = _step15$value[0],\n              layoutInfo = _step15$value[1];\n\n          if (!initialMap.has(key)) {\n            var initialLayoutInfo = this.layout.getInitialLayoutInfo(layoutInfo.type, layoutInfo.section, layoutInfo.index);\n            transaction.initialLayoutInfo.set(key, initialLayoutInfo);\n          }\n        } // Figure out which views were removed.\n\n      } catch (err) {\n        _didIteratorError15 = true;\n        _iteratorError15 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion15 && _iterator15.return) {\n            _iterator15.return();\n          }\n        } finally {\n          if (_didIteratorError15) {\n            throw _iteratorError15;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion16 = true;\n      var _didIteratorError16 = false;\n      var _iteratorError16 = undefined;\n\n      try {\n        for (var _iterator16 = this._visibleViews[Symbol.iterator](), _step16; !(_iteratorNormalCompletion16 = (_step16 = _iterator16.next()).done); _iteratorNormalCompletion16 = true) {\n          var _step16$value = _slicedToArray(_step16.value, 2),\n              key = _step16$value[0],\n              view = _step16$value[1];\n\n          if (finalMap.has(key)) {\n            // Remap section and index to final position\n            var _finalLayoutInfo = finalMap.get(key);\n\n            view.layoutInfo.section = _finalLayoutInfo.section;\n            view.layoutInfo.index = _finalLayoutInfo.index;\n          } else {\n            transaction.removed.set(key, view);\n\n            this._visibleViews.delete(key); // In case something weird happened, where we have a view but no\n            // initial layout info, use the one attached to the view.\n\n\n            var _k = [view.layoutInfo.type, view.layoutInfo.section, view.layoutInfo.index].join(':');\n\n            if (!transaction.finalLayoutInfo.has(_k)) {\n              transaction.finalLayoutInfo.set(_k, view.layoutInfo);\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError16 = true;\n        _iteratorError16 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion16 && _iterator16.return) {\n            _iterator16.return();\n          }\n        } finally {\n          if (_didIteratorError16) {\n            throw _iteratorError16;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'dataSource',\n    get: function get() {\n      return this._dataSource;\n    }\n    /**\n     * Set the collection view's data source\n     * @type {DataSource}\n     */\n    ,\n    set: function set(dataSource) {\n      this._setDataSource(dataSource);\n    }\n  }, {\n    key: 'layout',\n    get: function get() {\n      return this._layout;\n    }\n    /**\n     * Set the collection view's layout\n     * @type {Layout}\n     */\n    ,\n    set: function set(layout) {\n      this.setLayout(layout);\n    }\n  }, {\n    key: 'visibleViews',\n    get: function get() {\n      return Array.from(this._visibleViews.values());\n    }\n  }]);\n\n  return CollectionView;\n}(_ScrollView3.default);\n\nexports.default = CollectionView;","map":null,"metadata":{},"sourceType":"script"}