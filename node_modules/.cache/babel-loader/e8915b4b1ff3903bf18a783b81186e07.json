{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = proxy;\n\nvar _react = require('react');\n/**\n * Creates a proxy object containing all of the methods of the input object\n * bound to that object, such that calling them still applies to the input\n * object. This allows combining the methods of two objects without mutating\n * either one.\n */\n\n\nfunction proxy(obj) {\n  var res = {};\n\n  if (!obj) {\n    return res;\n  }\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = getAllPropertyNames(obj)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n\n      if (typeof obj[key] === 'function') {\n        res[key] = obj[key].bind(obj);\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return res;\n}\n\nfunction getAllPropertyNames(obj) {\n  var props = [];\n\n  do {\n    props = props.concat(Object.getOwnPropertyNames(obj));\n  } while ((obj = Object.getPrototypeOf(obj)) && obj !== Object.prototype && obj !== _react.Component.prototype);\n\n  return props;\n}","map":null,"metadata":{},"sourceType":"script"}