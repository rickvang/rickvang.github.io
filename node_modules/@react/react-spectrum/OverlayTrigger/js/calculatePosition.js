'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.calculatePositionInternal = calculatePositionInternal;
exports.default = calculatePosition;

var _style = require('dom-helpers/style');

var _style2 = _interopRequireDefault(_style);

var _offset = require('dom-helpers/query/offset');

var _offset2 = _interopRequireDefault(_offset);

var _position = require('dom-helpers/query/position');

var _position2 = _interopRequireDefault(_position);

var _scrollLeft = require('dom-helpers/query/scrollLeft');

var _scrollLeft2 = _interopRequireDefault(_scrollLeft);

var _scrollTop = require('dom-helpers/query/scrollTop');

var _scrollTop2 = _interopRequireDefault(_scrollTop);

var _ownerDocument = require('dom-helpers/ownerDocument');

var _ownerDocument2 = _interopRequireDefault(_ownerDocument);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var AXIS = {
  top: 'top',
  bottom: 'top',
  left: 'left',
  right: 'left'
};

var FLIPPED_DIRECTION = {
  top: 'bottom',
  bottom: 'top',
  left: 'right',
  right: 'left'
};

var CROSS_AXIS = {
  top: 'left',
  left: 'top'
};

var AXIS_SIZE = {
  top: 'height',
  left: 'width'
};

var PARSED_PLACEMENT_CACHE = {};

function getContainerDimensions(containerNode) {
  var width = void 0,
      height = void 0,
      top = 0,
      left = 0;
  var scroll = {};

  var containerDOMNode = _reactDom2.default.findDOMNode(containerNode);

  if (containerDOMNode.tagName === 'BODY') {
    width = window.innerWidth;
    height = window.innerHeight;

    scroll.top = (0, _scrollTop2.default)((0, _ownerDocument2.default)(containerDOMNode).documentElement) || (0, _scrollTop2.default)(containerDOMNode);
    scroll.left = (0, _scrollLeft2.default)((0, _ownerDocument2.default)(containerDOMNode).documentElement) || (0, _scrollLeft2.default)(containerDOMNode);
  } else {
    var _getOffset = (0, _offset2.default)(containerDOMNode);

    width = _getOffset.width;
    height = _getOffset.height;
    top = _getOffset.top;
    left = _getOffset.left;

    scroll.top = (0, _scrollTop2.default)(containerDOMNode);
    scroll.left = (0, _scrollLeft2.default)(containerDOMNode);
  }

  return { width: width, height: height, scroll: scroll, top: top, left: left };
}

function getDelta(axis, offset, size, containerDimensions, padding) {
  var containerScroll = containerDimensions.scroll[axis];
  var containerHeight = containerDimensions[AXIS_SIZE[axis]];

  var startEdgeOffset = offset - padding - containerScroll;
  var endEdgeOffset = offset + padding - containerScroll + size;

  if (startEdgeOffset < 0) {
    return -startEdgeOffset;
  } else if (endEdgeOffset > containerHeight) {
    return Math.max(containerHeight - endEdgeOffset, -startEdgeOffset);
  } else {
    return 0;
  }
}

function shouldFlip(axis, offset, size, padding, placement, flipContainerDimensions, containerOffsetWithBoundary) {
  var containerScroll = flipContainerDimensions.scroll[axis];
  var containerHeight = flipContainerDimensions[AXIS_SIZE[axis]];

  var startEdgeOffset = containerOffsetWithBoundary[axis] + offset - padding - containerScroll;
  var endEdgeOffset = containerOffsetWithBoundary[axis] + offset + padding - containerScroll + size;

  if (startEdgeOffset < 0 && (placement === 'top' || placement === 'left')) {
    return true;
  } else if (endEdgeOffset > containerHeight && (placement === 'bottom' || placement === 'right')) {
    return true;
  } else {
    return false;
  }
}

function getMargins(node) {
  var style = window.getComputedStyle(node);
  return {
    top: parseInt(style.marginTop, 10) || 0,
    bottom: parseInt(style.marginBottom, 10) || 0,
    left: parseInt(style.marginLeft, 10) || 0,
    right: parseInt(style.marginRight, 10) || 0
  };
}

function parsePlacement(input) {
  if (PARSED_PLACEMENT_CACHE[input]) {
    return PARSED_PLACEMENT_CACHE[input];
  }

  var _input$split = input.split(' '),
      _input$split2 = _slicedToArray(_input$split, 2),
      placement = _input$split2[0],
      crossPlacement = _input$split2[1];

  var axis = AXIS[placement] || 'right';
  var crossAxis = CROSS_AXIS[axis];

  if (!AXIS[crossPlacement]) {
    crossPlacement = 'center';
  }

  var size = AXIS_SIZE[axis];
  var crossSize = AXIS_SIZE[crossAxis];
  PARSED_PLACEMENT_CACHE[input] = { placement: placement, crossPlacement: crossPlacement, axis: axis, crossAxis: crossAxis, size: size, crossSize: crossSize };
  return PARSED_PLACEMENT_CACHE[input];
}

function computePosition(childOffset, containerDimensions, overlaySize, placementInfo, offset, crossOffset) {
  var placement = placementInfo.placement,
      crossPlacement = placementInfo.crossPlacement,
      axis = placementInfo.axis,
      crossAxis = placementInfo.crossAxis,
      size = placementInfo.size,
      crossSize = placementInfo.crossSize;

  var position = {};

  position[crossAxis] = childOffset[crossAxis] + crossOffset;
  if (crossPlacement === 'center') {
    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;
  } else if (crossPlacement !== crossAxis) {
    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];
  }

  // Ensure overlay sticks to target(ignore for overlays smaller than target)
  if (childOffset[crossSize] < overlaySize[crossSize]) {
    var positionForPositiveSideOverflow = Math.min(position[crossAxis], childOffset[crossAxis]);
    position[crossAxis] = Math.max(positionForPositiveSideOverflow, childOffset[crossAxis] - overlaySize[crossSize] + childOffset[crossSize]);
  }

  if (placement === axis) {
    position[axis] = childOffset[axis] - overlaySize[size] + offset;
  } else {
    position[axis] = childOffset[axis] + childOffset[size] + offset;
  }

  return position;
}

function calculatePositionInternal(placementInput, containerDimensions, childOffset, overlaySize, margins, padding, flip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset) {
  var placementInfo = parsePlacement(placementInput);
  var _placementInfo = placementInfo,
      axis = _placementInfo.axis,
      size = _placementInfo.size,
      crossAxis = _placementInfo.crossAxis,
      crossSize = _placementInfo.crossSize,
      placement = _placementInfo.placement,
      crossPlacement = _placementInfo.crossPlacement;

  var position = computePosition(childOffset, containerDimensions, overlaySize, placementInfo, offset, crossOffset);
  var normalizedOffset = offset;

  // First check if placement should be flipped
  if (flip && shouldFlip(axis, position[axis], overlaySize[size], padding, placement, boundaryDimensions, containerOffsetWithBoundary)) {
    var flippedPlacementInfo = parsePlacement(FLIPPED_DIRECTION[placement] + ' ' + crossPlacement);
    var _axis = flippedPlacementInfo.axis,
        _size = flippedPlacementInfo.size;

    var flippedPosition = computePosition(childOffset, containerDimensions, overlaySize, flippedPlacementInfo, -1 * offset, crossOffset);

    // Check if flipped placement has enough space otherwise flip is not possible
    if (!shouldFlip(_axis, flippedPosition[_axis], overlaySize[_size], padding, FLIPPED_DIRECTION[placement], boundaryDimensions, containerOffsetWithBoundary)) {
      placementInfo = flippedPlacementInfo;
      position = flippedPosition;
      normalizedOffset = -1 * offset;
    }
  }

  var delta = getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
  position[crossAxis] += delta;

  var maxHeight = Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top - containerOffsetWithBoundary.top - position.top - margins.top - margins.bottom - padding);
  overlaySize.height = Math.min(overlaySize.height, maxHeight);

  position = computePosition(childOffset, containerDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset);
  delta = delta = getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);

  position[crossAxis] += delta;

  var arrowPosition = {};
  arrowPosition[crossAxis] = childOffset[crossSize] > overlaySize[crossSize] ? null : childOffset[crossAxis] - position[crossAxis] + childOffset[crossSize] / 2;

  return {
    positionLeft: position.left,
    positionTop: position.top,
    maxHeight: maxHeight,
    arrowOffsetLeft: arrowPosition.left,
    arrowOffsetTop: arrowPosition.top,
    placement: placementInfo.placement
  };
}

function calculatePosition(placementInput, overlayNode, target, container, padding, flip, boundariesElement, offset, crossOffset) {
  var isBodyContainer = container.tagName === 'BODY';
  var childOffset = isBodyContainer ? (0, _offset2.default)(target) : (0, _position2.default)(target, container);

  if (!isBodyContainer) {
    childOffset.top += parseInt((0, _style2.default)(target, 'marginTop'), 10) || 0;
    childOffset.left += parseInt((0, _style2.default)(target, 'marginLeft'), 10) || 0;
  }

  var overlaySize = (0, _offset2.default)(overlayNode);
  var margins = getMargins(overlayNode);
  overlaySize.width += margins.left + margins.right;
  overlaySize.height += margins.top + margins.bottom;

  var containerDimensions = getContainerDimensions(container);
  var boundaryContainer = boundariesElement === 'container' ? container : boundariesElement();
  var boundaryDimensions = getContainerDimensions(boundaryContainer);
  var containerOffsetWithBoundary = boundaryContainer.tagName === 'BODY' ? (0, _offset2.default)(container) : (0, _position2.default)(container, boundaryContainer);
  return calculatePositionInternal(placementInput, containerDimensions, childOffset, overlaySize, margins, padding, flip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset);
}