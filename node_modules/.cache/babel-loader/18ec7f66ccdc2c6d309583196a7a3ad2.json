{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _events = require('events');\n\nvar _IndexPath = require('./IndexPath');\n\nvar _IndexPath2 = _interopRequireDefault(_IndexPath);\n\nvar _IndexPathSet = require('./IndexPathSet');\n\nvar _IndexPathSet2 = _interopRequireDefault(_IndexPathSet);\n\nvar _IndexSet = require('./IndexSet');\n\nvar _IndexSet2 = _interopRequireDefault(_IndexSet);\n\nvar _Range = require('./Range');\n\nvar _Range2 = _interopRequireDefault(_Range);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n/**\n * {@link CollectionView} supports arbitrary data sources, which provide data to be rendered,\n * and respond to user-initiated actions from {@link EditableCollectionView}.\n * Data provided by a data source is two dimensional: items are grouped into sections.\n * This can be useful, for example, if you want to display headers above a group of items.\n *\n * There is one built-in data source, {@link ArrayDataSource}, which simply renders a two-dimensional\n * array of data provided to its constructor. If you need custom behavior, you can either\n * extend {@link ArrayDataSource} or implement your own data source from scratch.\n *\n * All data sources must extend the {@link DataSource} abstract base class. Data sources must\n * implement a minimum of three methods to provide data to a collection view:\n *\n * - {@link getNumberOfSections}\n * - {@link getSectionLength}\n * - {@link getItem}\n *\n * When data in the data source changes, perhaps in response to some external event such as a\n * server update, the data source should emit events. The collection view listens for these\n * events and updates its views as necessary. All of the events have an optional `animated`\n * argument specifying whether the collection view should animate the change or apply it\n * immediately (`true` if omitted).\n *\n * - `'insertSection', section, animated` - emitted when a section is inserted, with a section index.\n * - `'insertItem', indexPath, animated` - emitted when an item is inserted, with an {@link IndexPath}.\n * - `'removeSection, section, animated` - emitted when a section is removed, with a section index.\n * - `'removeItem', indexPath, animated` - emitted when an item is removed, with an {@link IndexPath}.\n * - `'moveSection', from, to, animated` - emitted when a section is moved, with a source section\n     index, and destination section index.\n * - `'moveItem', from, to, animated` - emitted when an item is moved, with a source {@link IndexPath},\n     and destination {@link IndexPath}.\n * - `'reloadItem', indexPath, animated` - emitted when an item was updated, with an {@link IndexPath}.\n *\n * Additionally, changes can be grouped into transactions, such that all changes that occur within the\n * transaction are batched together and applied at once. If animated, the animations occur all at once\n * rather than in sequence. Transactions are started and ended by two events:\n *\n * - `'startTransaction'` - Starts a transaction. All changes until `endTransaction` is emitted\n *   are batched together and applied at once.\n * - `'endTransaction', animated` - Ends a transaction. All changes since the last `startTransaction` event\n *   are applied together.\n *\n * Optionally, data sources can support editing. {@link EditableCollectionView} will call\n * methods on its data source in response to user events. The data source should update its internal\n * state and perform any actions it needs to save the underlying data (such as sending events to a server).\n * It should also emit the above events as necessary to keep collection view in sync.\n *\n * @extends {EventEmitter}\n */\n\n\nvar DataSource = function (_EventEmitter) {\n  _inherits(DataSource, _EventEmitter);\n\n  function DataSource() {\n    _classCallCheck(this, DataSource);\n\n    return _possibleConstructorReturn(this, (DataSource.__proto__ || Object.getPrototypeOf(DataSource)).apply(this, arguments));\n  }\n\n  _createClass(DataSource, [{\n    key: 'getNumberOfSections',\n\n    /**\n     * Returns the number of sections in the collection\n     * @abstract\n     * @return {number}\n     */\n    value: function getNumberOfSections() {\n      return 0;\n    }\n    /**\n     * Returns the number of items in a particular section\n     * @abstract\n     * @param {number} section\n     * @return {number}\n     */\n\n  }, {\n    key: 'getSectionLength',\n    value: function getSectionLength(section) {\n      return 0;\n    }\n    /**\n     * Returns an item at a given section and index\n     * @abstract\n     * @param {number} section\n     * @param {number} index\n     */\n\n  }, {\n    key: 'getItem',\n    value: function getItem(section, index) {\n      return null;\n    }\n    /**\n     * Starts a transaction. All changes until `endTransaction` is called\n     * are batched together and applied at once.\n     * @abstract\n     */\n\n  }, {\n    key: 'startTransaction',\n    value: function startTransaction() {}\n    /**\n     * Ends a transaction. All changes since the last `startTransaction` call\n     * are applied together.\n     * @abstract\n     * @param {boolean} [animated=true] whether the changes should be animated\n     */\n\n  }, {\n    key: 'endTransaction',\n    value: function endTransaction(animated) {}\n    /**\n     * Inserts an item into the collection at a given IndexPath\n     * @abstract\n     * @param {IndexPath} indexPath the IndexPath at which to insert\n     * @param {*} item the item to insert\n     * @param {boolean} [animated=true] whether the insert should be animated\n     */\n\n  }, {\n    key: 'insertItem',\n    value: function insertItem(indexPath, item, animated) {}\n    /**\n     * Inserts multiple items into the collection at once.\n     * The default implementation calls `insertItem` for\n     * each item to insert within a transaction.\n     * @param {IndexPath} indexPath the IndexPath at which to insert\n     * @param {Array} items an array of items to insert\n     * @param {boolean} [animated=true] whether the insert should be animated\n     */\n\n  }, {\n    key: 'insertItems',\n    value: function insertItems(indexPath, items, animated) {\n      this.startTransaction();\n      indexPath = indexPath.copy();\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var item = _step.value;\n          this.insertItem(indexPath, item);\n          indexPath.index++;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      this.endTransaction(animated);\n    }\n    /**\n     * Inserts a section with the given items\n     * @abstract\n     * @param {number} section the section index at which to insert\n     * @param {Array} items an array of items to insert in the section\n     * @param {boolean} [animated=true] whether the insert should be animated\n     */\n\n  }, {\n    key: 'insertSection',\n    value: function insertSection(section, items, animated) {}\n    /**\n     * Inserts multiple sections into the collection at once.\n     * @param {number} sectionIndex the section index at which to insert\n     * @param {Array<Array>} sections an array of sections to insert\n     * @param {boolean} [animated=true] whether the insert should be animated\n     */\n\n  }, {\n    key: 'insertSections',\n    value: function insertSections(sectionIndex, sections, animated) {\n      this.startTransaction();\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = sections[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var section = _step2.value;\n          this.insertSection(sectionIndex++, section);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      this.endTransaction(animated);\n    }\n    /**\n     * Removes the item at the given IndexPath\n     * @abstract\n     * @param {IndexPath} indexPath the IndexPath to remove\n     * @param {boolean} [animated=true] whether the remove should be animated\n     */\n\n  }, {\n    key: 'removeItem',\n    value: function removeItem(indexPath, animated) {}\n    /**\n     * Removes multiple items at once\n     * @param {IndexPathSet} indexPathSet an IndexPathSet to remove\n     * @param {boolean} [animated=true] whether the remove should be animated\n     */\n\n  }, {\n    key: 'removeItems',\n    value: function removeItems(indexPathSet, animated) {\n      this.startTransaction();\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = indexPathSet.reverseIterator[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var indexPath = _step3.value;\n          this.removeItem(indexPath);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      this.endTransaction(animated);\n    }\n    /**\n     * Removes all items in the given section at once.\n     * @param {number} section the section to clear\n     * @param {boolean} [animated=true] whether the remove should be animated\n     */\n\n  }, {\n    key: 'clearSection',\n    value: function clearSection(section, animated) {\n      var count = this.getSectionLength(section);\n\n      if (count === 0) {\n        return;\n      }\n\n      var indexPathSet = new _IndexPathSet2.default();\n      indexPathSet.addRangeInSection(section, new _Range2.default(0, count - 1));\n      this.removeItems(indexPathSet, animated);\n    }\n    /**\n     * Removes a section from the collection\n     * @abstract\n     * @param {number} section the section to remove\n     * @param {boolean} [animated=true] whether the remove should be animated\n     */\n\n  }, {\n    key: 'removeSection',\n    value: function removeSection(section, animated) {}\n    /**\n     * Removes multiple sections at once\n     * @param {IndexSet} indexSet the IndexSet to remove\n     * @param {boolean} [animated=true] whether the remove should be animated\n     */\n\n  }, {\n    key: 'removeSections',\n    value: function removeSections(indexSet, animated) {\n      this.startTransaction();\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = indexSet.reverseIterator[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var index = _step4.value;\n          this.removeSection(index);\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      this.endTransaction(animated);\n    }\n    /**\n     * Removes all sections from the collection at once.\n     * @param {boolean} [animated=true] whether the remove should be animated\n     */\n\n  }, {\n    key: 'clear',\n    value: function clear(animated) {\n      var count = this.getNumberOfSections();\n\n      if (count === 0) {\n        return;\n      }\n\n      var indexSet = new _IndexSet2.default();\n      indexSet.addRange(new _Range2.default(0, count - 1));\n      this.removeSections(indexSet, animated);\n    }\n    /**\n     * Moves an item from one IndexPath to another\n     * @abstract\n     * @param {IndexPath} from the source IndexPath\n     * @param {IndexPath} to the destination IndexPath\n     * @param {boolean} [animated=true] whether the move should be animated\n     */\n\n  }, {\n    key: 'moveItem',\n    value: function moveItem(from, to, animated) {}\n    /**\n     * Moves a section\n     * @abstract\n     * @param {number} fromSection the source section index\n     * @param {number} toSection the destination section index\n     * @param {boolean} [animated=true] whether the move should be animated\n     */\n\n  }, {\n    key: 'moveSection',\n    value: function moveSection(fromSection, toSection, animated) {}\n    /**\n     * Moves all items in the given IndexPathSet to the given IndexPath\n     * such that the first item in the IndexPathSet is at the IndexPath\n     * and all others follow in the same order as in the IndexPathSet.\n     * @param {IndexPathSet} indexPathSet the IndexPathSet to move\n     * @param {IndexPath} toIndexPath the destination IndexPath\n     * @param {boolean} [animated=true] whether the move should be animated\n     */\n\n  }, {\n    key: 'moveItems',\n    value: function moveItems(indexPathSet, toIndexPath, animated) {\n      this.startTransaction(); // Make copies so we don't modify the input objects\n\n      toIndexPath = toIndexPath.copy(); // Shift the target down by the number of items being moved from before the target\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = indexPathSet[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var indexPath = _step5.value;\n\n          if (indexPath.section === toIndexPath.section && indexPath.index < toIndexPath.index) {\n            toIndexPath.index--;\n          }\n        } // Compute the initial and final positions for all of the items to move\n\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      var moves = [];\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = indexPathSet[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var _indexPath = _step6.value;\n          moves.push({\n            from: _indexPath,\n            to: toIndexPath.copy()\n          });\n          toIndexPath.index++;\n        } // Shift later from indices down if they have a larger index in the same section\n\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      for (var i = 0; i < moves.length; i++) {\n        var a = moves[i].from;\n\n        for (var j = i; j < moves.length; j++) {\n          var b = moves[j].from;\n\n          if (b.section === a.section && b.index > a.index) {\n            b.index--;\n          }\n        }\n      } // Interleave the moves so they can be applied one by one rather than all at once\n\n\n      for (var _i = 0; _i < moves.length; _i++) {\n        var _a = moves[_i];\n\n        for (var _j = moves.length - 1; _j > _i; _j--) {\n          var _b = moves[_j];\n\n          if (_b.from.section === _a.to.section) {\n            if (_b.from.index < _a.to.index) {\n              _a.to.index++;\n            } else {\n              _b.from.index++;\n            }\n          }\n        }\n      } // Finally, perform the moves\n\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = moves[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var move = _step7.value;\n          this.moveItem(move.from, move.to);\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      this.endTransaction(animated);\n    }\n    /**\n     * Moves the item in the given IndexPathSet to a new section\n     * such that the first item in the IndexPathSet is first in the new section\n     * and all others follow in the same order as in the IndexPathSet.\n     * @param {IndexPathSet} indexPathSet the IndexPathSet to move\n     * @param {number} toSection the destination section to create\n     * @param {boolean} [animated=true] whether the move should be animated\n     */\n\n  }, {\n    key: 'moveItemsToNewSection',\n    value: function moveItemsToNewSection(indexPathSet, toSection, animated) {\n      this.startTransaction(); // Insert a new section\n\n      this.insertSection(toSection, []); // Adjust the index paths to move, and move them to the new section\n\n      indexPathSet.adjustForInsertedSection(toSection);\n      this.moveItems(indexPathSet, new _IndexPath2.default(toSection, 0));\n      this.endTransaction(animated);\n    }\n    /**\n     * Replaces the item at an IndexPath with a different item\n     * @abstract\n     * @param {IndexPath} indexPath the IndexPath to replace\n     * @param {*} item the replacement item\n     * @param {boolean} [animated=true] whether the replacement should be animated\n     */\n\n  }, {\n    key: 'replaceItem',\n    value: function replaceItem(indexPath, item, animated) {}\n    /**\n     * Replaces a section with a different array of items\n     * @abstract\n     * @param {number} section - The section to replace\n     * @param {Array} items - The replacement items\n     * @param {boolean} [animated=true] whether the replacement should be animated\n     */\n\n  }, {\n    key: 'replaceSection',\n    value: function replaceSection(section, items, animated) {}\n    /**\n     * Performs a drag and drop reorder operation. By default, calls\n     * `moveSection`, `moveItemsToNewSection`, or `moveItems` depending on the\n     * drag and drop targets.\n     * @param {DragTarget} dragTarget - the drag target\n     * @param {DragTarget} dropTarget - the drop target\n     * @param {DropOperation} dropOperation - the operation to perform\n     * @param {IndexPathSet} indexPathSet - the IndexPathSet to reorder\n     */\n\n  }, {\n    key: 'performReorder',\n    value: function performReorder(dragTarget, dropTarget, dropOperation, indexPathSet) {\n      if (dragTarget.type === 'section') {\n        this.moveSection(dragTarget.indexPath.section, dropTarget.indexPath.section);\n      } else {\n        if (dropTarget.type === 'section') {\n          this.moveItemsToNewSection(indexPathSet, dropTarget.indexPath.section);\n        } else {\n          this.moveItems(indexPathSet, dropTarget.indexPath);\n        }\n      }\n    }\n    /**\n     * Performs a drop operation on the collection view. By default,\n     * calls `insertSection` or `insertItems` depending on the drop target.\n     * @param {DragTarget} dropTarget - the target of the drop\n     * @param {DropOperation} dropOperation - the operation to perform\n     * @param {Array} items - the items being dropped\n     */\n\n  }, {\n    key: 'performDrop',\n    value: function performDrop(dropTarget, dropOperation, items) {\n      if (dropTarget.type === 'section') {\n        this.insertSection(dropTarget.indexPath.section, items);\n      } else {\n        this.insertItems(dropTarget.indexPath, items);\n      }\n    }\n  }]);\n\n  return DataSource;\n}(_events.EventEmitter);\n\nexports.default = DataSource;","map":null,"metadata":{},"sourceType":"script"}