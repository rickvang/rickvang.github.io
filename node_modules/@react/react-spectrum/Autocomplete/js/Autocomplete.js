'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class;

var _autobindDecorator = require('autobind-decorator');

var _autobindDecorator2 = _interopRequireDefault(_autobindDecorator);

var _events = require('../../utils/events');

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _createId = require('../../utils/createId');

var _createId2 = _interopRequireDefault(_createId);

var _Menu = require('../../Menu');

var _Overlay = require('../../OverlayTrigger/js/Overlay');

var _Overlay2 = _interopRequireDefault(_Overlay);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _scrollToDOMNode = require('../../utils/scrollToDOMNode');

var _scrollToDOMNode2 = _interopRequireDefault(_scrollToDOMNode);

require('../style/index.css');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var getLabel = function getLabel(o) {
  return typeof o === 'string' ? o : o.label;
};

var LISTBOX = '-listbox';
var OPTION = '-option-';

var Autocomplete = (0, _autobindDecorator2.default)(_class = function (_React$Component) {
  _inherits(Autocomplete, _React$Component);

  function Autocomplete(props) {
    _classCallCheck(this, Autocomplete);

    var _this = _possibleConstructorReturn(this, (Autocomplete.__proto__ || Object.getPrototypeOf(Autocomplete)).call(this, props));

    _this.state = {
      value: '',
      showDropdown: false,
      results: [],
      selectedIndex: -1,
      isFocused: false
    };

    _this.autocompleteId = (0, _createId2.default)();
    return _this;
  }

  _createClass(Autocomplete, [{
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.componentWillReceiveProps(this.props);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(props) {
      if (props.value != null && props.value !== this.state.value) {
        this.setValue(props.value);
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.updateSize();
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      this.updateSize();
    }
  }, {
    key: 'updateSize',
    value: function updateSize() {
      if (this.wrapper) {
        var width = this.wrapper.offsetWidth;
        if (width !== this.state.width) {
          this.setState({ width: width });
        }
      }
    }
  }, {
    key: 'onChange',
    value: function onChange(value) {
      var onChange = this.props.onChange;

      if (onChange) {
        onChange(value);
      }

      if (this.props.value == null) {
        this.setValue(value);
      }
    }
  }, {
    key: 'setValue',
    value: function setValue(value) {
      this.setState({
        value: value,
        showDropdown: this.state.isFocused,
        selectedIndex: this.props.allowCreate && this.state.selectedIndex === -1 ? -1 : 0
      });

      this.getCompletions(value);
    }
  }, {
    key: 'getCompletions',
    value: function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(value) {
        var _this2 = this;

        var results, getCompletions;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.optionIdPrefix = this.optionIdPrefix || this.autocompleteId + LISTBOX;
                this._value = value;

                results = [];
                getCompletions = this.props.getCompletions;

                if (!getCompletions) {
                  _context.next = 8;
                  break;
                }

                _context.next = 7;
                return getCompletions(value);

              case 7:
                results = _context.sent;

              case 8:
                if (!(this._value === value)) {
                  _context.next = 11;
                  break;
                }

                this.setState({ results: results }, function () {
                  var list = _reactDom2.default.findDOMNode(_this2.getListRef());
                  if (list) {
                    list.scrollTop = 0;
                  }
                });

                return _context.abrupt('return', results);

              case 11:
                return _context.abrupt('return', this.state.results);

              case 12:
              case 'end':
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getCompletions(_x) {
        return _ref.apply(this, arguments);
      }

      return getCompletions;
    }()
  }, {
    key: 'onSelect',
    value: function onSelect(value, event) {
      this.onChange(typeof value === 'string' ? value : value.label);
      this.hideMenu();

      if (this.props.onSelect) {
        this.props.onSelect(value, event);
      }
    }
  }, {
    key: 'onFocus',
    value: function onFocus() {
      this.setState({ isFocused: true });
    }
  }, {
    key: 'onBlur',
    value: function onBlur(event) {
      if (this.wrapper && this.wrapper.contains(event.relatedTarget)) {
        // If the element receiving focus is a child of the Autocomplete,
        // for example the toggle button on a ComboBox,
        // do nothing in order prevent hideMenu from executing twice.
        return;
      }
      this.hideMenu();
      this.setState({ isFocused: false });
    }
  }, {
    key: 'onEscape',
    value: function onEscape(event) {
      event.preventDefault();
      this.hideMenu();
    }
  }, {
    key: 'onSelectFocused',
    value: function onSelectFocused(event) {
      // Autocomplete should accept space key as text entry
      if (event.key === ' ') {
        return;
      }
      var _state = this.state,
          _state$results = _state.results,
          results = _state$results === undefined ? [] : _state$results,
          selectedIndex = _state.selectedIndex;

      var value = results[selectedIndex];
      if (value) {
        event.preventDefault();
        this.onSelect(value, event);
      } else if (this.props.allowCreate) {
        if (event.key !== 'Tab') {
          event.preventDefault();
        }
        this.onSelect(this.state.value, event);
      }
    }
  }, {
    key: 'onFocusFirst',
    value: function onFocusFirst(event) {
      event.preventDefault();
      this.selectIndex(0);
    }
  }, {
    key: 'onFocusLast',
    value: function onFocusLast(event) {
      event.preventDefault();
      this.selectIndex(this.state.results.length - 1);
    }
  }, {
    key: 'onFocusPrevious',
    value: function onFocusPrevious(event) {
      event.preventDefault();
      var _state2 = this.state,
          _state2$results = _state2.results,
          results = _state2$results === undefined ? [] : _state2$results,
          selectedIndex = _state2.selectedIndex;

      var index = selectedIndex - 1;
      if (index < 0) {
        index = results.length - 1;
      }

      this.selectIndex(index);
    }
  }, {
    key: 'onFocusNext',
    value: function onFocusNext(event) {
      event.preventDefault();
      // make sure menu is shown
      if (!this.state.showDropdown) {
        this.showMenu();
      }
      var _state3 = this.state,
          _state3$results = _state3.results,
          results = _state3$results === undefined ? [] : _state3$results,
          selectedIndex = _state3.selectedIndex;

      var index = results.length ? (selectedIndex + 1) % results.length : 0;
      this.selectIndex(index);
    }
  }, {
    key: 'onPageDown',
    value: function onPageDown(event) {
      event.preventDefault();
      var _state4 = this.state,
          _state4$results = _state4.results,
          results = _state4$results === undefined ? [] : _state4$results,
          selectedIndex = _state4.selectedIndex,
          showDropdown = _state4.showDropdown;

      var len = results.length;
      if (!showDropdown || !len) {
        return;
      }

      var listNode = _reactDom2.default.findDOMNode(this.getListRef());
      var items = [].concat(_toConsumableArray(listNode.children));
      var targetItem = items[selectedIndex === -1 ? 0 : selectedIndex];
      var nextPage = Math.min(targetItem.offsetTop + listNode.clientHeight, listNode.scrollHeight + listNode.clientHeight);
      var index = items.indexOf(targetItem) + 1;
      var item = items.slice(index).find(function (item) {
        return item.offsetTop + item.offsetHeight > nextPage;
      });

      if (item) {
        this.selectIndex(items.indexOf(item), true);
      } else {
        this.onFocusLast(event);
      }
    }
  }, {
    key: 'onPageUp',
    value: function onPageUp(event) {
      event.preventDefault();
      var _state5 = this.state,
          _state5$results = _state5.results,
          results = _state5$results === undefined ? [] : _state5$results,
          selectedIndex = _state5.selectedIndex,
          showDropdown = _state5.showDropdown;

      var len = results.length;
      if (!showDropdown || !len) {
        return;
      }

      var listNode = _reactDom2.default.findDOMNode(this.getListRef());
      var items = [].concat(_toConsumableArray(listNode.children));
      var targetItem = items[selectedIndex === -1 ? 0 : selectedIndex];
      var nextPage = Math.max(targetItem.offsetTop + targetItem.offsetHeight - listNode.clientHeight, 0);
      var index = items.indexOf(targetItem);
      var item = items.slice(0, index).reverse().find(function (item) {
        return item.offsetTop < nextPage;
      });

      if (item) {
        this.selectIndex(items.indexOf(item));
      } else {
        this.onFocusFirst(event);
      }
    }
  }, {
    key: 'onMouseEnter',
    value: function onMouseEnter(index) {
      this.selectIndex(index);
    }
  }, {
    key: 'onAltArrowDown',
    value: function onAltArrowDown(event) {
      event.preventDefault();
      if (!this.state.showDropdown) {
        this.showMenu();
      }
    }
  }, {
    key: 'onAltArrowUp',
    value: function onAltArrowUp(event) {
      event.preventDefault();
      if (this.state.showDropdown) {
        this.hideMenu();
      }
    }
  }, {
    key: 'onTab',
    value: function onTab(event) {
      this.onSelectFocused(event);
    }
  }, {
    key: 'selectIndex',
    value: function selectIndex(selectedIndex, alignToStart) {
      var _this3 = this;

      this.setState({ selectedIndex: selectedIndex }, function () {
        if (_this3.menu && !isNaN(selectedIndex) && selectedIndex !== -1) {
          // make sure that the selected item scrolls into view
          var list = _reactDom2.default.findDOMNode(_this3.getListRef());
          if (list) {
            var node = list.children[selectedIndex];
            if (node) {
              (0, _scrollToDOMNode2.default)(node, list, alignToStart);
            }
          }
        }
      });
    }
  }, {
    key: 'toggleMenu',
    value: function toggleMenu() {
      if (this.state.showDropdown) {
        this.hideMenu();
      } else {
        this.showMenu();
      }
    }
  }, {
    key: 'showMenu',
    value: function () {
      var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
        var _this4 = this;

        var results, selectedIndex;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                this.setState({ showDropdown: true, selectedIndex: -1 });
                _context2.next = 3;
                return this.getCompletions(this.state.value);

              case 3:
                _context2.t0 = _context2.sent;

                if (_context2.t0) {
                  _context2.next = 6;
                  break;
                }

                _context2.t0 = [];

              case 6:
                results = _context2.t0;


                // Reset the selected index based on the value
                selectedIndex = results.findIndex(function (result) {
                  return getLabel(result) === _this4.state.value;
                });

                if (selectedIndex !== -1) {
                  this.setState({ selectedIndex: selectedIndex });
                }

                if (this.props.onMenuShow) {
                  this.props.onMenuShow();
                }

              case 10:
              case 'end':
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function showMenu() {
        return _ref2.apply(this, arguments);
      }

      return showMenu;
    }()
  }, {
    key: 'hideMenu',
    value: function hideMenu() {
      this.setState({ showDropdown: false, selectedIndex: -1 });
      if (this.props.onMenuHide) {
        this.props.onMenuHide();
      }
    }
  }, {
    key: 'getActiveDescendantId',
    value: function getActiveDescendantId() {
      var _state6 = this.state,
          selectedIndex = _state6.selectedIndex,
          showDropdown = _state6.showDropdown,
          _state6$results = _state6.results,
          results = _state6$results === undefined ? [] : _state6$results;

      return showDropdown && results.length > 0 && selectedIndex !== -1 ? this.optionIdPrefix + OPTION + selectedIndex : undefined;
    }
  }, {
    key: 'getListboxId',
    value: function getListboxId() {
      var _state7 = this.state,
          showDropdown = _state7.showDropdown,
          _state7$results = _state7.results,
          results = _state7$results === undefined ? [] : _state7$results;

      return showDropdown && results.length > 0 ? this.autocompleteId + LISTBOX : undefined;
    }
  }, {
    key: 'getListRef',
    value: function getListRef() {
      return this.menu && this.menu.getListRef();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this5 = this;

      var _props = this.props,
          id = _props.id,
          className = _props.className;
      var _state8 = this.state,
          isFocused = _state8.isFocused,
          _state8$results = _state8.results,
          results = _state8$results === undefined ? [] : _state8$results,
          selectedIndex = _state8.selectedIndex,
          showDropdown = _state8.showDropdown,
          value = _state8.value;

      var children = _react2.default.Children.toArray(this.props.children);
      var trigger = children.find(function (c) {
        return c.props.autocompleteInput;
      }) || children[0];
      var menuShown = showDropdown && results.length > 0;
      var inputId = id || trigger.props.id || this.autocompleteId;

      return _react2.default.createElement(
        'div',
        {
          className: (0, _classnames2.default)('react-spectrum-Autocomplete', { 'is-focused': isFocused }, className),
          ref: function ref(w) {
            return _this5.wrapper = w;
          },
          role: 'combobox',
          'aria-controls': this.getListboxId(),
          'aria-expanded': menuShown,
          'aria-haspopup': 'true',
          'aria-owns': this.getListboxId() },
        children.map(function (child) {
          if (child === trigger) {
            return _react2.default.cloneElement(child, {
              value: value,
              onChange: (0, _events.chain)(child.props.onChange, _this5.onChange),
              onKeyDown: (0, _events.chain)(child.props.onKeyDown, _events.interpretKeyboardEvent.bind(_this5)),
              onFocus: (0, _events.chain)(child.props.onFocus, _this5.onFocus),
              onBlur: (0, _events.chain)(child.props.onBlur, _this5.onBlur),
              id: inputId,
              autoComplete: 'off',
              role: 'textbox',
              'aria-activedescendant': _this5.getActiveDescendantId(),
              'aria-autocomplete': 'list',
              'aria-controls': _this5.getListboxId()
            });
          }

          return child;
        }),
        _react2.default.createElement(
          _Overlay2.default,
          { target: this.wrapper, show: menuShown, placement: 'bottom left', role: 'presentation' },
          _react2.default.createElement(
            _Menu.Menu,
            {
              onSelect: this.onSelect,
              onMouseDown: function onMouseDown(e) {
                return e.preventDefault();
              },
              style: { width: this.state.width + 'px' },
              role: 'listbox',
              ref: function ref(m) {
                return _this5.menu = m;
              },
              id: this.getListboxId() },
            results.map(function (result, i) {
              var label = getLabel(result);
              return _react2.default.createElement(
                _Menu.MenuItem,
                {
                  role: 'option',
                  id: _this5.optionIdPrefix + OPTION + i,
                  tabIndex: selectedIndex === i ? 0 : -1,
                  key: 'item-' + i,
                  value: result,
                  icon: result.icon,
                  focused: selectedIndex === i,
                  selected: label === value,
                  onMouseEnter: _this5.onMouseEnter.bind(_this5, i),
                  onMouseDown: function onMouseDown(e) {
                    return e.preventDefault();
                  } },
                label
              );
            })
          )
        )
      );
    }
  }]);

  return Autocomplete;
}(_react2.default.Component)) || _class;

Autocomplete.propTypes = {
  /**
   * Allows input that isn't part of the list of options
   */
  allowCreate: _propTypes2.default.bool,

  /**
   * Value of the input
   */
  value: _propTypes2.default.string,

  /**
   * Callback for when value changes due to selection
   */
  onSelect: _propTypes2.default.func,

  /**
   * String for extra class names to add to the top level div
   */
  className: _propTypes2.default.string,

  /**
   * String that will override the default id generated by the instance
   */
  id: _propTypes2.default.string,

  /**
   * Callback for when the menu opens
   */
  onMenuShow: _propTypes2.default.func,

  /**
   * Callback for when the menu closes
   */
  onMenuHide: _propTypes2.default.func
};
Autocomplete.defaultProps = {
  allowCreate: false
};
exports.default = Autocomplete;