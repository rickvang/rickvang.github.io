{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"/Users/rvang/Desktop/Spectrum/testapp/node_modules/@babel/runtime/regenerator\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _Range = require('./Range');\n\nvar _Range2 = _interopRequireDefault(_Range);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/**\n * The IndexSet class represents a set of indices into another data structure,\n * such as an array. For example, a selection of items in a list could be stored\n * by an IndexSet. Internally, it is stored as a sorted list of ranges.\n */\n\n\nvar IndexSet = function () {\n  /**\n   * Creates a new IndexSet\n   */\n  function IndexSet() {\n    _classCallCheck(this, IndexSet);\n\n    this.ranges = [];\n  }\n  /**\n   * Adds the given Range to the index set\n   * @param {Range} range the range to add\n   */\n\n\n  _createClass(IndexSet, [{\n    key: 'addRange',\n    value: function addRange(range) {\n      if (range.length === 0) {\n        return;\n      }\n\n      range = range.copy();\n\n      if (this.ranges.length === 0) {\n        this.ranges.push(range);\n        return;\n      }\n\n      var startIndex = this.findRangeIndex(range.start, true);\n      var endIndex = this.findRangeIndex(range.end, true);\n      var startRange = this.ranges[startIndex];\n      var endRange = this.ranges[endIndex];\n      var removalStart = startIndex;\n      var removalEnd = endIndex;\n      var matchesStart = startRange.contains(range.start) || startRange.end === range.start - 1;\n      var matchesEnd = endRange.contains(range.end) || endRange.start - 1 === range.end;\n\n      if (matchesStart) {\n        range.start = startRange.start;\n      }\n\n      if (matchesEnd) {\n        range.end = endRange.end;\n      }\n\n      if (startIndex === endIndex) {\n        if (matchesStart || matchesEnd) {\n          removalEnd++;\n        }\n      } else {\n        if (!matchesStart) {\n          removalStart++;\n        }\n\n        if (matchesEnd) {\n          removalEnd++;\n        }\n      }\n\n      if (removalEnd > removalStart) {\n        this.ranges.splice(removalStart, removalEnd - removalStart);\n      }\n\n      if (range.start > startRange.end) {\n        startIndex++;\n      }\n\n      this.ranges.splice(startIndex, 0, range);\n    }\n    /**\n     * Adds the given index to the index set\n     * @param {number} index the index to add\n     */\n\n  }, {\n    key: 'addIndex',\n    value: function addIndex(index) {\n      this.addRange(new _Range2.default(index, index));\n    }\n    /**\n     * Adds all indexes in the given IndexSet to this index set\n     * @param {IndexSet} indexSet the IndexSet to add\n     */\n\n  }, {\n    key: 'addIndexSet',\n    value: function addIndexSet(indexSet) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = indexSet.ranges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var range = _step.value;\n          this.addRange(range);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n    /**\n     * Removes the given Range from the index set\n     * @param {Range} range the range to remove\n     */\n\n  }, {\n    key: 'removeRange',\n    value: function removeRange(range) {\n      if (range.length === 0 || this.ranges.length === 0) {\n        return;\n      }\n\n      var startIndex = this.findRangeIndex(range.start, true);\n      var endIndex = this.findRangeIndex(range.end, true);\n      var startRange = this.ranges[startIndex];\n      var endRange = this.ranges[endIndex];\n      var removalStart = startIndex;\n      var removalEnd = endIndex;\n\n      if (startRange.contains(range.start) && range.start > startRange.start) {\n        if (startIndex === endIndex && range.end < endRange.end) {\n          endRange = new _Range2.default(range.end + 1, endRange.end);\n          this.ranges.splice(startIndex + 1, 0, endRange);\n        }\n\n        startRange.end = range.start - 1;\n        removalStart++;\n      } else if (range.start > startRange.end) {\n        removalStart++;\n      }\n\n      if (endRange.contains(range.end) && range.end < endRange.end) {\n        endRange.start = range.end + 1;\n      } else if (range.end >= endRange.end) {\n        removalEnd++;\n      }\n\n      if (removalEnd > removalStart) {\n        this.ranges.splice(removalStart, removalEnd - removalStart);\n      }\n    }\n    /**\n     * Removes the given index from the index set\n     * @param {number} index the index to remove\n     */\n\n  }, {\n    key: 'removeIndex',\n    value: function removeIndex(index) {\n      this.removeRange(new _Range2.default(index, index));\n    }\n    /**\n     * Removes all indexes in the given IndexSet from this index set\n     * @param {IndexSet} indexSet the IndexSet to remove\n     */\n\n  }, {\n    key: 'removeIndexSet',\n    value: function removeIndexSet(indexSet) {\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = indexSet.ranges[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var range = _step2.value;\n          this.removeRange(range);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n    /**\n     * Toggles the given index. If the index set contains the given index,\n     * it is removed, otherwise it is added to the index set.\n     * @param {number} index the index to toggle\n     */\n\n  }, {\n    key: 'toggleIndex',\n    value: function toggleIndex(index) {\n      if (this.containsIndex(index)) {\n        this.removeIndex(index);\n      } else {\n        this.addIndex(index);\n      }\n    }\n    /**\n     * Removes all indices from the IndexSet\n     */\n\n  }, {\n    key: 'clear',\n    value: function clear() {\n      this.ranges.length = 0;\n    }\n    /**\n     * Adjusts the index set for an insertion by shifting\n     * indices above the insertion index by the number of\n     * inserted items.\n     * @param {Range} range the inserted range\n     */\n\n  }, {\n    key: 'adjustForInsertedRange',\n    value: function adjustForInsertedRange(range) {\n      this._adjustRangesAbove(range.start, range.length);\n\n      this.removeRange(range);\n    }\n    /**\n     * Adjusts the index set for a deletion by shifting\n     * indices above the insertion index by the number\n     * of deleted items.\n     * @param {Range} range the deleted range\n     */\n\n  }, {\n    key: 'adjustForDeletedRange',\n    value: function adjustForDeletedRange(range) {\n      this.removeRange(range);\n\n      this._adjustRangesAbove(range.end + 1, -range.length);\n    }\n    /**\n     * Adjusts the index set for a move.\n     * @param {number} fromIndex the source index\n     * @param {number} toIndex the destination index\n     */\n\n  }, {\n    key: 'adjustForMove',\n    value: function adjustForMove(fromIndex, toIndex) {\n      var contains = this.containsIndex(fromIndex);\n      this.adjustForDeletedRange(new _Range2.default(fromIndex, fromIndex));\n      this.adjustForInsertedRange(new _Range2.default(toIndex, toIndex));\n\n      if (contains) {\n        this.addIndex(toIndex);\n      }\n    }\n    /**\n     * Helper function to increment or decrement ranges\n     * above the given range's start by the range's length.\n     */\n\n  }, {\n    key: '_adjustRangesAbove',\n    value: function _adjustRangesAbove(index, count) {\n      if (this.ranges.length === 0) {\n        return;\n      }\n\n      var i = this.findRangeIndex(index, true);\n\n      for (; i < this.ranges.length; i++) {\n        var r = this.ranges[i];\n\n        if (r.start >= index) {\n          r.start += count;\n        }\n\n        if (r.end >= index) {\n          r.end += count;\n        } // merge ranges that end up next to each other\n\n\n        if (i > 0 && r.start === this.ranges[i - 1].end + 1) {\n          r.start = this.ranges[--i].start;\n          this.ranges.splice(i, 1);\n        }\n      }\n    }\n    /**\n     * Returns whether the given index is in the index set\n     * @param {number} index the index to check\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'containsIndex',\n    value: function containsIndex(index) {\n      return this.findRangeIndex(index) >= 0;\n    }\n    /**\n     * Returns whether all indexes in the given Range are in the index set\n     * @param {Range} range the range to check\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'containsRange',\n    value: function containsRange(range) {\n      var startingRange = this.findRange(range);\n\n      if (startingRange) {\n        return startingRange.contains(range.start) && startingRange.contains(range.end);\n      }\n\n      return false;\n    }\n    /**\n     * The first index in the index set\n     * @type {number}\n     */\n\n  }, {\n    key: Symbol.iterator,\n\n    /**\n     * An ES6 iterator for looping through the indexes\n     * in the index set one at a time.\n     * @return {Generator}\n     */\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function value() {\n      var _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, range, i;\n\n      return _regeneratorRuntime.wrap(function value$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _iteratorNormalCompletion3 = true;\n              _didIteratorError3 = false;\n              _iteratorError3 = undefined;\n              _context.prev = 3;\n              _iterator3 = this.ranges[Symbol.iterator]();\n\n            case 5:\n              if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {\n                _context.next = 17;\n                break;\n              }\n\n              range = _step3.value;\n              i = range.start;\n\n            case 8:\n              if (!(i <= range.end)) {\n                _context.next = 14;\n                break;\n              }\n\n              _context.next = 11;\n              return i;\n\n            case 11:\n              i++;\n              _context.next = 8;\n              break;\n\n            case 14:\n              _iteratorNormalCompletion3 = true;\n              _context.next = 5;\n              break;\n\n            case 17:\n              _context.next = 23;\n              break;\n\n            case 19:\n              _context.prev = 19;\n              _context.t0 = _context['catch'](3);\n              _didIteratorError3 = true;\n              _iteratorError3 = _context.t0;\n\n            case 23:\n              _context.prev = 23;\n              _context.prev = 24;\n\n              if (!_iteratorNormalCompletion3 && _iterator3.return) {\n                _iterator3.return();\n              }\n\n            case 26:\n              _context.prev = 26;\n\n              if (!_didIteratorError3) {\n                _context.next = 29;\n                break;\n              }\n\n              throw _iteratorError3;\n\n            case 29:\n              return _context.finish(26);\n\n            case 30:\n              return _context.finish(23);\n\n            case 31:\n            case 'end':\n              return _context.stop();\n          }\n        }\n      }, value, this, [[3, 19, 23, 31], [24,, 26, 30]]);\n    })\n    /**\n     * An ES6 iterator for looping the the indexes\n     * in the index set on at a time, in reverse.\n     * @type {Iterator}\n     */\n\n  }, {\n    key: 'objectsFromArray',\n\n    /**\n     * Returns an array of items from the given array\n     * whose indexes are in the index set.\n     * @param {Array} arr the array to get items from\n     * @return {Array}\n     */\n    value: function objectsFromArray(arr) {\n      var res = [];\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var index = _step4.value;\n          res.push(arr[index]);\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return res;\n    }\n    /**\n     * Removes the indices specified by this index set\n     * from the given array.\n     * @param {Array} arr the array to remove items from\n     */\n\n  }, {\n    key: 'removeFromArray',\n    value: function removeFromArray(arr) {\n      for (var rangeIndex = this.ranges.length - 1; rangeIndex >= 0; rangeIndex--) {\n        var range = this.ranges[rangeIndex];\n        arr.splice(range.start, range.length);\n      }\n    }\n    /**\n     * Returns whether this index set is equal to the given index set\n     * @param {IndexSet} other the IndexSet to compare\n     * @return {boolean}\n     */\n\n  }, {\n    key: 'equals',\n    value: function equals(other) {\n      if (!other || !(other instanceof IndexSet)) {\n        return false;\n      }\n\n      if (other === this) {\n        return true;\n      }\n\n      if (other.ranges.length !== this.ranges.length) {\n        return false;\n      }\n\n      for (var i = 0; i < this.ranges.length; i++) {\n        if (!this.ranges[i].equals(other.ranges[i])) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n    /**\n     * Returns a copy of the index set\n     * @return {IndexSet}\n     */\n\n  }, {\n    key: 'copy',\n    value: function copy() {\n      var res = new IndexSet();\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = this.ranges[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var range = _step5.value;\n          res.ranges.push(range.copy());\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return res;\n    }\n    /**\n     * Returns a new index set containing the indexes in this\n     * index set minus the indexes in the other index set.\n     * @param {IndexSet} other the index set to subtract from this one\n     */\n\n  }, {\n    key: 'difference',\n    value: function difference(other) {\n      var res = this.copy();\n      res.removeIndexSet(other);\n      return res;\n    }\n  }, {\n    key: 'findRangeIndex',\n    value: function findRangeIndex(index) {\n      var nearest = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var ranges = this.ranges;\n      var low = 0;\n      var high = ranges.length;\n      var mid = void 0;\n\n      while (low < high) {\n        mid = low + high >> 1;\n        var range = ranges[mid];\n\n        if (index < range.start) {\n          high = mid;\n        } else if (index > range.end) {\n          low = mid + 1;\n        } else {\n          return mid;\n        }\n      }\n\n      if (nearest) {\n        return mid;\n      }\n\n      return -1;\n    }\n  }, {\n    key: 'findRange',\n    value: function findRange(index) {\n      var rangeIndex = this.findRangeIndex(index);\n\n      if (rangeIndex === -1) {\n        return null;\n      }\n\n      return this.ranges[rangeIndex];\n    }\n  }, {\n    key: 'firstIndex',\n    get: function get() {\n      if (this.ranges.length > 0) {\n        return this.ranges[0].start;\n      }\n\n      return -1;\n    }\n    /**\n     * The last index in the index set\n     * @type {number}\n     */\n\n  }, {\n    key: 'lastIndex',\n    get: function get() {\n      if (this.ranges.length > 0) {\n        return this.ranges[this.ranges.length - 1].end;\n      }\n\n      return -1;\n    }\n    /**\n     * The number of indexes in the index set\n     * @type {number}\n     */\n\n  }, {\n    key: 'length',\n    get: function get() {\n      var length = 0;\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this.ranges[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var range = _step6.value;\n          length += range.length;\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      return length;\n    }\n    /**\n     * Whether the IndexSet is empty\n     * @type {boolean}\n     */\n\n  }, {\n    key: 'isEmpty',\n    get: function get() {\n      return this.ranges.length === 0;\n    }\n  }, {\n    key: 'reverseIterator',\n    get: function get() {\n      var ranges = this.ranges;\n      return _defineProperty({}, Symbol.iterator,\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var rangeIndex, range, i;\n        return _regeneratorRuntime.wrap(function _callee$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                rangeIndex = ranges.length - 1;\n\n              case 1:\n                if (!(rangeIndex >= 0)) {\n                  _context2.next = 13;\n                  break;\n                }\n\n                range = ranges[rangeIndex];\n                i = range.end;\n\n              case 4:\n                if (!(i >= range.start)) {\n                  _context2.next = 10;\n                  break;\n                }\n\n                _context2.next = 7;\n                return i;\n\n              case 7:\n                i--;\n                _context2.next = 4;\n                break;\n\n              case 10:\n                rangeIndex--;\n                _context2.next = 1;\n                break;\n\n              case 13:\n              case 'end':\n                return _context2.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n  }]);\n\n  return IndexSet;\n}();\n\nexports.default = IndexSet;","map":null,"metadata":{},"sourceType":"script"}