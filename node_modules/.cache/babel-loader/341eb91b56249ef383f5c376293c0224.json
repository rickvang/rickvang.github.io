{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = undefined;\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar _collectionView = require('@react/collection-view');\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar TableViewLayout = function (_ListLayout) {\n  _inherits(TableViewLayout, _ListLayout);\n\n  function TableViewLayout() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, TableViewLayout);\n\n    var _this = _possibleConstructorReturn(this, (TableViewLayout.__proto__ || Object.getPrototypeOf(TableViewLayout)).call(this, options));\n\n    _this.insertionIndicator = null;\n    return _this;\n  }\n\n  _createClass(TableViewLayout, [{\n    key: 'getLayoutInfo',\n    value: function getLayoutInfo(type, section, index) {\n      if (type === 'insertion-indicator') {\n        return this.insertionIndicator;\n      }\n\n      return _get(TableViewLayout.prototype.__proto__ || Object.getPrototypeOf(TableViewLayout.prototype), 'getLayoutInfo', this).call(this, type, section, index);\n    }\n  }, {\n    key: 'getVisibleLayoutInfos',\n    value: function getVisibleLayoutInfos(rect) {\n      var layoutInfos = _get(TableViewLayout.prototype.__proto__ || Object.getPrototypeOf(TableViewLayout.prototype), 'getVisibleLayoutInfos', this).call(this, rect);\n\n      if (this.insertionIndicator) {\n        layoutInfos.push(this.insertionIndicator);\n      }\n\n      return layoutInfos;\n    }\n  }, {\n    key: 'validate',\n    value: function validate() {\n      _get(TableViewLayout.prototype.__proto__ || Object.getPrototypeOf(TableViewLayout.prototype), 'validate', this).call(this);\n\n      var count = this.collectionView.getSectionLength(0);\n      this.contentHeight = count * this.rowHeight - 1; // Show the drop insertion indicator if the default drop position of the table view is \"between\",\n      // the target's drop position is also \"between\", and the table is not empty.\n\n      var dropTarget = this.collectionView._dropTarget;\n      var showInsertionIndicator = dropTarget && this.component.props.dropPosition === 'between' && dropTarget.dropPosition === _collectionView.DragTarget.DROP_BETWEEN && count > 0;\n\n      if (showInsertionIndicator) {\n        var l = new _collectionView.LayoutInfo('insertion-indicator');\n        l.rect = new _collectionView.Rect(0, Math.max(0, Math.min(this.contentHeight - 3, dropTarget.indexPath.index * this.rowHeight - 1)), this.collectionView.size.width, 2);\n        l.zIndex = 10;\n        this.insertionIndicator = l;\n      } else {\n        this.insertionIndicator = null;\n      }\n    }\n  }, {\n    key: 'getDropTarget',\n    value: function getDropTarget(point) {\n      var dropPosition = this.component.props.dropPosition === 'on' ? _collectionView.DragTarget.DROP_ON : _collectionView.DragTarget.DROP_BETWEEN; // If we are dropping between rows, the target should move to the\n      // next item halfway through a row.\n\n      if (dropPosition === _collectionView.DragTarget.DROP_BETWEEN) {\n        point = point.copy();\n        point.y += this.rowHeight / 2;\n      }\n\n      var indexPath = this.collectionView.indexPathAtPoint(point);\n\n      if (indexPath) {\n        return new _collectionView.DragTarget('item', indexPath, dropPosition);\n      } else {\n        var index = dropPosition === _collectionView.DragTarget.DROP_ON ? 0 : this.collectionView.getSectionLength(0);\n        return new _collectionView.DragTarget('item', new _collectionView.IndexPath(0, index), _collectionView.DragTarget.DROP_BETWEEN);\n      }\n    }\n  }]);\n\n  return TableViewLayout;\n}(_collectionView.ListLayout);\n\nexports.default = TableViewLayout;","map":null,"metadata":{},"sourceType":"script"}