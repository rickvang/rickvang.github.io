{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _View2 = require('./View');\n\nvar _View3 = _interopRequireDefault(_View2);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar KNOB_PADDING = 2;\nvar MIN_KNOB_HEIGHT = 20;\nvar MIN_OVERSCROLL_HEIGHT = 8;\nvar IS_MOBILE = 'ontouchstart' in global;\nvar KNOB_THICKNESS = IS_MOBILE ? 3 : 8;\nvar KNOB_COLOR = IS_MOBILE ? 'rgba(0, 0, 0, 0.3)' : 'rgba(0, 0, 0, 0.5)';\n\nvar Scroller = function (_View) {\n  _inherits(Scroller, _View);\n\n  function Scroller(scrollView, orientation) {\n    _classCallCheck(this, Scroller);\n\n    var _this = _possibleConstructorReturn(this, (Scroller.__proto__ || Object.getPrototypeOf(Scroller)).call(this));\n\n    _this.scrollView = scrollView;\n    _this.knobWidth = KNOB_THICKNESS;\n    _this.knobHeight = 0;\n    _this.trackHeight = 0;\n    _this.value = 0;\n    _this.hidden = false;\n    _this.isVertical = orientation !== 'horizontal';\n\n    _this.css({\n      position: 'absolute',\n      width: _this.knobWidth + 'px',\n      height: _this.knobWidth + 'px',\n      backgroundColor: KNOB_COLOR,\n      borderRadius: KNOB_THICKNESS + 'px',\n      top: 0,\n      left: 0,\n      opacity: 0,\n      transition: 'opacity 200ms'\n    }); // set WAI-ARIA role=\"presentation\" so that the scrollbar has no role\n\n\n    _this.setAttribute('role', 'presentation');\n\n    _this.onEvent('mouseDown', _this.mouseDown.bind(_this));\n\n    _this.onEvent('mouseOver', _this.mouseOver.bind(_this));\n\n    _this.onEvent('mouseOut', _this.mouseOut.bind(_this));\n\n    _this._mouseDown = false;\n    _this._mouseOver = false;\n    _this._scrolling = false;\n    _this._dragOffset = 0;\n    _this._valueAtDragStart = 0;\n    _this.mouseMove = _this.mouseMove.bind(_this);\n    _this.mouseUp = _this.mouseUp.bind(_this);\n    return _this;\n  }\n\n  _createClass(Scroller, [{\n    key: 'updateScrollViewSize',\n    value: function updateScrollViewSize() {\n      var hidden = this.isVertical ? this.scrollView.contentSize.height <= this.scrollView.size.height : this.scrollView.contentSize.width <= this.scrollView.size.width;\n\n      if (hidden !== this.hidden) {\n        this.css({\n          visibility: hidden ? 'hidden' : 'visible'\n        });\n        this.hidden = hidden;\n      }\n\n      if (!hidden) {\n        this.updateKnob();\n      }\n    }\n  }, {\n    key: 'updateKnob',\n    value: function updateKnob() {\n      var scrollViewSize = this.isVertical ? this.scrollView.size.height : this.scrollView.size.width;\n      var contentSize = this.isVertical ? this.scrollView.contentSize.height : this.scrollView.contentSize.width;\n      var proportion = scrollViewSize / contentSize;\n      var knobHeight = Math.max(MIN_KNOB_HEIGHT, proportion * scrollViewSize);\n      var trackHeight = scrollViewSize - knobHeight - KNOB_PADDING * 2;\n      var x = this.isVertical ? this.scrollView.size.width - this.knobWidth - KNOB_PADDING : KNOB_PADDING + trackHeight * this.value;\n      var y = this.isVertical ? KNOB_PADDING + trackHeight * this.value : this.scrollView.size.height - this.knobWidth - KNOB_PADDING;\n      var minVal = KNOB_PADDING;\n      var maxVal = scrollViewSize - knobHeight - KNOB_PADDING;\n      var val = this.isVertical ? y : x;\n\n      if (val < minVal) {\n        knobHeight = Math.max(MIN_OVERSCROLL_HEIGHT, knobHeight + (val + minVal));\n        val = minVal;\n      } else if (val > maxVal) {\n        knobHeight = Math.max(MIN_OVERSCROLL_HEIGHT, knobHeight - (val - maxVal));\n        val = scrollViewSize - knobHeight - KNOB_PADDING;\n      }\n\n      if (knobHeight !== this.knobHeight) {\n        this.knobHeight = knobHeight;\n        this.trackHeight = scrollViewSize - knobHeight - KNOB_PADDING * 2;\n\n        if (this.isVertical) {\n          this.css({\n            height: this.knobHeight + 'px'\n          });\n        } else {\n          this.css({\n            width: this.knobHeight + 'px'\n          });\n        }\n      }\n\n      var _ref = this.isVertical ? [x, val] : [val, y];\n\n      var _ref2 = _slicedToArray(_ref, 2);\n\n      x = _ref2[0];\n      y = _ref2[1];\n      var transform = 'translate3d(' + x + 'px, ' + y + 'px, 0)';\n      this.css({\n        WebkitTransformorm: transform,\n        transform: transform\n      });\n    }\n  }, {\n    key: 'setValue',\n    value: function setValue(value) {\n      this.value = value;\n      this.updateKnob();\n    }\n  }, {\n    key: 'getDragOffset',\n    value: function getDragOffset(e) {\n      return this.isVertical ? e.clientY - this.scrollView.getRect().y : e.clientX - this.scrollView.getRect().x;\n    }\n  }, {\n    key: 'mouseDown',\n    value: function mouseDown(e) {\n      e.preventDefault();\n      e.stopPropagation();\n      this._mouseDown = true;\n      this._dragOffset = this.getDragOffset(e);\n      this._valueAtDragStart = this.value;\n      document.addEventListener('mousemove', this.mouseMove, false);\n      document.addEventListener('mouseup', this.mouseUp, false);\n    }\n  }, {\n    key: 'mouseMove',\n    value: function mouseMove(e) {\n      e.preventDefault();\n      var offset = this.getDragOffset(e);\n      var delta = offset - this._dragOffset;\n      this.setValue(this._valueAtDragStart + delta / this.trackHeight);\n      var contentOffset = this.scrollView.contentOffset.copy();\n\n      if (this.isVertical) {\n        contentOffset.y = this.value * (this.scrollView.contentSize.height - this.scrollView.size.height);\n      } else {\n        contentOffset.x = this.value * (this.scrollView.contentSize.width - this.scrollView.size.width);\n      }\n\n      this.scrollView.setContentOffset(contentOffset);\n    }\n  }, {\n    key: 'mouseUp',\n    value: function mouseUp(e) {\n      var _this2 = this;\n\n      e.preventDefault();\n      this._mouseDown = false;\n      document.removeEventListener('mousemove', this.mouseMove, false);\n      document.removeEventListener('mouseup', this.mouseUp, false);\n      setTimeout(function () {\n        _this2.hide();\n      }, 1000);\n    }\n  }, {\n    key: 'mouseOver',\n    value: function mouseOver() {\n      this._mouseOver = true;\n    }\n  }, {\n    key: 'mouseOut',\n    value: function mouseOut() {\n      var _this3 = this;\n\n      this._mouseOver = false;\n      setTimeout(function () {\n        _this3.hide();\n      }, 1000);\n    }\n  }, {\n    key: 'show',\n    value: function show() {\n      this.css({\n        opacity: 1\n      });\n    }\n  }, {\n    key: 'hide',\n    value: function hide() {\n      if (!this._mouseOver && !this._mouseDown && !this._scrolling) {\n        this.css({\n          opacity: 0\n        });\n      }\n    }\n  }, {\n    key: 'scrollStarted',\n    value: function scrollStarted() {\n      if (!this._scrolling) {\n        this._scrolling = true;\n        this.show();\n      }\n    }\n  }, {\n    key: 'scrollEnded',\n    value: function scrollEnded() {\n      if (this._scrolling) {\n        this._scrolling = false;\n        this.hide();\n      }\n    }\n  }, {\n    key: 'flash',\n    value: function flash() {\n      var _this4 = this;\n\n      if (this._scrolling || this._mouseDown || this._mouseOver) {\n        return;\n      }\n\n      this.show();\n      setTimeout(function () {\n        _this4.hide();\n      }, 1300);\n    }\n  }]);\n\n  return Scroller;\n}(_View3.default);\n\nexports.default = Scroller;","map":null,"metadata":{},"sourceType":"script"}