{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports.default = function (d3) {\n  d3.timeline = function () {\n    var DISPLAY_TYPES = [\"circle\", \"rect\"];\n\n    var hover = function hover() {},\n        mouseover = function mouseover() {},\n        mouseout = function mouseout() {},\n        click = function click() {},\n        scroll = function scroll() {},\n        labelFunction = function labelFunction(label) {\n      return label;\n    },\n        navigateLeft = function navigateLeft() {},\n        navigateRight = function navigateRight() {},\n        orient = \"bottom\",\n        width = null,\n        height = null,\n        rowSeparatorsColor = null,\n        backgroundColor = null,\n        tickFormat = {\n      format: d3.time.format(\"%I %p\"),\n      tickTime: d3.time.hours,\n      tickInterval: 1,\n      tickSize: 6,\n      tickValues: null\n    },\n        colorCycle = d3.scale.category20(),\n        colorPropertyName = null,\n        display = \"rect\",\n        beginning = 0,\n        labelMargin = 0,\n        ending = 0,\n        margin = {\n      left: 30,\n      right: 30,\n      top: 30,\n      bottom: 30\n    },\n        stacked = false,\n        rotateTicks = false,\n        timeIsRelative = false,\n        fullLengthBackgrounds = false,\n        itemHeight = 20,\n        itemMargin = 5,\n        navMargin = 60,\n        showTimeAxis = true,\n        showAxisTop = false,\n        showTodayLine = false,\n        timeAxisTick = false,\n        timeAxisTickFormat = {\n      stroke: \"stroke-dasharray\",\n      spacing: \"4 10\"\n    },\n        showTodayFormat = {\n      marginTop: 25,\n      marginBottom: 0,\n      width: 1,\n      color: colorCycle\n    },\n        showBorderLine = false,\n        showBorderFormat = {\n      marginTop: 25,\n      marginBottom: 0,\n      width: 1,\n      color: colorCycle\n    },\n        showAxisHeaderBackground = false,\n        showAxisNav = false,\n        showAxisCalendarYear = false,\n        axisBgColor = \"white\",\n        chartData = {};\n\n    var appendTimeAxis = function appendTimeAxis(g, xAxis, yPosition) {\n      if (showAxisHeaderBackground) {\n        appendAxisHeaderBackground(g, 0, 0);\n      }\n\n      if (showAxisNav) {\n        appendTimeAxisNav(g);\n      }\n\n      ;\n      var axis = g.append(\"g\").attr(\"class\", \"axis\").attr(\"transform\", \"translate(\" + 0 + \",\" + yPosition + \")\").call(xAxis);\n    };\n\n    var appendTimeAxisCalendarYear = function appendTimeAxisCalendarYear(nav) {\n      var calendarLabel = beginning.getFullYear();\n\n      if (beginning.getFullYear() != ending.getFullYear()) {\n        calendarLabel = beginning.getFullYear() + \"-\" + ending.getFullYear();\n      }\n\n      nav.append(\"text\").attr(\"transform\", \"translate(\" + 20 + \", 0)\").attr(\"x\", 0).attr(\"y\", 14).attr(\"class\", \"calendarYear\").text(calendarLabel);\n    };\n\n    var appendTimeAxisNav = function appendTimeAxisNav(g) {\n      var timelineBlocks = 6;\n      var leftNavMargin = margin.left - navMargin;\n      var incrementValue = (width - margin.left) / timelineBlocks;\n      var rightNavMargin = width - margin.right - incrementValue + navMargin;\n      var nav = g.append('g').attr(\"class\", \"axis\").attr(\"transform\", \"translate(0, 20)\");\n\n      if (showAxisCalendarYear) {\n        appendTimeAxisCalendarYear(nav);\n      }\n\n      ;\n      nav.append(\"text\").attr(\"transform\", \"translate(\" + leftNavMargin + \", 0)\").attr(\"x\", 0).attr(\"y\", 14).attr(\"class\", \"chevron\").text(\"<\").on(\"click\", function () {\n        return navigateLeft(beginning, chartData);\n      });\n      nav.append(\"text\").attr(\"transform\", \"translate(\" + rightNavMargin + \", 0)\").attr(\"x\", 0).attr(\"y\", 14).attr(\"class\", \"chevron\").text(\">\").on(\"click\", function () {\n        return navigateRight(ending, chartData);\n      });\n    };\n\n    var appendAxisHeaderBackground = function appendAxisHeaderBackground(g, xAxis, yAxis) {\n      g.insert(\"rect\").attr(\"class\", \"row-green-bar\").attr(\"x\", xAxis).attr(\"width\", width).attr(\"y\", yAxis).attr(\"height\", itemHeight).attr(\"fill\", axisBgColor);\n    };\n\n    var appendTimeAxisTick = function appendTimeAxisTick(g, xAxis, maxStack) {\n      g.append(\"g\").attr(\"class\", \"axis\").attr(\"transform\", \"translate(\" + 0 + \",\" + (margin.top + (itemHeight + itemMargin) * maxStack) + \")\").attr(timeAxisTickFormat.stroke, timeAxisTickFormat.spacing).call(xAxis.tickFormat(\"\").tickSize(-(margin.top + (itemHeight + itemMargin) * (maxStack - 1) + 3), 0, 0));\n    };\n\n    var appendBackgroundBar = function appendBackgroundBar(yAxisMapping, index, g, data, datum) {\n      var greenbarYAxis = (itemHeight + itemMargin) * yAxisMapping[index] + margin.top;\n      g.selectAll(\"svg\").data(data).enter().insert(\"rect\").attr(\"class\", \"row-green-bar\").attr(\"x\", fullLengthBackgrounds ? 0 : margin.left).attr(\"width\", fullLengthBackgrounds ? width : width - margin.right - margin.left).attr(\"y\", greenbarYAxis).attr(\"height\", itemHeight).attr(\"fill\", backgroundColor instanceof Function ? backgroundColor(datum, index) : backgroundColor);\n    };\n\n    var appendLabel = function appendLabel(gParent, yAxisMapping, index, hasLabel, datum) {\n      var fullItemHeight = itemHeight + itemMargin;\n      var rowsDown = margin.top + fullItemHeight / 2 + fullItemHeight * (yAxisMapping[index] || 1);\n      gParent.append(\"text\").attr(\"class\", \"timeline-label\").attr(\"transform\", \"translate(\" + labelMargin + \",\" + rowsDown + \")\").text(hasLabel ? labelFunction(datum.label) : datum.id).on(\"click\", function (d, i) {\n        click(d, index, datum);\n      });\n    };\n\n    function timeline(gParent) {\n      var g = gParent.append(\"g\");\n      var gParentSize = gParent[0][0].getBoundingClientRect();\n      var gParentItem = d3.select(gParent[0][0]);\n      var yAxisMapping = {},\n          maxStack = 1,\n          minTime = 0,\n          maxTime = 0;\n      setWidth(); // check if the user wants relative time\n      // if so, substract the first timestamp from each subsequent timestamps\n\n      if (timeIsRelative) {\n        var originTime;\n        g.each(function (d, i) {\n          d.forEach(function (datum, index) {\n            datum.times.forEach(function (time, j) {\n              if (index === 0 && j === 0) {\n                originTime = time.starting_time; //Store the timestamp that will serve as origin\n\n                time.starting_time = 0; //Set the origin\n\n                time.ending_time = time.ending_time - originTime; //Store the relative time (millis)\n              } else {\n                time.starting_time = time.starting_time - originTime;\n                time.ending_time = time.ending_time - originTime;\n              }\n            });\n          });\n        });\n      } // check how many stacks we're gonna need\n      // do this here so that we can draw the axis before the graph\n\n\n      if (stacked || ending === 0 || beginning === 0) {\n        g.each(function (d, i) {\n          d.forEach(function (datum, index) {\n            // create y mapping for stacked graph\n            if (stacked && Object.keys(yAxisMapping).indexOf(index) == -1) {\n              yAxisMapping[index] = maxStack;\n              maxStack++;\n            } // figure out beginning and ending times if they are unspecified\n\n\n            datum.times.forEach(function (time, i) {\n              if (beginning === 0) if (time.starting_time < minTime || minTime === 0 && timeIsRelative === false) minTime = time.starting_time;\n              if (ending === 0) if (time.ending_time > maxTime) maxTime = time.ending_time;\n            });\n          });\n        });\n\n        if (ending === 0) {\n          ending = maxTime;\n        }\n\n        if (beginning === 0) {\n          beginning = minTime;\n        }\n      }\n\n      var scaleFactor = 1 / (ending - beginning) * (width - margin.left - margin.right); // draw the axis\n\n      var xScale = d3.time.scale().domain([beginning, ending]).range([margin.left, width - margin.right]);\n      var xAxis = d3.svg.axis().scale(xScale).orient(orient).tickFormat(tickFormat.format).tickSize(tickFormat.tickSize);\n\n      if (tickFormat.tickValues != null) {\n        xAxis.tickValues(tickFormat.tickValues);\n      } else {\n        xAxis.ticks(tickFormat.numTicks || tickFormat.tickTime, tickFormat.tickInterval);\n      } // draw the chart\n\n\n      g.each(function (d, i) {\n        chartData = d;\n        d.forEach(function (datum, index) {\n          var data = datum.times;\n          var hasLabel = typeof datum.label != \"undefined\"; // issue warning about using id per data set. Ids should be individual to data elements\n\n          if (typeof datum.id != \"undefined\") {\n            console.warn(\"d3Timeline Warning: Ids per dataset is deprecated in favor of a 'class' key. Ids are now per data element.\");\n          }\n\n          if (backgroundColor) {\n            appendBackgroundBar(yAxisMapping, index, g, data, datum);\n          }\n\n          g.selectAll(\"svg\").data(data).enter().append(function (d, i) {\n            return document.createElementNS(d3.ns.prefix.svg, \"display\" in d ? d.display : display);\n          }).attr(\"x\", getXPos).attr(\"y\", getStackPosition).attr(\"width\", function (d, i) {\n            return (d.ending_time - d.starting_time) * scaleFactor;\n          }).attr(\"cy\", function (d, i) {\n            return getStackPosition(d, i) + itemHeight / 2;\n          }).attr(\"cx\", getXPos).attr(\"r\", itemHeight / 2).attr(\"height\", itemHeight).style(\"fill\", function (d, i) {\n            var dColorPropName;\n            if (d.color) return d.color;\n\n            if (colorPropertyName) {\n              dColorPropName = d[colorPropertyName];\n\n              if (dColorPropName) {\n                return colorCycle(dColorPropName);\n              } else {\n                return colorCycle(datum[colorPropertyName]);\n              }\n            }\n\n            return colorCycle(index);\n          }).on(\"mousemove\", function (d, i) {\n            hover(d, index, datum);\n          }).on(\"mouseover\", function (d, i) {\n            mouseover(d, i, datum);\n          }).on(\"mouseout\", function (d, i) {\n            mouseout(d, i, datum);\n          }).on(\"click\", function (d, i) {\n            click(d, index, datum);\n          }).attr(\"class\", function (d, i) {\n            return datum.class ? \"timelineSeries_\" + datum.class : \"timelineSeries_\" + index;\n          }).attr(\"id\", function (d, i) {\n            // use deprecated id field\n            if (datum.id && !d.id) {\n              return 'timelineItem_' + datum.id;\n            }\n\n            return d.id ? d.id : \"timelineItem_\" + index + \"_\" + i;\n          });\n          g.selectAll(\"svg\").data(data).enter().append(\"text\").attr(\"x\", getXTextPos).attr(\"y\", getStackTextPosition).text(function (d) {\n            return d.label;\n          });\n\n          if (rowSeparatorsColor) {\n            var lineYAxis = itemHeight + itemMargin / 2 + margin.top + (itemHeight + itemMargin) * yAxisMapping[index];\n            gParent.append(\"svg:line\").attr(\"class\", \"row-separator\").attr(\"x1\", 0 + margin.left).attr(\"x2\", width - margin.right).attr(\"y1\", lineYAxis).attr(\"y2\", lineYAxis).attr(\"stroke-width\", 1).attr(\"stroke\", rowSeparatorsColor);\n          } // add the label\n\n\n          if (hasLabel) {\n            appendLabel(gParent, yAxisMapping, index, hasLabel, datum);\n          }\n\n          if (typeof datum.icon !== \"undefined\") {\n            gParent.append(\"image\").attr(\"class\", \"timeline-label\").attr(\"transform\", \"translate(\" + 0 + \",\" + (margin.top + (itemHeight + itemMargin) * yAxisMapping[index]) + \")\").attr(\"xlink:href\", datum.icon).attr(\"width\", margin.left).attr(\"height\", itemHeight);\n          }\n\n          function getStackPosition(d, i) {\n            if (stacked) {\n              return margin.top + (itemHeight + itemMargin) * yAxisMapping[index];\n            }\n\n            return margin.top;\n          }\n\n          function getStackTextPosition(d, i) {\n            if (stacked) {\n              return margin.top + (itemHeight + itemMargin) * yAxisMapping[index] + itemHeight * 0.75;\n            }\n\n            return margin.top + itemHeight * 0.75;\n          }\n        });\n      });\n      var belowLastItem = margin.top + (itemHeight + itemMargin) * maxStack;\n      var aboveFirstItem = margin.top;\n      var timeAxisYPosition = showAxisTop ? aboveFirstItem : belowLastItem;\n\n      if (showTimeAxis) {\n        appendTimeAxis(g, xAxis, timeAxisYPosition);\n      }\n\n      if (timeAxisTick) {\n        appendTimeAxisTick(g, xAxis, maxStack);\n      }\n\n      if (width > gParentSize.width) {\n        var move = function move() {\n          var x = Math.min(0, Math.max(gParentSize.width - width, d3.event.translate[0]));\n          zoom.translate([x, 0]);\n          g.attr(\"transform\", \"translate(\" + x + \",0)\");\n          scroll(x * scaleFactor, xScale);\n        };\n\n        var zoom = d3.behavior.zoom().x(xScale).on(\"zoom\", move);\n        gParent.attr(\"class\", \"scrollable\").call(zoom);\n      }\n\n      if (rotateTicks) {\n        g.selectAll(\".tick text\").attr(\"transform\", function (d) {\n          return \"rotate(\" + rotateTicks + \")translate(\" + (this.getBBox().width / 2 + 10) + \",\" // TODO: change this 10\n          + this.getBBox().height / 2 + \")\";\n        });\n      }\n\n      var gSize = g[0][0].getBoundingClientRect();\n      setHeight();\n\n      if (showBorderLine) {\n        g.each(function (d, i) {\n          d.forEach(function (datum) {\n            var times = datum.times;\n            times.forEach(function (time) {\n              appendLine(xScale(time.starting_time), showBorderFormat);\n              appendLine(xScale(time.ending_time), showBorderFormat);\n            });\n          });\n        });\n      }\n\n      if (showTodayLine) {\n        var todayLine = xScale(new Date());\n        appendLine(todayLine, showTodayFormat);\n      }\n\n      function getXPos(d, i) {\n        return margin.left + (d.starting_time - beginning) * scaleFactor;\n      }\n\n      function getXTextPos(d, i) {\n        return margin.left + (d.starting_time - beginning) * scaleFactor + 5;\n      }\n\n      function setHeight() {\n        if (!height && !gParentItem.attr(\"height\")) {\n          if (itemHeight) {\n            // set height based off of item height\n            height = gSize.height + gSize.top - gParentSize.top; // set bounding rectangle height\n\n            d3.select(gParent[0][0]).attr(\"height\", height);\n          } else {\n            throw \"height of the timeline is not set\";\n          }\n        } else {\n          if (!height) {\n            height = gParentItem.attr(\"height\");\n          } else {\n            gParentItem.attr(\"height\", height);\n          }\n        }\n      }\n\n      function setWidth() {\n        if (!width && !gParentSize.width) {\n          try {\n            width = gParentItem.attr(\"width\");\n\n            if (!width) {\n              throw \"width of the timeline is not set. As of Firefox 27, timeline().with(x) needs to be explicitly set in order to render\";\n            }\n          } catch (err) {\n            console.log(err);\n          }\n        } else if (!(width && gParentSize.width)) {\n          try {\n            width = gParentItem.attr(\"width\");\n          } catch (err) {\n            console.log(err);\n          }\n        } // if both are set, do nothing\n\n      }\n\n      function appendLine(lineScale, lineFormat) {\n        gParent.append(\"svg:line\").attr(\"x1\", lineScale).attr(\"y1\", lineFormat.marginTop).attr(\"x2\", lineScale).attr(\"y2\", height - lineFormat.marginBottom).style(\"stroke\", lineFormat.color) //\"rgb(6,120,155)\")\n        .style(\"stroke-width\", lineFormat.width);\n      }\n    } // SETTINGS\n\n\n    timeline.margin = function (p) {\n      if (!arguments.length) return margin;\n      margin = p;\n      return timeline;\n    };\n\n    timeline.orient = function (orientation) {\n      if (!arguments.length) return orient;\n      orient = orientation;\n      return timeline;\n    };\n\n    timeline.itemHeight = function (h) {\n      if (!arguments.length) return itemHeight;\n      itemHeight = h;\n      return timeline;\n    };\n\n    timeline.itemMargin = function (h) {\n      if (!arguments.length) return itemMargin;\n      itemMargin = h;\n      return timeline;\n    };\n\n    timeline.navMargin = function (h) {\n      if (!arguments.length) return navMargin;\n      navMargin = h;\n      return timeline;\n    };\n\n    timeline.height = function (h) {\n      if (!arguments.length) return height;\n      height = h;\n      return timeline;\n    };\n\n    timeline.width = function (w) {\n      if (!arguments.length) return width;\n      width = w;\n      return timeline;\n    };\n\n    timeline.display = function (displayType) {\n      if (!arguments.length || DISPLAY_TYPES.indexOf(displayType) == -1) return display;\n      display = displayType;\n      return timeline;\n    };\n\n    timeline.labelFormat = function (f) {\n      if (!arguments.length) return labelFunction;\n      labelFunction = f;\n      return timeline;\n    };\n\n    timeline.tickFormat = function (format) {\n      if (!arguments.length) return tickFormat;\n      tickFormat = format;\n      return timeline;\n    };\n\n    timeline.hover = function (hoverFunc) {\n      if (!arguments.length) return hover;\n      hover = hoverFunc;\n      return timeline;\n    };\n\n    timeline.mouseover = function (mouseoverFunc) {\n      if (!arguments.length) return mouseover;\n      mouseover = mouseoverFunc;\n      return timeline;\n    };\n\n    timeline.mouseout = function (mouseoutFunc) {\n      if (!arguments.length) return mouseout;\n      mouseout = mouseoutFunc;\n      return timeline;\n    };\n\n    timeline.click = function (clickFunc) {\n      if (!arguments.length) return click;\n      click = clickFunc;\n      return timeline;\n    };\n\n    timeline.scroll = function (scrollFunc) {\n      if (!arguments.length) return scroll;\n      scroll = scrollFunc;\n      return timeline;\n    };\n\n    timeline.colors = function (colorFormat) {\n      if (!arguments.length) return colorCycle;\n      colorCycle = colorFormat;\n      return timeline;\n    };\n\n    timeline.beginning = function (b) {\n      if (!arguments.length) return beginning;\n      beginning = b;\n      return timeline;\n    };\n\n    timeline.ending = function (e) {\n      if (!arguments.length) return ending;\n      ending = e;\n      return timeline;\n    };\n\n    timeline.labelMargin = function (m) {\n      if (!arguments.length) return labelMargin;\n      labelMargin = m;\n      return timeline;\n    };\n\n    timeline.rotateTicks = function (degrees) {\n      if (!arguments.length) return rotateTicks;\n      rotateTicks = degrees;\n      return timeline;\n    };\n\n    timeline.stack = function () {\n      stacked = !stacked;\n      return timeline;\n    };\n\n    timeline.relativeTime = function () {\n      timeIsRelative = !timeIsRelative;\n      return timeline;\n    };\n\n    timeline.showBorderLine = function () {\n      showBorderLine = !showBorderLine;\n      return timeline;\n    };\n\n    timeline.showBorderFormat = function (borderFormat) {\n      if (!arguments.length) return showBorderFormat;\n      showBorderFormat = borderFormat;\n      return timeline;\n    };\n\n    timeline.showToday = function () {\n      showTodayLine = !showTodayLine;\n      return timeline;\n    };\n\n    timeline.showTodayFormat = function (todayFormat) {\n      if (!arguments.length) return showTodayFormat;\n      showTodayFormat = todayFormat;\n      return timeline;\n    };\n\n    timeline.colorProperty = function (colorProp) {\n      if (!arguments.length) return colorPropertyName;\n      colorPropertyName = colorProp;\n      return timeline;\n    };\n\n    timeline.rowSeparators = function (color) {\n      if (!arguments.length) return rowSeparatorsColor;\n      rowSeparatorsColor = color;\n      return timeline;\n    };\n\n    timeline.background = function (color) {\n      if (!arguments.length) return backgroundColor;\n      backgroundColor = color;\n      return timeline;\n    };\n\n    timeline.showTimeAxis = function () {\n      showTimeAxis = !showTimeAxis;\n      return timeline;\n    };\n\n    timeline.showAxisTop = function () {\n      showAxisTop = !showAxisTop;\n      return timeline;\n    };\n\n    timeline.showAxisCalendarYear = function () {\n      showAxisCalendarYear = !showAxisCalendarYear;\n      return timeline;\n    };\n\n    timeline.showTimeAxisTick = function () {\n      timeAxisTick = !timeAxisTick;\n      return timeline;\n    };\n\n    timeline.fullLengthBackgrounds = function () {\n      fullLengthBackgrounds = !fullLengthBackgrounds;\n      return timeline;\n    };\n\n    timeline.showTimeAxisTickFormat = function (format) {\n      if (!arguments.length) return timeAxisTickFormat;\n      timeAxisTickFormat = format;\n      return timeline;\n    };\n\n    timeline.showAxisHeaderBackground = function (bgColor) {\n      showAxisHeaderBackground = !showAxisHeaderBackground;\n\n      if (bgColor) {\n        axisBgColor = bgColor;\n      }\n\n      ;\n      return timeline;\n    };\n\n    timeline.navigate = function (navigateBackwards, navigateForwards) {\n      if (!arguments.length) return [navigateLeft, navigateRight];\n      navigateLeft = navigateBackwards;\n      navigateRight = navigateForwards;\n      showAxisNav = !showAxisNav;\n      return timeline;\n    };\n\n    return timeline;\n  };\n\n  return d3;\n};\n\n; // vim: ts=2 sw=2","map":null,"metadata":{},"sourceType":"script"}