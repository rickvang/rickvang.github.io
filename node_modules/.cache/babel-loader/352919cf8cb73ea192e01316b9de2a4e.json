{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _get = function get(object, property, receiver) {\n  if (object === null) object = Function.prototype;\n  var desc = Object.getOwnPropertyDescriptor(object, property);\n\n  if (desc === undefined) {\n    var parent = Object.getPrototypeOf(object);\n\n    if (parent === null) {\n      return undefined;\n    } else {\n      return get(parent, property, receiver);\n    }\n  } else if (\"value\" in desc) {\n    return desc.value;\n  } else {\n    var getter = desc.get;\n\n    if (getter === undefined) {\n      return undefined;\n    }\n\n    return getter.call(receiver);\n  }\n};\n\nvar _DragTarget = require('./DragTarget');\n\nvar _DragTarget2 = _interopRequireDefault(_DragTarget);\n\nvar _IndexPath = require('./IndexPath');\n\nvar _IndexPath2 = _interopRequireDefault(_IndexPath);\n\nvar _Layout2 = require('./Layout');\n\nvar _Layout3 = _interopRequireDefault(_Layout2);\n\nvar _LayoutInfo = require('./LayoutInfo');\n\nvar _LayoutInfo2 = _interopRequireDefault(_LayoutInfo);\n\nvar _Rect = require('./Rect');\n\nvar _Rect2 = _interopRequireDefault(_Rect);\n\nvar _Size = require('./Size');\n\nvar _Size2 = _interopRequireDefault(_Size);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar MARGIN = 20;\nvar SECTION_SPACING = 20;\nvar SECTION_HEADER_HEIGHT = 50;\nvar DRAG_SPACING = 100;\nvar ACTIVE_USER_WIDTH = 140;\nvar SMALL_ACTIVE_USER_WIDTH = 36;\nvar MIN_SECTION_WIDTH = 260;\nvar FOOTER_HEIGHT = 45;\nvar ELEMENT_MARGIN = 6;\n\nvar StackLayout = function (_Layout) {\n  _inherits(StackLayout, _Layout);\n\n  function StackLayout() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, StackLayout);\n\n    var _this = _possibleConstructorReturn(this, (StackLayout.__proto__ || Object.getPrototypeOf(StackLayout)).call(this));\n\n    _this.layoutInfo = [];\n    _this.headers = [];\n    _this.footers = [];\n    _this.activeUsers = [];\n    _this.showActiveSessions = options.showActiveSessions || false;\n    _this.showHeaders = options.showHeaders !== false;\n    _this.showFooters = options.showFooters || false;\n    _this.elementSpacing = options.elementSpacing || 0;\n    _this.dragSpacing = options.dragSpacing != null ? options.dragSpacing : DRAG_SPACING;\n    return _this;\n  }\n\n  _createClass(StackLayout, [{\n    key: 'getLayoutInfo',\n    value: function getLayoutInfo(type, section, index) {\n      if (type === 'item') {\n        return this.layoutInfo[section] && this.layoutInfo[section][index];\n      }\n\n      if (type === 'activeUsers') {\n        return this.activeUsers[section] && this.activeUsers[section][index];\n      }\n\n      if (type === 'header') {\n        return this.headers[section];\n      }\n\n      if (type === 'footer') {\n        return this.footers[section];\n      }\n    }\n  }, {\n    key: 'validate',\n    value: function validate(invalidationContext) {\n      var oldLayoutInfo = this.layoutInfo;\n      this.layoutInfo = [];\n      this.headers = [];\n      this.footers = [];\n      this.activeUsers = [];\n      var delegate = this.collectionView.delegate;\n      var offset = this.showHeaders ? MARGIN : 0;\n      var dropTarget = this.collectionView._dropTarget; // TODO: faster algorithm using invalidIndices...\n\n      var numSections = this.collectionView.getNumberOfSections();\n\n      for (var sectionIndex = 0; sectionIndex < numSections; sectionIndex++) {\n        var sectionLength = this.collectionView.getSectionLength(sectionIndex);\n\n        if (!this.layoutInfo[sectionIndex]) {\n          this.layoutInfo[sectionIndex] = [];\n        }\n\n        if (this.showActiveSessions && !this.activeUsers[sectionIndex]) {\n          this.activeUsers[sectionIndex] = [];\n        }\n\n        if (sectionIndex > 0) {\n          offset += SECTION_SPACING;\n        }\n\n        if (dropTarget && dropTarget.type === 'section' && dropTarget.indexPath.section === sectionIndex) {\n          offset += this.dragSpacing;\n        }\n\n        var header = null;\n        var sectionStart = offset;\n        var lmargin = this.showHeaders ? MARGIN : 0;\n        var rmargin = 0;\n\n        if (this.showActiveSessions) {\n          rmargin = ACTIVE_USER_WIDTH;\n        } else if (this.showHeaders) {\n          rmargin = MARGIN;\n        }\n\n        var postWidth = this.collectionView.size.width - lmargin - rmargin;\n\n        if (this.showHeaders && postWidth < MIN_SECTION_WIDTH) {\n          if (this.showActiveSessions) {\n            rmargin = SMALL_ACTIVE_USER_WIDTH;\n          }\n\n          postWidth = Math.max(MIN_SECTION_WIDTH, this.collectionView.size.width - lmargin - rmargin);\n        } // Post background view\n\n\n        if (this.showHeaders) {\n          header = new _LayoutInfo2.default('header', sectionIndex);\n          header.rect = new _Rect2.default(MARGIN, offset, postWidth, SECTION_HEADER_HEIGHT);\n          header.zIndex = -1;\n          this.headers[sectionIndex] = header;\n          offset += SECTION_HEADER_HEIGHT;\n        }\n\n        var elementMargin = this.showHeaders ? ELEMENT_MARGIN : 0;\n\n        for (var index = 0; index < sectionLength; index++) {\n          if (dropTarget && dropTarget.type === 'item' && dropTarget.indexPath.section === sectionIndex && dropTarget.indexPath.index === index) {\n            offset += this.dragSpacing;\n          }\n\n          if (index > 0) {\n            offset += this.elementSpacing;\n          } // Use the last (non-estimated) height if possible\n\n\n          var old = oldLayoutInfo[sectionIndex] && oldLayoutInfo[sectionIndex][index];\n          var height = old ? old.rect.height : delegate.estimateSize(this.collectionView.getItem(sectionIndex, index)).height; // Create the layout info for the content view\n\n          var layoutInfo = new _LayoutInfo2.default('item', sectionIndex, index);\n          layoutInfo.rect = new _Rect2.default(lmargin + elementMargin, offset, postWidth - elementMargin * 2, height);\n          layoutInfo.estimatedSize = invalidationContext.sizeChanged || (old ? old.estimatedSize : true);\n          this.layoutInfo[sectionIndex][index] = layoutInfo; // Create an extra view to show active sessions for an element if needed\n\n          if (this.showActiveSessions) {\n            var activeUsers = activeUsers = new _LayoutInfo2.default('activeUsers', sectionIndex, index);\n            activeUsers.rect = new _Rect2.default(lmargin + postWidth, layoutInfo.rect.y, rmargin, layoutInfo.rect.height);\n            this.activeUsers[sectionIndex][index] = activeUsers;\n          }\n\n          if (layoutInfo.estimatedSize && !invalidationContext.contentChanged) {\n            this.updateItemSize(new _IndexPath2.default(sectionIndex, index));\n          }\n\n          offset += layoutInfo.rect.height;\n        } // Add space at the bottom of the section if the index is past the end\n\n\n        if (dropTarget && dropTarget.type === 'item' && dropTarget.indexPath.section === sectionIndex && dropTarget.indexPath.index === sectionLength) {\n          offset += this.dragSpacing;\n        }\n\n        if (this.showHeaders) {\n          offset += MARGIN;\n        }\n\n        if (this.showFooters) {\n          var footer = new _LayoutInfo2.default('footer', sectionIndex);\n          footer.rect = new _Rect2.default(MARGIN, offset, postWidth, FOOTER_HEIGHT);\n          footer.zIndex = 2;\n          this.footers[sectionIndex] = footer;\n          offset += FOOTER_HEIGHT;\n        }\n\n        if (header) {\n          header.rect.height = offset - sectionStart;\n        }\n      }\n\n      this.contentHeight = offset + (this.showHeaders ? MARGIN : 0);\n    }\n  }, {\n    key: 'getVisibleLayoutInfos',\n    value: function getVisibleLayoutInfos(rect) {\n      var res = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.headers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var header = _step.value;\n\n          if (header.rect.intersects(rect)) {\n            res.push(header);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.footers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var footer = _step2.value;\n\n          if (footer.rect.intersects(rect)) {\n            res.push(footer);\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.layoutInfo[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _section = _step3.value;\n          var _iteratorNormalCompletion6 = true;\n          var _didIteratorError6 = false;\n          var _iteratorError6 = undefined;\n\n          try {\n            for (var _iterator6 = _section[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n              var _layoutInfo = _step6.value;\n\n              if (_layoutInfo.rect.intersects(rect)) {\n                res.push(_layoutInfo);\n              }\n            }\n          } catch (err) {\n            _didIteratorError6 = true;\n            _iteratorError6 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion6 && _iterator6.return) {\n                _iterator6.return();\n              }\n            } finally {\n              if (_didIteratorError6) {\n                throw _iteratorError6;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      if (this.showActiveSessions) {\n        var _iteratorNormalCompletion4 = true;\n        var _didIteratorError4 = false;\n        var _iteratorError4 = undefined;\n\n        try {\n          for (var _iterator4 = this.activeUsers[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n            var section = _step4.value;\n            var _iteratorNormalCompletion5 = true;\n            var _didIteratorError5 = false;\n            var _iteratorError5 = undefined;\n\n            try {\n              for (var _iterator5 = section[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n                var layoutInfo = _step5.value;\n\n                if (layoutInfo.rect.intersects(rect)) {\n                  res.push(layoutInfo);\n                }\n              }\n            } catch (err) {\n              _didIteratorError5 = true;\n              _iteratorError5 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion5 && _iterator5.return) {\n                  _iterator5.return();\n                }\n              } finally {\n                if (_didIteratorError5) {\n                  throw _iteratorError5;\n                }\n              }\n            }\n          }\n        } catch (err) {\n          _didIteratorError4 = true;\n          _iteratorError4 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion4 && _iterator4.return) {\n              _iterator4.return();\n            }\n          } finally {\n            if (_didIteratorError4) {\n              throw _iteratorError4;\n            }\n          }\n        }\n      }\n\n      return res;\n    }\n  }, {\n    key: 'updateItemSize',\n    value: function updateItemSize(indexPath) {\n      var section = indexPath.section,\n          index = indexPath.index;\n      var view = this.collectionView.getItemView(section, index);\n\n      if (!view) {\n        return false;\n      }\n\n      var layoutInfo = this.layoutInfo[section][index];\n      var size = view.getSize();\n\n      if (size.height !== layoutInfo.rect.height) {\n        layoutInfo.rect.height = size.height;\n        layoutInfo.estimatedSize = view.estimatedSize || false;\n\n        if (this.showActiveSessions) {\n          this.activeUsers[section][index].rect.height = size.height;\n        }\n\n        return true;\n      }\n\n      return false;\n    }\n  }, {\n    key: 'findGap',\n    value: function findGap(point, layoutInfos) {\n      if (!layoutInfos.length) {\n        return 0;\n      }\n\n      var low = 0;\n      var high = layoutInfos.length - 1;\n\n      if (point.y < layoutInfos[0].rect.y) {\n        return 0;\n      }\n\n      if (point.y > layoutInfos[high].rect.maxY) {\n        return layoutInfos.length;\n      }\n\n      while (low < high) {\n        var mid = low + high >> 1;\n        var header = layoutInfos[mid];\n        var next = layoutInfos[mid + 1];\n\n        if (point.y < header.rect.maxY) {\n          high = mid;\n        } else if (point.y > next.rect.y) {\n          low = mid + 1;\n        } else {\n          return mid + 1;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: 'sectionGapAtPoint',\n    value: function sectionGapAtPoint(point) {\n      if (this.showHeaders) {\n        return this.findGap(point, this.headers);\n      }\n    }\n  }, {\n    key: 'gapAtPoint',\n    value: function gapAtPoint(point) {\n      var rmargin = this.showActiveSessions ? ACTIVE_USER_WIDTH : MARGIN;\n\n      if (point.x < MARGIN || point.x > this.collectionView.size.width - rmargin) {\n        return null;\n      }\n\n      var visible = this.getVisibleLayoutInfos(new _Rect2.default(point.x, point.y, 1, 1));\n\n      if (visible.length === 0) {\n        var section = this.sectionGapAtPoint(point);\n\n        if (section != null) {\n          return new _IndexPath2.default(section);\n        }\n      }\n\n      if (visible.length === 1 && visible[0].type === 'header') {\n        if (point.y < visible[0].rect.y + 30) {\n          return null;\n        }\n\n        var _section2 = visible[0].section;\n        var index = this.findGap(point, this.layoutInfo[_section2]);\n\n        if (index != null) {\n          return new _IndexPath2.default(_section2, index);\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: 'getDragTarget',\n    value: function getDragTarget(point) {\n      var visible = this.getVisibleLayoutInfos(new _Rect2.default(point.x, point.y, 1, 1));\n\n      if (visible.length === 0) {\n        return null;\n      }\n\n      visible.sort(function (a, b) {\n        return b.zIndex - a.zIndex;\n      });\n      var indexPath = new _IndexPath2.default(visible[0].section, visible[0].index);\n      var type = visible[0].type === 'item' ? 'item' : 'section';\n      return new _DragTarget2.default(type, indexPath);\n    }\n  }, {\n    key: 'getDropTarget',\n    value: function getDropTarget(point) {\n      var sectionDrag = this.collectionView._dragTarget && this.collectionView._dragTarget.type === 'section';\n\n      if (sectionDrag) {\n        var visible = this.getVisibleLayoutInfos(new _Rect2.default(point.x, point.y, 1, 1));\n        var _iteratorNormalCompletion7 = true;\n        var _didIteratorError7 = false;\n        var _iteratorError7 = undefined;\n\n        try {\n          for (var _iterator7 = visible[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n            var _layoutInfo2 = _step7.value;\n\n            if (_layoutInfo2.type === 'header') {\n              return new _DragTarget2.default('section', new _IndexPath2.default(_layoutInfo2.section, 0));\n            }\n          }\n        } catch (err) {\n          _didIteratorError7 = true;\n          _iteratorError7 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion7 && _iterator7.return) {\n              _iterator7.return();\n            }\n          } finally {\n            if (_didIteratorError7) {\n              throw _iteratorError7;\n            }\n          }\n        }\n      }\n\n      var gap = this.sectionGapAtPoint(point);\n\n      if (gap != null) {\n        return new _DragTarget2.default('section', new _IndexPath2.default(gap, 0));\n      }\n\n      if (sectionDrag) {\n        return this._dropTarget;\n      }\n\n      var indexPath = this.collectionView.indexPathAtPoint(point);\n\n      if (!indexPath) {\n        // If we're not showing headers, there should be only 1 section.\n        // Find a gap between items in that section.\n        if (!this.showHeaders && this.layoutInfo.length > 0) {\n          var _gap = this.findGap(point, this.layoutInfo[0]);\n\n          if (_gap != null) {\n            return new _DragTarget2.default('item', new _IndexPath2.default(0, _gap));\n          }\n        }\n\n        return this._dropTarget;\n      } // Increment index path if past the center\n\n\n      var layoutInfo = this.getLayoutInfo('item', indexPath.section, indexPath.index);\n      var rowY = point.y - layoutInfo.rect.y;\n\n      if (rowY > layoutInfo.rect.height / 2) {\n        indexPath.index++;\n      }\n\n      this._dropTarget = new _DragTarget2.default('item', indexPath);\n      return this._dropTarget;\n    }\n  }, {\n    key: 'itemInserted',\n    value: function itemInserted(indexPath) {\n      this.layoutInfo[indexPath.section].splice(indexPath.index, 0, null);\n    }\n  }, {\n    key: 'itemRemoved',\n    value: function itemRemoved(indexPath) {\n      this.layoutInfo[indexPath.section].splice(indexPath.index, 1);\n    }\n  }, {\n    key: 'itemMoved',\n    value: function itemMoved(from, to) {\n      var layoutInfo = this.layoutInfo[from.section].splice(from.index, 1)[0];\n      this.layoutInfo[to.section].splice(to.index, 0, layoutInfo);\n    }\n  }, {\n    key: 'itemReplaced',\n    value: function itemReplaced(indexPath) {\n      this.layoutInfo[indexPath.section][indexPath.index] = null;\n    }\n  }, {\n    key: 'sectionInserted',\n    value: function sectionInserted(section) {\n      this.layoutInfo.splice(section, 0, []);\n    }\n  }, {\n    key: 'sectionRemoved',\n    value: function sectionRemoved(section) {\n      this.layoutInfo.splice(section, 1);\n    }\n  }, {\n    key: 'sectionMoved',\n    value: function sectionMoved(fromSection, toSection) {\n      var section = this.layoutInfo.splice(fromSection, 1)[0];\n      this.layoutInfo.splice(toSection, 0, section);\n    }\n  }, {\n    key: 'sectionReplaced',\n    value: function sectionReplaced(section) {\n      this.layoutInfo[section] = [];\n    }\n  }, {\n    key: 'getInitialLayoutInfo',\n    value: function getInitialLayoutInfo(type, section, index) {\n      var initial = _get(StackLayout.prototype.__proto__ || Object.getPrototypeOf(StackLayout.prototype), 'getInitialLayoutInfo', this).call(this, type, section, index);\n\n      initial.opacity = 0;\n      initial.transform = 'scale3d(0.8, 0.8, 0.8)';\n      return initial;\n    }\n  }, {\n    key: 'getContentSize',\n    value: function getContentSize() {\n      return new _Size2.default(this.collectionView.size.width, this.contentHeight);\n    }\n  }, {\n    key: 'getFinalLayoutInfo',\n    value: function getFinalLayoutInfo(type, section, index) {\n      var final = _get(StackLayout.prototype.__proto__ || Object.getPrototypeOf(StackLayout.prototype), 'getFinalLayoutInfo', this).call(this, type, section, index);\n\n      final.opacity = 0;\n      final.transform = 'scale3d(0.8, 0.8, 0.8)';\n      return final;\n    }\n  }, {\n    key: 'indexPathAbove',\n    value: function indexPathAbove(indexPath) {\n      return this.collectionView.incrementIndexPath(indexPath, -1);\n    }\n  }, {\n    key: 'indexPathBelow',\n    value: function indexPathBelow(indexPath) {\n      return this.collectionView.incrementIndexPath(indexPath, 1);\n    }\n  }]);\n\n  return StackLayout;\n}(_Layout3.default);\n\nexports.default = StackLayout;","map":null,"metadata":{},"sourceType":"script"}