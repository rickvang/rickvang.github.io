{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _DropOperation = require('../DropOperation');\n\nvar _DropOperation2 = _interopRequireDefault(_DropOperation);\n\nvar _utils = require('../utils');\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n} // Map strings used by the HTML5 DnD API to our DropOperation constants.\n\n\nvar DROP_OPERATION = {\n  none: _DropOperation2.default.NONE,\n  move: _DropOperation2.default.MOVE,\n  copy: _DropOperation2.default.COPY,\n  link: _DropOperation2.default.LINK\n};\nvar DROP_OPERATION_ALLOWED = Object.assign({}, DROP_OPERATION, {\n  copyMove: _DropOperation2.default.COPY | _DropOperation2.default.MOVE,\n  copyLink: _DropOperation2.default.COPY | _DropOperation2.default.LINK,\n  linkMove: _DropOperation2.default.LINK | _DropOperation2.default.MOVE,\n  all: _DropOperation2.default.ALL\n});\nvar DROP_EFFECT = (0, _utils.invert)(DROP_OPERATION);\nvar EFFECT_ALLOWED = (0, _utils.invert)(DROP_OPERATION_ALLOWED);\n\nvar DragHandler = function () {\n  function DragHandler() {\n    _classCallCheck(this, DragHandler);\n\n    this.mouseDown = this.mouseDown.bind(this);\n    this.dragStart = this.dragStart.bind(this);\n    this.dragOver = this.dragOver.bind(this);\n    this.dragEnter = this.dragEnter.bind(this);\n    this.dragLeave = this.dragLeave.bind(this);\n    this.dragEnd = this.dragEnd.bind(this);\n    this.drop = this.drop.bind(this);\n    this.views = new Set();\n    this.dragView = null;\n    this.dragX = 0;\n    this.dragY = 0;\n    this.dropEffect = 'none';\n    this.dragOverView = null;\n    this.dragOverElements = new Set();\n    this.hasSetupEvents = false;\n    this.bodyIsDraggable = false;\n  }\n\n  _createClass(DragHandler, [{\n    key: 'setupEvents',\n    value: function setupEvents() {\n      if (this.hasSetupEvents || typeof document === 'undefined') {\n        return;\n      }\n\n      document.addEventListener('mousedown', this.mouseDown, false);\n      document.addEventListener('dragstart', this.dragStart, false);\n      document.addEventListener('dragover', this.dragOver, false);\n      document.addEventListener('dragenter', this.dragEnter, false);\n      document.addEventListener('dragleave', this.dragLeave, false);\n      document.addEventListener('dragend', this.dragEnd, false);\n      document.addEventListener('drop', this.drop, false);\n      this.hasSetupEvents = true;\n    }\n  }, {\n    key: 'teardownEvents',\n    value: function teardownEvents() {\n      if (!this.hasSetupEvents || typeof document === 'undefined') {\n        return;\n      }\n\n      document.removeEventListener('mousedown', this.mouseDown, false);\n      document.removeEventListener('dragstart', this.dragStart, false);\n      document.removeEventListener('dragover', this.dragOver, false);\n      document.removeEventListener('dragenter', this.dragEnter, false);\n      document.removeEventListener('dragleave', this.dragLeave, false);\n      document.removeEventListener('dragend', this.dragEnd, false);\n      document.removeEventListener('drop', this.drop, false);\n      this.bodyIsDraggable = false;\n      this.hasSetupEvents = false;\n    }\n  }, {\n    key: 'registerView',\n    value: function registerView(view) {\n      this.setupEvents();\n      this.views.add(view);\n    }\n  }, {\n    key: 'unregisterView',\n    value: function unregisterView(view) {\n      this.views.delete(view);\n\n      if (this.views.size === 0) {\n        this.teardownEvents();\n      }\n    }\n  }, {\n    key: 'containsPoint',\n    value: function containsPoint(view, event) {\n      var rect = view.getRect();\n      return event.clientX >= rect.x && event.clientX <= rect.maxX && event.clientY >= rect.y && event.clientY <= rect.maxY;\n    }\n  }, {\n    key: 'hitTest',\n    value: function hitTest(event) {\n      var possibleViews = [];\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.views[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _view = _step.value;\n\n          if (this.containsPoint(_view, event)) {\n            possibleViews.push(_view);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (possibleViews.length > 1) {\n        var innerView = null;\n        var _iteratorNormalCompletion2 = true;\n        var _didIteratorError2 = false;\n        var _iteratorError2 = undefined;\n\n        try {\n          for (var _iterator2 = possibleViews[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n            var view = _step2.value;\n\n            if (innerView) {\n              if (innerView.getDOMNode().contains(view.getDOMNode())) {\n                innerView = view;\n              }\n            } else if (view.getDOMNode().contains(event.target)) {\n              innerView = view;\n            }\n          }\n        } catch (err) {\n          _didIteratorError2 = true;\n          _iteratorError2 = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion2 && _iterator2.return) {\n              _iterator2.return();\n            }\n          } finally {\n            if (_didIteratorError2) {\n              throw _iteratorError2;\n            }\n          }\n        }\n\n        return innerView;\n      } else {\n        return possibleViews[0] || null;\n      }\n    }\n  }, {\n    key: '_isElementChildOfCollectionView',\n    value: function _isElementChildOfCollectionView(element) {\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.views[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var view = _step3.value;\n\n          if (view.getDOMNode().contains(element)) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: 'mouseDown',\n    value: function mouseDown(event) {\n      // Firefox has problems focusing text fields if there are any draggable superviews\n      var isTextInput = event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.isContentEditable;\n      var element = event.target;\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this.views[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var view = _step4.value;\n\n          if (view.getDOMNode().contains(element)) {\n            if (isTextInput) {\n              view.removeAttribute('draggable');\n            } else {\n              view.setAttribute('draggable', 'true');\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n    }\n  }, {\n    key: 'dragStart',\n    value: function dragStart(event) {\n      if (!this._isElementChildOfCollectionView(event.target)) {\n        return;\n      }\n\n      var view = this.hitTest(event);\n\n      if (!view) {\n        event.preventDefault();\n        return;\n      }\n\n      var allowedDropOperations = view.dragStart(event);\n\n      if (!allowedDropOperations) {\n        event.preventDefault();\n        return;\n      }\n\n      this.dragView = view;\n      event.dataTransfer.effectAllowed = EFFECT_ALLOWED[allowedDropOperations];\n    }\n  }, {\n    key: 'setDragImage',\n    value: function setDragImage(event, view) {\n      if (!this._isElementChildOfCollectionView(event.target)) {\n        return;\n      } // Edge and IE Specific. Since, setDragImage function is not exposed in both.\n\n\n      if (!event.dataTransfer.setDragImage) {\n        return;\n      } // In Firefox, the drag view must be within the viewport\n\n\n      var mustBeInViewport = 'MozAppearance' in document.documentElement.style;\n      var node = view.getDOMNode().cloneNode(true);\n      node.classList.add('dragging');\n      node.style.zIndex = -100;\n      node.style.position = 'absolute';\n      node.style.top = 0;\n      node.style.left = mustBeInViewport ? 0 : '-100000px';\n      node.style.padding = '10px';\n      document.body.appendChild(node);\n      var size = node.getBoundingClientRect();\n      event.dataTransfer.setDragImage(node, size.width / 2, size.height / 2);\n      setTimeout(function () {\n        document.body.removeChild(node);\n      }, 0);\n    }\n  }, {\n    key: 'dragOver',\n    value: function dragOver(event) {\n      if (!this._isElementChildOfCollectionView(event.target)) {\n        return;\n      }\n\n      event.preventDefault();\n\n      if (event.clientX === this.dragX && event.clientY === this.dragY) {\n        event.dataTransfer.dropEffect = this.dropEffect;\n        return;\n      }\n\n      var allowedOperations = DROP_OPERATION_ALLOWED[event.dataTransfer.effectAllowed];\n      var target = this.hitTest(event);\n\n      if (target !== this.dragOverView) {\n        if (this.dragOverView) {\n          this.dragOverView.dragExited();\n          this.dropEffect = 'none';\n        }\n\n        if (target) {\n          var dropEffect = target.dragEntered(event, allowedOperations);\n          this.dropEffect = DROP_EFFECT[dropEffect] || 'none';\n          this.dragEnteredEffect = this.dropEffect;\n        }\n\n        this.dragOverView = target;\n      }\n\n      if (target && this.dragEnteredEffect !== 'none') {\n        var _dropEffect = target.dragMoved(event, allowedOperations);\n\n        if (_dropEffect != null) {\n          this.dropEffect = DROP_EFFECT[_dropEffect] || 'none';\n        }\n      }\n\n      event.dataTransfer.dropEffect = this.dropEffect;\n      this.dragX = event.clientX;\n      this.dragY = event.clientY;\n    }\n  }, {\n    key: 'dragEnter',\n    value: function dragEnter(event) {\n      this.dragOverElements.add(event.target);\n    }\n  }, {\n    key: 'dragLeave',\n    value: function dragLeave(event) {\n      this.dragOverElements.delete(event.target);\n\n      if (this.dragOverElements.size === 0) {\n        this.dragEnd(event);\n      }\n    } // dragEnd always gets called to remove drag animations\n    // Does not require check to see if it's a collection-view as users can't drag more than one thing at a time\n    // and probably wanna cancel their drag if they go outside the drag area anyways...\n\n  }, {\n    key: 'dragEnd',\n    value: function dragEnd(event) {\n      if (this.dragView) {\n        this.dragView.dragEnd(event, DROP_OPERATION[event.dataTransfer.dropEffect]);\n        this.dragView = null;\n      }\n\n      if (this.dragOverView) {\n        this.dragOverView.dragExited();\n        this.dragOverView = null;\n      }\n\n      this.dragX = 0;\n      this.dragY = 0;\n      this.dropEffect = 'none';\n    }\n  }, {\n    key: 'drop',\n    value: function drop(event) {\n      if (!this._isElementChildOfCollectionView(event.target)) {\n        return;\n      }\n\n      event.preventDefault();\n      var target = this.dragOverView;\n\n      if (!target) {\n        target = this.hitTest(event);\n      }\n\n      if (!target) {\n        return;\n      }\n\n      target.drop(event, DROP_OPERATION[this.dropEffect]);\n      target.dragExited();\n      this.dragOverView = null;\n    }\n  }]);\n\n  return DragHandler;\n}();\n\nexports.default = new DragHandler();","map":null,"metadata":{},"sourceType":"script"}