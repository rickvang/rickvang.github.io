{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _IndexPath = require('./IndexPath');\n\nvar _IndexPath2 = _interopRequireDefault(_IndexPath);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n/*\n * These wrapper objects allow us to store a unique id for each\n * section and item in a collection view. These are used to generate\n * ids for views.\n */\n\n\nvar UID = 0;\n\nvar Section = function Section() {\n  var items = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n  _classCallCheck(this, Section);\n\n  this.id = UID++;\n  this.items = items.map(function (item) {\n    return new Item(item);\n  });\n};\n\nvar Item = function Item(item) {\n  _classCallCheck(this, Item);\n\n  this.id = UID++;\n  this.item = item;\n};\n/**\n * This class is used as a cache of the currently displayed data in a CollectionView.\n * The DataSource may get ahead of what is currently displayed due to animations.\n * CollectionData also provides caching, in case it is slow to compute each item, for example.\n * @private\n */\n\n\nvar CollectionData = function () {\n  function CollectionData(dataSource) {\n    _classCallCheck(this, CollectionData);\n\n    this.dataSource = dataSource;\n    this.sections = [];\n    var numSections = dataSource ? dataSource.getNumberOfSections() : 0;\n\n    for (var section = 0; section < numSections; section++) {\n      var count = dataSource.getSectionLength(section);\n      var items = [];\n\n      for (var index = 0; index < count; index++) {\n        items.push(dataSource.getItem(section, index));\n      }\n\n      this.sections[section] = new Section(items);\n    }\n  }\n\n  _createClass(CollectionData, [{\n    key: 'getNumberOfSections',\n    value: function getNumberOfSections() {\n      return this.sections.length;\n    }\n  }, {\n    key: 'getSectionLength',\n    value: function getSectionLength(section) {\n      if (section < 0 || section >= this.sections.length) {\n        return 0;\n      }\n\n      return this.sections[section].items.length;\n    }\n  }, {\n    key: 'getItemsInSection',\n    value: function getItemsInSection(section) {\n      return this.sections[section].items.map(function (c) {\n        return c.item;\n      });\n    }\n  }, {\n    key: 'getItem',\n    value: function getItem(section, index) {\n      return this.sections[section].items[index].item;\n    }\n  }, {\n    key: 'getSectionID',\n    value: function getSectionID(section) {\n      return this.sections[section].id;\n    }\n  }, {\n    key: 'getItemID',\n    value: function getItemID(section, index) {\n      return this.sections[section].items[index].id;\n    }\n  }, {\n    key: 'getKey',\n    value: function getKey(type, section, index) {\n      // If there is no section, this is a global view not tied to content.\n      // Use the LayoutInfo's type as its id, assuming it will be unique.\n      if (section == null) {\n        return type;\n      } // Get a unique id for this layout info tied to the content.\n      // This id will not change, even if the content is moved around.\n      // If layoutInfo.index is null, the layout info is tied to\n      // a section instead of an individual item.\n\n\n      var id = index == null ? this.getSectionID(section) : this.getItemID(section, index);\n      return type + ':' + id;\n    }\n  }, {\n    key: '_checkIndex',\n    value: function _checkIndex(indexPath) {\n      var insert = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var section = indexPath.section,\n          index = indexPath.index;\n\n      if (section < 0 || section >= this.sections.length) {\n        return false;\n      }\n\n      if (index < 0 || index > this.sections[section].items.length) {\n        return;\n      }\n\n      if (!insert && index === this.sections[section].items.length) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: 'insertItem',\n    value: function insertItem(item, indexPath) {\n      if (!this._checkIndex(indexPath, true)) {\n        return;\n      }\n\n      this.sections[indexPath.section].items.splice(indexPath.index, 0, new Item(item));\n    }\n  }, {\n    key: 'insertSection',\n    value: function insertSection(section, items) {\n      if (section < 0 || section > this.sections.length) {\n        return;\n      }\n\n      this.sections.splice(section, 0, new Section(items));\n    }\n  }, {\n    key: 'removeItem',\n    value: function removeItem(indexPath) {\n      if (!this._checkIndex(indexPath)) {\n        return;\n      }\n\n      this.sections[indexPath.section].items.splice(indexPath.index, 1);\n    }\n  }, {\n    key: 'removeSection',\n    value: function removeSection(section) {\n      if (section < 0 || section >= this.sections.length) {\n        return;\n      }\n\n      this.sections.splice(section, 1);\n    }\n  }, {\n    key: 'moveItem',\n    value: function moveItem(from, to) {\n      if (!this._checkIndex(from)) {\n        return;\n      }\n\n      if (!this._checkIndex(to, true)) {\n        return;\n      }\n\n      var item = this.sections[from.section].items.splice(from.index, 1)[0];\n      this.sections[to.section].items.splice(to.index, 0, item);\n    }\n  }, {\n    key: 'moveSection',\n    value: function moveSection(fromSection, toSection) {\n      if (fromSection < 0 || fromSection >= this.sections.length) {\n        return;\n      }\n\n      if (toSection < 0 || toSection >= this.sections.length) {\n        return;\n      }\n\n      var section = this.sections.splice(fromSection, 1)[0];\n      this.sections.splice(toSection, 0, section);\n    }\n  }, {\n    key: 'replaceItem',\n    value: function replaceItem(indexPath, item, retainID) {\n      if (!this._checkIndex(indexPath)) {\n        return;\n      }\n\n      var items = this.sections[indexPath.section].items;\n\n      if (retainID) {\n        items[indexPath.index].item = item;\n      } else {\n        items[indexPath.index] = new Item(item);\n      }\n    }\n  }, {\n    key: 'replaceSection',\n    value: function replaceSection(section, items) {\n      if (section < 0 || section >= this.sections.length) {\n        return;\n      }\n\n      this.sections[section] = new Section(items);\n    }\n  }, {\n    key: 'incrementIndexPath',\n    value: function incrementIndexPath(indexPath, amount) {\n      var section = indexPath.section,\n          index = indexPath.index;\n\n      if (amount < 0) {\n        amount = -amount;\n\n        while (section >= 0 && amount > 0) {\n          var amt = Math.min(amount, index);\n          amount -= amt;\n          index -= amt;\n\n          while (amount > 0 && --section >= 0 && (index = this.getSectionLength(section)) === 0) {\n            continue;\n          }\n        }\n      } else {\n        while (section < this.sections.length && amount > 0) {\n          var sectionLength = this.getSectionLength(section);\n\n          var _amt = Math.min(amount, sectionLength - index);\n\n          amount -= _amt;\n          index += _amt;\n\n          if (amount > 0 || index === sectionLength) {\n            do {\n              section++;\n            } while (section < this.sections.length && this.getSectionLength(section) === 0);\n\n            index = 0;\n          }\n        }\n      }\n\n      if (section >= this.sections.length || section < 0) {\n        return null;\n      }\n\n      return new _IndexPath2.default(section, index);\n    }\n  }, {\n    key: 'firstIndexPath',\n    get: function get() {\n      for (var section = 0; section < this.sections.length; section++) {\n        if (this.getSectionLength(section) > 0) {\n          return new _IndexPath2.default(section, 0);\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: 'lastIndexPath',\n    get: function get() {\n      for (var section = this.sections.length - 1; section >= 0; section--) {\n        var len = this.getSectionLength(section);\n\n        if (len > 0) {\n          return new _IndexPath2.default(section, len - 1);\n        }\n      }\n\n      return null;\n    }\n  }]);\n\n  return CollectionData;\n}();\n\nexports.default = CollectionData;","map":null,"metadata":{},"sourceType":"script"}